/* Du_模块中慎用vmalloc */

模块中慎用vmalloc，多用__get_free_pages
既然这样问，那么答案必然是否：）先来说一个案例：

我们写了一个模块，用来加载逻辑驱动，如果编译时静态链接到内核，则运行正常；但如果链接成ko文件，然后通过insmod装载到内核，那么运行的过程中，不定期出现错误：“Unaligned kernel access ”。



由于问题难以重现，所以定位非常困难，只能逐行检查代码，整理思路。同样的代码，在x86下运行没有任何问题，因此，我怀疑很可能是因为MIPS指令集将不对齐指令和对齐指令分得很细，而出于效率的考虑，编译器把C源码中的内存访问都强制解释成对齐指令导致的。因为x86执行不对齐的内存访问时，仅仅是多消耗一些CPU时钟，不会产生异常，MIPS却比较严格。



因为这个猜测能解释通我们目前遇到的现象，并且在错误难以重现的情况下，阅读海量的汇编指令是非常困难的。所以我沿着这个思路走，把模块加载过程和卸载过程分成几个阶段，每个阶段打桩测试。结果惊喜地发现在vmalloc了一个10M的空间然后立即释放并卸载模块的时候，同样的错误出现了。这基本证明了未对齐的内存访问应该就是vmalloc引入的。

vmalloc请求__vmalloc_node以可睡眠的方式（GFP_KERNEL），从高端内存（__GFP_HIGHMEM）分配地址空间并映射到内核页表（PAGE_KERNEL）。


可见，vmalloc绝对不可在中断上下文调用。
__get_free_pages为我们在内核空间申请大量内存提供了另外一种途径。令人欣慰的是，用它申请的内存，在物理上也是连续的。这里不详细分析这个函数的具体实现，内核对一次动态分配连续物理内存的数量做了限制，目前是2的11次方个页，我们可以根据拥有的物理内存总数，调整MAX_ORDER宏来扩大或者缩小这个范围。这个函数非常事宜在动态加载的模块中使用，但必须注意的是，模块尽量在系统启动完成之后不长的时间内加载，一旦出现了大量内存碎片，再想分配连续的物理页就很难了。


linux内核对vlan的支持是遵循8021.q实现的，并且其设计和编码都很富有技巧。如果看懂了这部分内容，那么，可以说对linux的网络驱动模型就有了比较深入的理解，你会发现内核网络驱动接口设计的如此之巧妙，堪为我们做软件设计的范例。 阅读本文之前，你必须对Linux网络设备驱动和网络协议栈模型有所了解。否则，就需要先补充这方面的知识。对于网络设备驱动，建议参考3c59x.c和e100.c；对与网络协议栈模型，建议阅读《深入理解Linux网络技术内幕》。


