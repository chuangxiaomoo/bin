# Linux

# 16、TCP/IP通信建立的过程怎样，端口有什么作用？ 　　

TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。

建立起一个TCP连接需要经过“三次握手”：

第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主 动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客 户端交互，最终确定断开）


# 第25题：引用与指针有什么区别？

1) 引用必须被初始化，指针不必。

2) 引用初始化以后不能被改变，指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

# 第28题：内存的分配方式有几种?

【参考答案】

一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。

二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

 
# 1. 输出结果

```cpp
  int arr[]={5,6,7,8,9,10};
  int *ptr=arr;
  *(ptr++)+=123;
  printf(＂%d,%d＂,*ptr,*(++ptr));
```

# 2. 输出结果

```cpp
void footprint(int first_run, int count)
{
    if ((!first_run) || (++count)) {
        printf("%d\n", count);
    }
}


int main(int argc, char *argv[])
{
    footprint(0, 4);
    return 0;
}
```

# 3. 编写 helloworld.c

1. 简述预处理(preprocess)、汇编(assemble)、编译(compile)、链接(link)、执行(run)对源文件或可执行文件都做了什么？
2. 编写 helloworld.c，实现打印输出 "Hello World!"
3. 写出 gcc 进行上述操作的命令。

# 4. 编写标准宏 MIN()，这个宏输入两个参数并返回较小的一个

# 5. 编写标准宏 DBG(fmt, args...)，将文件与行号同时打印到 stdout 和 stderr

# 6. 如何避免头文件被重复包含？

# 7. 函数定义时，数组名和指针指针作为参数，有什么区别？

    int func(char *p)
    int func(char p[])

# 8. 定义一个指向函数的指针，一个指向二维数组类型的指针？

# 9. 实现冒泡算法

# 10. 不使用库函数，实现函数 atoi()，将字串转换为整形？

