# Questions

1 什么是进程，什么是线程，二者的区别？

2 线程间通信的机制及比较？

3 什么是死锁，举例说明？
    两人过独木桥
    互斥条件。          东西不够
    不可抢占条件。      不可抢占
    占有且申请条件。
    循环等待条件。
4 volatile的作用，及应用场景？

5 什么是watchdog？其作用及应用场景？

6 private, public, protect 的作用？

7 指针与引用的区别？

8 构造与析构的顺序

9 程序指错

a 3x3数组旋转
                  +--+--+--+--+
                  |  |  |  |  |
                  +--+--+--+--+
                  |  |  |  |  |
                  +--+--+--+--+
                  |  |  |  |  |
                  +--+--+--+--+
                  | S|  |  |  |
                  +--+--+--+--+
  1 先保存左下角
  2 每一次挪动，90°对称的4个点，依次完成
  3 关键: 4个点的描述
  4 相信两点的关系
    a. P1,P2中一个坐标相同 P1.x = P2.y
    b. P1,P2另一个坐标互补 P1.y + P2.x = n-1
  5 两层循环条件
```cpp
    // k-kernel
    for (k = 0; k < n/2; k++)
    // i-side
      for (i = 0; i < (n-1)-2*k; i++)
          int temp = mat[n-1-k-i][k];
```

b 条件变量

条件变量的使用总是和一个互斥锁结合在一起。例如管道间的读写同步。

```cpp
// pthread_cond_wait会先解除之前的pthread_mutex_lock锁定的mtx，
// 然后阻塞在等待对列里休眠，直到再次被唤醒（大多数情况下是等待的条件成立而被唤醒，
// 唤醒后，该进程会先锁定先pthread_mutex_lock(&mtx);，再读取资源
// 用这个流程是比较清楚的
// block-->unlock-->wait() return-->lock
pthread_cond_wait(&cond, &mtx);
```
