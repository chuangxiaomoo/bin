# 任务.异步IO

# Server端处理高并发网络请求主要方法

循环：早期系统使用简单的循环选择解决方案，即循环遍历打开的网络连接的列表，判断是否有要读取的数据。这种方法既缓慢（尤其是随着连接数量增加越来越慢），又低效（因为在处理当前连接时其他连接可能正在发送请求并等待响应）。在系统循环遍历每个连接时，其他连接不得不等待。如果有 100 个连接，其中只有一个有数据，那么仍然必须处理其他 99 个连接，才能轮到真正需要处理的连接。

socket IO复用：这是对循环方法的改进，它用一个结构保存要监视的每个连接的数组，当在socket发现数据时会select/epoll调用会返回到用户空间，然后可以继续后续处理。

异步socket IO：利用现代内核中的多线程支持监听和处理连接，为每个连接启动一个新线程。这把责任直接交给操作系统，但是会在 RAM 和 CPU 方面增加相当大的开销，因为每个线程都需要自己的执行空间。另外，如果每个线程都忙于处理网络连接，线程之间的上下文切换会很频繁。这里的异步其实是不是真正的异步，模拟异步IO，将IO的操作交给专门的thread来处理而异。

# 系统中任务主要可分为4类

1. timer.定时任务
2. delay.延时任务
3. bgread.网络
4

create_BGread_schedule()
create_time_engine()

delay_ctrl_exec(DELAY_CMD_SETETHMAC, outer.mac, sizeof(outer.mac));
eventNotify(JEvent_EthMacCfgChg);

