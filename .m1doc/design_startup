# Do right thing and do thing right.

[敏捷开发中的分析与设计](http://terryyin.blogbus.com/logs/121558164.html)

# 02_分析

[需求分析、概要设计、详细设计](http://topic.csdn.net/t/20050906/11/4252256.html)

> 没有文档，有时我也很冤枉
> 1. 日志现在写一个300k的文件要3秒，为什么这么久都没有人发现？
> 2. 延时抓拍功能来自方安，为什么没有任何屏蔽措施？就在主干里了。

标签：
需求分析：requirement analysis    -- 客户能明白，市场人员能看懂的，可以吹的
概要设计：preliminary design      -- 
详细设计：detailed design

架构师      (迭代与层次、框架)
系统工程师  (如何测试、集成)
软件工程师

# <一> 需求分析（requirement analysis）

  需求分析是当前软件工程中的关键问题。需求分析阶段的任务是：在可行性分析的基础
  上，进一步了解、确定用户需求，准确地回答`系统必须做什么`的问题。获得需求规格
  说明书。还涉及到软件系统的目标、软件系统提供的服务、软件系统的约束和软件系统
  运行的环境。它还涉及到这些因素和系统的精确规格说明，以及系统进化之间的关系。

  需求分析的基本任务包括：

  • 抽取需求: 分析现行系统存在需要解决的问题。获取足够多的问题领域的知识，需求
    抽取的方法一般有问卷法、面谈法、数据采集法、用例法、情景实例法以及基于目标
    的方法等；还有知识工程方法，例如，场记分析法、卡片分类法、分类表格技术和基
    于模型的知识获取等。

  • 模拟和分析需求：需求分析和模拟又包含三个层次的工作。首先是需求建模。需求模
    型的表现形式有自然语言、半形式化(如图、表、结构化英语等)和形式化表示等三种
    。需求概念模型的要求包括实现的独立性；不模拟数据的表示和内部组织等；需求模
    拟技术又分为企业模拟、功能需求模拟和非功能需求模拟等。

  • 传递需求：传递需求的主要任务是书写软件`需求规格说明`--`功能、性能、约束`。

  • 认可需求：就是对需求规格说明达成一致，其主要任务是冲突求解，包括定义冲突和
    冲突求解两方面。常用的冲突求解方法有：协商、竞争、仲裁、强制、教育等，其中
    有些只能用人的因素去控制。

  • 进化需求：客户的需要总是不断(连续)地增长，但是一般的软件开发又总是落后于客
    户需求的增长，如何管理需求的进化(变化)就成为软件进化的首要问题。对于传统的
    变化管理过程来说，其基本成分包括软件配置、软件基线和变化审查小组。当前的发
    展是软件家族法，即产品线方法。多视点方法也是管理需求变化的一种新方法，它可
    以用于管理不一致性，并进行关于变化的推理。

    需求目的：视频基本特性要求。
    需求描述：
    应用场合：
    使用频度：
    优先级：
    验收准则：
    需求来源：
    需求分配：
    注释与问题：分开说明

# <二> 概要设计

  概要设计是在需求分析的基础上通过抽象和分解将系统分解成模块，确定系统功能是实
  现。

  概要设计基本任务：

  • 建立软件系统结构：划分模块、定义模块功能、模块间的调用关系、定义模块的接口
    、评价模块的质量

  • 数据结构和数据库的设计：数据结构设计、概念设计、逻辑设计、物理设计

  • 编写概要设计文档：概要设计说明书、用户手册、数据库设计说明书、修订测试计划


# <三> 详细设计

  • 详细设计说明书

1 引言
    1.1 编写目的
         编写这份详细设计说明书的目的（指出预期的读者）。
    1.2 背景
         待开发软件系统的相关。
    1.3 名称解释
         列出本文档中用到的有必要解释的术语。此术语可能在其他文档中用到。
    1.4 参考资料

  列出编写本报告时参考的文件(如经核准的计划任务书或合同、上级机关的批文等)、资料、技术标准，
  以及他们的作者、标题、编号、发布日期和出版单位。


2 程序系统结构

3 类设计
  3.1 命名空间(命名空间下可再加子命名空间,以此类推,相应序号加层)
       3.1.1 类名称
            3.1.1.1 类功能说明：
    3.1.1.2 父类
            3.1.1.3 成员变量
            3.1.1.4 成员函数列表
            3.1.1.5 成员函数设计
                 3.1.1.5.1 函数名:
                      3.1.1.5.1.1 功能描述
                      3.1.1.5.1.2 输入
                      3.1.1.5.1.3 返回值
                      3.1.1.5.1.4 流程图
                      3.1.1.5.1.5 算法说明
                 3.1.1.5.2 函数名
                      …
         3.1.2 类名称
               ….
  3.2 命名空间
     ….

# 敏捷开发---Story设计

在迭代开始后，通常以一个一个Story分别完成开发的。先由SE给Story开发人员、测试人员以及资料人员进行需求**串讲**工作，详细介绍Story的业务实现和功能要求。 

开发、测试、资料人员以头脑风暴的形式一起讨论，SE和对应这个Story的开发人员、测试人员、资料人员要在这个Story的理解上**达成一致**，大体的实现方案，并且要思考如何测试这个Story，这也体现了测试先行的理念。

开发人员根据讨论的结果形成Story设计文档，并根据设计文档给SE进行**反串讲**工作，得到SE确认通过后才可以开始编码。 

Story设计完成标准： 

a. 各个模块的接口确认清楚；
b. 简单设计方案通过评审； 
c. 补充和更新AT用例； 
d. 测试用例方案通过评审；

如在Story测试阶段需要做性能测试，则在测试方案中要明确说明； 

# 敏捷开发真正的重点不是 User Story 的拆分, 而是开发人员的能力

谈到敏捷开发, 许多人纠结的第一个问题便是: User Story 如何的划分? 更有不少人, 一遇到在 User Story 上有延迟交付或交付的质量不佳时, 便说是因为 User Story 的拆分不对, 就整天在纠结所谓 User Story 颗粒度大小的问题。

然而, 事实的真相是如何呢?

首先, 先从敏捷开发实践的本身说起：

敏捷开发之所以强调 “敏捷” , 主要是希望藉由 User Story 的划分 , 能帮助开发人员, 有效的管理版本开发上需求的复杂度, 而使开发人员能在最短的时间内 “发现自身的问题”, “发现自身的不足”, “发现因自身的问题、不足与外部的变化所造成的风险” 。

所以, 敏捷开发的核心基础, 最强调的便是: “User Story 必需要是可测的” 与 “User Story 间的持续集成” 。

接下来再谈一下, 人的思维、人的一念之间是如何严重的扭曲了敏捷开发?!

当一个开发人员, 他 (她) 只是在证明自己“`没做错事`” 时, 而不是在 “`发现自身的问题`” 时, 那在拆分User Story 上, 便会发生这些场景:

1. 将 User Story 拆的需 3 周甚至一个月以上才能完成; 这样的思维与作法, 只是在证明自身所负责开发的 User Story 是可被 “测试的” 。但, 却只是被 “测试人员可测试的” ; 也就是说, 有的开发人员希望将 User Story 要拆的 “够大”, 只是要掩饰自身无法做 “有效” 的 “开发者自动化测试” 罢了。

2. 将 User Story 拆的只需完成单一且极简单的 “功能点”; 这样的思维与作法, 只是在证明自身所负责开发的 User Story 是可被 “如期交付的” ; 也就是说, 有的开发人员希望要将 User Story 拆的 “够小”, 只是要`掩饰`自身无法理解与掌握 “`完整的业务场景`” 与 “`软件架构`” 罢了。

所以, 我们要纠结的不应该是所谓 User Story 颗粒度大小的问题; 而是应协助开发人员能诚实的发现与面对自身的不足与所面临的问题, 并给予开发人员适当且必要的赋能与协助。因为, 唯有如此, 开发人员的能力提升了, 则开发人员便自然能在 “更短的时间内” “真正有质量 (有品味)” 的完成 “复杂度越高” 的User Story。

所以, 我们要纠结的不应该是所谓 User Story 颗粒度大小的问题; 我们应该真正专注的是: 如何能使开发人员能在 “更短的时间内” “真正有质量 (有品味)” 的完成 “复杂度高” 的 User Story。

# IPD流程含义

TR1   需求基线
TR2   功能基线/特性基线
TR3   分配基线
TR4   代码基线
TR4A  软硬件基本功能基线
TR5   产品基线
TR6   发布基线

GA    一般性可获得性
