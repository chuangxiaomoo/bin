#! /bin/awk

# [awk](http://www.cnblogs.com/276815076/archive/2011/12/05/2276625.html)

# 分隔.多分隔
    echo "a=b"         | awk -F'=' '{print $1}'
    echo "1{2[3,4]5|6" | awk -F"[{|,[\]]" '{ print $1,$2,$3,$4,$5}'
    echo "1{2[3,4]5|6" | awk -F'[{|,[\]]' '{ print $1,$2,$3,$4,$5}'
    echo "1{2[3,4]5|6" | awk 'BEGIN{ FS="[|,]" } { print $1,$2,$3,$4,$5}'

# codingstyle
    format_of_awk() {
        awk 'BEGIN { cnt=0 } 
            { if($5 < 0) { cnt++ } } 
            END { printf("%s\n", cnt) }
        ' $1
    }

# 传递参数

    pass_para2awk() {
        #! /bin/sh
        raw_srcfile="abc.c"
        raw_srcfile2="fff.c"
        strip_srcfile=`awk -v str=$raw_srcfile -v str2=$raw_srcfile2 'BEGIN {
                    gsub(/\.c/, "", str)
                    print str
                    gsub(/\.c/, "", str2)
                    print str2
                }' 
        `
        echo $strip_srcfile
    } 

# for
    awk '{ 
        for (i = 2; i <= NF; i++)
                printf("%s ", $i)
                printf("\n")
    }' filename

# bit and or 

function fn_calc()
{
    case $1 in
    and) echo ${@:2}   | awk '{ ret=$1; for (i = 2; i <= NF; i++) { ret=and(ret,$i) }; print ret; }'  ;;
     or) echo ${@:2}   | awk '{ ret=$1; for (i = 2; i <= NF; i++) { ret=or(ret,$i) }; print ret; }'   ;;
      *) cmdline="echo | awk '{printf \"%d\n\", ${*} }'"; eval $cmdline                               ;;
    esac
}

# array 数组 (http://www.cnblogs.com/chengmo/archive/2010/10/08/1846190.html)

    Tarray[1]=“cheng mo”
    Tarray[2]=“800927”

    Tarray[“first”]=“cheng ”
    Tarray[“last”]=”mo”
    Tarray[“birth”]=”800927”

# 无序
awk 'BEGIN{info="it is a test";split(info,tA," ");      
    for(k in tA){print k,tA[k];}}'    

# 有序 -- 注意：数组下标是从1开始，与c数组不一样。
awk 'BEGIN{info="it is a test";tlen=split(info,tA," "); 
    for(k=1;k<=tlen;k++){print k,tA[k];}}' 


# next 跳过next指令之后的所有语句，包括next之后的所有Pattern {Actions}
    '{ ...; next; ...; }'

# 内置函数

    . substr
    # awk中等价于${string:pos:length}的命令是 substr(string,pos,length).
    # 使用一个空的"echo"通过管道给 awk 一个假的输入, 这样可以不用提供一个文件名.
    echo | awk '{ 
        print substr("'"${String}"'",3,4) # skid
    }'

# 比较字符串

 直接用 <, ==, > 比较符比较。
 echo | awk 'a="test";b="test";if(a==b) print "a equals b"'
 echo | awk 'a="test";b="test123";if(a<b) print "a is less than b"'

# 正则
    awk '/foo/ { print $0 }' BBS-list

    cat <<-"HERE"
        cfile=jcp_cmd.c
        JCP_CMD_REG("timecfg", JCPCmdTimeCfg, &(RegCmdWorkList.RegCmd_list));
    HERE

    awk -F'"' '/JCP_CMD_REG/ { print $2}' $cfile | sort | \
    awk '{ i++; printf "%-16s", $1; if (0 == i%4) print ""; }'

# 正则取反 !

    root@Moo64:~/txt# cat input 
    123
    456
    root@Moo64:~/txt# cat input | awk '!/123/ {print $1}' 
    456

# gawk中使用位运算和用例
    http://blog.csdn.net/cmatch/article/details/2976538
    e.g.
    awk '$2=="A" && $3=="P" && and($4,0x00001)==1' /tmp/adzone.xml

# 格式化汉字

    function fn_fmt_hexun() {
        awk -F',' -v v_data=$DATA -v v_time=$TIME '{ 
            synlen = " %-12s ";
            if (length($2) < 9) {
                synlen = " %-10s "; 
            } else if (length($2) < 12) { 
                synlen = " %-11s "; 
            }

            printf "%-6s" synlen "%-6s %-6s %-6s %-6s %-6s %-6s %-12s %-12s %-6s %-6s %-6s\n", \
                       $1,    $2, $3,   $4,   $5,  $6, $7, $8,  $9,   $10,   $11, $12, $13
        }' $1
    }

# [内置变量表](http://www.cnblogs.com/chengmo/archive/2010/10/06/1844818.html)
    ┌───────────────┬──────────────────────────────────────────────────┐
    │   属性        │ 说明                                             │
    ├───────────────┼──────────────────────────────────────────────────┤
    │   $0          │ 当前记录（作为单个变量）                         │
    │   $1~$n       │ 当前记录的第n个字段，字段间由FS分隔              │
    │   FS          │ 输入字段分隔符默认是空格                         │
    │   NF          │ 当前记录中的字段个数，就是有多少列               │
    │   NR          │ 已经读出的记录数，就是行号，从1开始              │
    │   ARGC        │ 命令行参数个数                                   │
    │   ARGV        │ 命令行参数数组                                   │
    │   FILENAME    │ 当前输入文件的名字                               │
    │   IGNORECASE  │ 如果为真，则进行忽略大小写的匹配                 │
    │   CONVFMT     │ 数字转换格式 %.6g                                │
    │   FIELDWIDTHS │ 输入字段宽度的空白分隔字符串                     │
    │   FNR         │ 当前记录数                                       │
    └───────────────┴──────────────────────────────────────────────────┘
