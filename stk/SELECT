#! /bin/bash
. `dirname ${0}`/'dbank' || { echo "dbank err" && exit; }
. /etc/common.rc

function fn_ls()
{
    [ $# -eq "0" ] && fn_execute -l && exit

    if fn_isdigit $1; then
        code=$1
    else
        local shmout=$SHMPATH/shmout
        local index=1
        echo "google  $1 ..."
        google $1 | tee $shmout
        [ 0 -ne  "${PIPESTATUS[0]}" ] && echo google fail && exit 1

        lines=`cat $shmout | grep '^[603]' | wc -l`
        [ 0 -eq "$lines" ] && echo "Error: no symbol $1 found" && exit
        if [ 1 -eq "$lines" ]; then
            code=`awk '/^[603]/{print $1}' $shmout`
            echo $code
        else
            while :; do
                cat -n $shmout
                read -p "    Please input index[1]:" index
                [ "${index:=1}" -le $lines ] && let index-- && break
            done
            codes=(`awk '{print $1}' $shmout`)
            code=${codes[$index]}
        fi
    fi

    fields='d.code,d.date,d.yesc,d.open,d.high,d.low,d.close,d.volume,d.amount'
    echo "
    SELECT nmc/close FROM cap WHERE code=${code} LIMIT 1 INTO @shares0;
    SELECT * FROM (
        SELECT $fields, $PEAK as peak, $TROUGH as trough, $RISE as rise, $TURNOV0 as turnover
        FROM day as d
        WHERE d.code = ${code} and d.date <= '${END}'
        ${COND} ORDER by date DESC limit ${LIMIT:-13}
    ) as tbl ORDER by date ASC;
	" | mysql -t kts
}

function fn_get_open_days()
{
    # 统计13日下跌 配合 SCREENER 3 做相应选股
    if [ -z "${2}" ] ; then
        mysql -N kts <<< "SELECT date from day WHERE code = 900001 " | tail -${1:-13}
    else
        mysql -N kts <<< "SELECT date from day WHERE code = 900001 " | tail -${1:-13} | tac | cat -n
    fi
}

function fn_lsd()
{
    # where d.code = c.code 非常重要，不重叠的field不需要加‘tbl_name.’
    columns="code,yesc,open,close"
    columns=${columns:-'*'}
    columns=d.${columns//,/,d.}
    TEMPDAY='day'

    fn_yist 
    echo ----- LIST:${#LIST[@]} COND@${END}: $COND -----


    case $1 in
    t|top)
        LIMIT=2000
        HAVING="rise>9.93"
        field=${2:-nmc}
        ;;
    f|floor)
        LIMIT=2000
        HAVING="rise<-9.93"
        field=${2:-nmc}
        ;;
    l|list)
        TAM=${END} SELECT lohi l; exit 0;
        ;;
    [0-9]*)
        if [ "${1}" = 0 ]; then
            LIMIT=2000 HAVING='rise>0' SELECT lsd
            exit 0;
        fi
        LIMIT=${LIMIT:-2000}
        field=${2:-rise}
        DT=`DT="${END} 15:05:00" SELECT dorat | sed -n "${1}p"`
        # echo ${DT}; exit
        DT=(${DT})
        TEMPDAY="(SELECT * FROM dorat WHERE date='${DT[0]}' && time='${DT[1]}')"
        HAVING="rise>0"
        ;;
    *)
        field=${1:-rise}
        ;;
    esac

    function fn_sql()
    {
        sqls="
        SELECT $columns, volume,amount, 
                $RISE as rise, 
                $TURNOV as tov, c.nmc, c.name
                FROM ${TEMPDAY} as d,cap as c where d.code = c.code and d.date = '${END}' 
                HAVING ${HAVING:-1} ${COND} ${inLIST} ORDER BY ${field} ${ASC:-desc} limit ${LIMIT:-36}
        " 
        # echo "${sqls}"
    }
    fn_sql $@ 
    mysql -t kts <<<"${sqls}"

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"SELECT code FROM (${sqls}) as tbl" > $file_c 
    up file_to_table $file_c
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_ace()
{
    dates=(`mysql -N kts <<< "SELECT date from day WHERE code=900001 ORDER by date DESC LIMIT ${LIMIT:-1},10"`)

    function fn_sql()
    {
        sqls="SELECT code FROM day as d where d.date = '${date:-$1}' and ${RISE}>9.93 " 
        #echo ${sqls}
    }

    > .soptter.ace
    local i=
    for i in ${dates[@]}; do
        fn_sql $i 
        mysql -N kts <<<"${sqls}" >> .soptter.ace
    done

    sort -u .soptter.ace -o .soptter.ace
    echo "Selcect `wc -l<.soptter.ace` From (${dates[@]}) into .soptter.ace"
        
    return $?
}

function fn_get_comma_cloumns()
{
    # code,date,yesc,open,high,low,close,volume,amount
    # echo "SELECT * FROM ${1:-day} limit 1" | mysql kts  | head -1  | tr '\t' ','
    mysql kts -N<<<"DESCRIBE ${1:-day};" | awk '{printf "%s,", $1} END{printf "\n"}' | sed 's/,$//g'
}


function fn_dt_hyphen_2_normal()
{
    dt0=${1:0:10} 
    dt1=${1:11:8}
    echo "${dt0//_/-} ${dt1//_/:}"
    return $?
}

function fn_dt_normal_2_hyphen()
{
    echo "${1//-/_}_${2//:/_}"
    return $?
}

# fn_dt_hyphen_2_normal 2015_08_11_11_02_21
# fn_dt_normal_2_hyphen 2015-08-11 11:02:21

function fn_rat()
{
    # 0. Make sure U've done [up 4]?
    # 1. 以PREV为标，自动处理生成 tbl_mavol520s，只需上午更新一次 tbl_mavol520s
    # 2. 使用多表tbl_mavol520s tbl_day`联合查询`得到数据
    field=${1:-v1v5}

    DT=(${DT:-`mysql -N kts<<<"SELECT date,time FROM stamp_day ORDER by id DESC LIMIT 1"`})
    SCALE=`DT=${DT[@]} fn_get_ratio_close2open`
    # echo ${SCALE}; exit
    tov="round(100*(d.volume)/(c.nmc/c.close),2)"
    tov5="round(100*(ma.vol5)/(c.nmc/c.close),2)"
    tov20="round(100*(ma.vol20)/(c.nmc/c.close),2)"
    v1v5="round(5*d.volume*${SCALE}/(ma.vol5),2)"       
    # v5vT="round(4*ma.vol5/(ma.vol20),2)"
    # ${v5vT} as v5vT, 

    TBL=${TBL:-cap} END=${PREV} ./SCREENER wma

    fn_yist
    tbl_day="(SELECT * FROM dorat WHERE date='${DT[0]}' && time='${DT[1]}' ${inLIST})"

    function fn_build_sqls() {
    sqls="
    SELECT d.code,DATE_FORMAT(d.date,'%m-%d')as date,d.yesc,d.open,d.low,d.close,
        round(100*((d.open+low)/2-d.yesc)/d.yesc,2) as av_open, 
        round(100*(d.close-(d.open+low)/2)/((d.open+low)/2),2) as av_rise,
        round(100*(d.close-d.yesc)/d.yesc,2) as rise, 
        ${tov} as tov, 
        ${tov5} as tov5,
        ${tov20}as tov20,
        ${v1v5} as v1v5, 
        d.amount,c.nmc,c.name FROM tbl_mavol520s as ma, 
        ${tbl_day} as d, cap as c
        WHERE ma.code=d.code and ma.code=c.code 
        HAVING 1 ${COND} ORDER by ${field} ${ASC:-DESC} limit ${LIMIT:-36}" 
    }
    fn_build_sqls

    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls"

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"SELECT code FROM (${sqls}) as tbl" > $file_c.rat 
    up file_to_table $file_c.rat
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_tri()
{
    field=${1:-rising}
    STEP=${STEP:-7}
    # D3=(${DT:-`mysql -N kts<<<"SELECT date FROM day WHERE code=900001 and date<='${END}' ORDER by date DESC LIMIT 0,1"`})
    D2=${END}
    D1=${DT:-`mysql -N kts<<<"SELECT date FROM day WHERE code=900001 and date<'${END}' ORDER by date DESC LIMIT 0,1"`}
    D0=${DT:-`mysql -N kts<<<"SELECT date FROM day WHERE code=900001 and date<'${END}' ORDER by date DESC LIMIT ${STEP},1"`}
    
    t2="(SELECT * FROM day WHERE date='${D2}')"
    t1="(SELECT * FROM day WHERE date='${D1}')"
    t0="(SELECT * FROM day WHERE date='${D0}')"

    function fn_build_sqls() {
    product="TRUNCATE(100*(tbl.close-(tbl.amount/tbl.volume))/tbl.close,2)"
    sqls="
    SELECT * FROM (SELECT '${END}' as date, d.code, d.close, 
        $RISE as rise,
        round(100*(t1.close-t0.yesc)/t0.yesc, 2) as rising, ${STEP}+1 as D, 
        c.nmc, c.name FROM 
        ${t2} as d, 
        ${t1} as t1, 
        ${t0} as t0, cap as c
        WHERE d.code=t1.code && d.code=t0.code and d.code=c.code   -- 取样本数40 = 2000*20%，7天可翻倍
              ORDER by rising DESC limit 40 ) as t
        ${COND} ORDER by ${field:-rising} ${ASC:-DESC} limit ${LIMIT:-40}
    " 
    }
    fn_build_sqls
    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls"

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"SELECT code FROM (${sqls}) as tbl" > $file_c 
    up file_to_table $file_c
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_dif3()
{
    DT=`SELECT dorat|tail -1`
    DP=(`cat ${date_dif3} 2> /dev/null`)
    DT3=(${DT})

    [ "${DT3[0]}${DT3[1]}.${STEP:-1}" = "${DP[0]}${DP[1]}" ] && return 0

    DT="${DT}" ./up ma2015
    xt_ret $? "ma2015" || return $?

    dts="SELECT DISTINCT date,time FROM dorat"
    odr="ORDER by date DESC, time DESC"
    DT2=(${DT2:-`mysql -N kts<<<"${dts} WHERE date<='${DT3[0]}' && time<='${DT3[1]}' ${odr} LIMIT ${STEP:-1},1"`})
    DT1=(${DT1:-`mysql -N kts<<<"${dts} WHERE date<='${DT2[0]}' && time<='${DT2[1]}' ${odr} LIMIT ${STEP:-1},1"`})
    DT0=(${DT0:-`mysql -N kts<<<"${dts} WHERE date<='${DT3[0]}' && time<='09:47:00'  ${odr} LIMIT 1"`})

    echo "${DT3[@]}.${STEP:-1}" > ${date_dif3}
    TEMPORARY=TEMPORARY

    echo "
    DROP   TABLE IF EXISTS dif3;
    CREATE TABLE IF NOT EXISTS dif3 (
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        yesc        DECIMAL(6,2) NOT NULL DEFAULT 0,
        open        DECIMAL(6,2) NOT NULL DEFAULT 0,
        high        DECIMAL(6,2) NOT NULL DEFAULT 0,
        low         DECIMAL(6,2) NOT NULL DEFAULT 0,
        close       DECIMAL(6,2) NOT NULL DEFAULT 0,
        avrg        DECIMAL(6,2) NOT NULL DEFAULT 0,
        ma20        DECIMAL(6,2) NOT NULL DEFAULT 0,
        close2      DECIMAL(6,2) NOT NULL DEFAULT 0,
        close1      DECIMAL(6,2) NOT NULL DEFAULT 0,
        volume      DECIMAL(12,2) NOT NULL DEFAULT 0,
        amount      DECIMAL(12,2) NOT NULL DEFAULT 0,
        -- dif
        av_op       DECIMAL(6,2) NOT NULL DEFAULT 0,
        rise        DECIMAL(6,2) NOT NULL DEFAULT 0,
        dirtio      DECIMAL(6,2) NOT NULL DEFAULT 0,            -- 增量量比 dif-vol-ratio
        pie         DECIMAL(8,1) NOT NULL DEFAULT 0,            -- 增量额度，以万为单位
        INDEX(code)
    );
    DROP   $TEMPORARY TABLE IF EXISTS t2,t1,t0;
    CREATE $TEMPORARY TABLE IF NOT EXISTS t2 (
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        close       DECIMAL(6,2) NOT NULL,
        volume      DECIMAL(12,2) NOT NULL,
        amount      DECIMAL(12,2) NOT NULL,
        INDEX(code)
    );
    CREATE $TEMPORARY TABLE t1 LIKE t2;
    CREATE $TEMPORARY TABLE t0 LIKE t2;
    INSERT INTO dif3(code,yesc,open,high,low,close,volume,amount) SELECT code,yesc,open,high,low,
                               close,volume,amount FROM dorat WHERE date='${DT3[0]}' and time='${DT3[1]}' and code<698765;
    INSERT INTO t2 SELECT code,close,volume,amount FROM dorat WHERE date='${DT2[0]}' and time='${DT2[1]}';
    INSERT INTO t1 SELECT code,close,volume,amount FROM dorat WHERE date='${DT1[0]}' and time='${DT1[1]}';
    INSERT INTO t0 SELECT code,close,volume,amount FROM dorat WHERE date='${DT0[0]}' and time='${DT0[1]}';

    UPDATE dif3    SET avrg=(amount/volume), rise=100*(close-yesc)/yesc;
    UPDATE dif3,t0 SET av_op=100*((t0.amount/t0.volume)-dif3.yesc)/dif3.yesc WHERE dif3.code=t0.code;
    UPDATE dif3 INNER JOIN ma2015 on dif3.code=ma2015.code SET dif3.ma20=ma2015.ma2015;
    DELETE FROM dif3 WHERE ma20=0;

    UPDATE dif3 INNER JOIN t2 on dif3.code=t2.code 
                INNER JOIN t1 on t2.code=t1.code
                      SET close2=t2.close,
                          close1=t1.close,
                          dirtio=(dif3.volume-t2.volume)/(t2.volume-t1.volume),
                          pie=(dif3.amount-t2.amount);                              -- 以万为单位

    " | mysql kts
    xt_ret $? "fail: mysql" || return $?

    fn_echo_succ "    succ: up dif3!"
}

function fn_dirtio()
{
    # sec_dt=$(date +%s -d "${DT3[*]}")
    # sec_dp=$(date +%s -d "${DT2[*]}")
    # sec_open=$(expr $sec_dt - $sec_dp) 
    # [ "${sec_open}" -gt 5400 ] && let sec_open-=5400
    # SCALE=$(bc -l <<<"scale=2; 14400/${sec_open}")
    # echo ${SCALE}; exit
    case $1 in
    u|usage)
        echo "
        SELECT dirtio <param>
        usage: print usage
        list : print list of Date Time
        i25  : insert 2.5min data
        d25  : delete 2.5min data
        c1   : cond1: rise>0&& av_op>2&&av_op<5 && close2<close1 && close2<close && pie>1000 && av_ri<2 
                      0轴上    高开2~5%            低走             再上行          1000万      不涨太快
                      1. 一直运行在ma20(F1)上方
                      2. 先破ma20(F1)，在10:00前后突破之
        c2   : cond2: 
        c3   : cond3: 
        c4   : cond4: 
        1~48 : DT=list[1~48]
        "
        exit 0
        ;;
    l|list)
        SELECT dorat | cat -n; exit 0
        ;;
    [0-9]*)
        let min=3*${STEP:-1}
        [ ${1} -ge ${min} ] && [ "${1}" -le 48 ] || { 
            fn_echo_fail "fail: $1 -ge ${min} && $1 -le 48"; exit 1; 
        }
        DT=`SELECT dorat | sed -n "${1}p"` 
        # echo ${DT};exit
        ;;
    *)
        field=$1
        ;;
    esac
    field=${field:-$2}

    fn_dif3 ${@} # up DT, with param 'up', update dif3
    fn_yist


    SCALE=`fn_get_ratio_close2open`
    xt_ret $? "" || return $?

    v1x1="round(48*(d.volume-t2.volume)/d.volume*${SCALE},2)"       
    tov5="round(100*(ma.vol5)/(c.nmc/c.close),2)"
    tov1="round(100*(d.volume)/(c.nmc/c.close),2)"
    tovt="round((ma.vol20)/(c.nmc/c.close),1)"
    columns='ma20,avrg,close,close2,close1,av_op,rise'
    columns=d.${columns//,/,d.}

    function fn_build_sqls() {
    sqls="
    SELECT d.code, ${columns},
        ${tovt} as tovt,
        ${tov5} as tov5,
        ${tov1} as tov1,                                        -- 有tov，不必volume
        round(d.amount/10000,2) as pie_Yi,
        round(5*d.volume*$SCALE/(ma.vol5),2) as v1x5,           -- 普通量比
        dirtio,pie,
        round(c.nmc/10000, 1) as nmc_Yi, c.name 
        FROM dif3 as d, tbl_mavol520s as ma, cap as c           -- USE INDEX(code)
        WHERE d.code=ma.code && d.code=c.code                   -- av_ri = rise-av_op
        HAVING 1 ${COND} ${inLIST} 
        ORDER by ${field:-dirtio} ${ASC:-DESC} limit ${LIMIT:-32}" 
    }
    fn_build_sqls

    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls" | sed -e 's/    |$/|/g' -e 's/----+$/+/g'
    xt_ret $? "" || return $?

    fn_echo_warn "dif3@${DT3[@]}.${STEP:-1}"
    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"SELECT code FROM (${sqls}) as tbl" > ${file_c}.dir
    up file_to_table ${file_c}.dir
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_wma()
{
    # 1. Make sure U've done [SCREENER 2]?
    # 2. 使用单表tbl_mavol520s作差得到数据
    SCALE=`fn_get_ratio_close2open`
    columns=code,close,ma5,ma10,ma20
    columns=t.${columns//,/,t.}

    fn_yist 
    echo ----- LIST:${#LIST[@]} COND@${END}: $COND -----

    sqls="
    SELECT ${columns}, 
    ${SCALE}*vol       as mavol,
    round(vol5 / 5,2)  as mavol5, 
    round(vol20/ 20,2) as mavol20, 
    round(vol60/ 60,2) as mavol60, 
    round(4*${SCALE}*vol/(vol5-vol),2)  as v1v4,
    c.nmc, c.name
    FROM tbl_mavol520s as t, cap as c WHERE t.code=c.code 
    HAVING 1 ${COND} ${inLIST}
    ORDER by ${1:-v1v4} ${ASC:-DESC} LIMIT ${LIMIT:-24}
    " 
    echo "${sqls}" | tee /dev/stderr | mysql $mo -t kts

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"SELECT code FROM (${sqls}) as tbl" > $file_c 
    up file_to_table $file_c
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_updown()
{
    NUM=${NUM:-5}
    START=`./SELECT get_open_days ${NUM} | head -1`

    echo "
    From ${START} to ${END}...
    "

    cd $workdir
    > $mps_god
    head -n -5 $mps_org >> $mps_god

    echo "
    SET @START='$START';
    SET @END='$END';
    SET @NUM=${NUM};
    call sp_stat_change();
    SELECT * FROM tbl_stat_change ORDER by ${field:-date} ${ASC:-ASC};
    " | tee /dev/stderr >> $mps_god

    mysql $mo -t kts <<< "source $mps_god"

    return
}

function fn_6maishenjian()
{   # date1,date2,amount,
    columns="off,open,close,turnov"
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    DATE2=${DATE2:-${END}}
    [ -s "${exclude1}" ] && EXCLUDE="and code not in (`cat ${exclude1}`)"

    echo ----- COND: $COND -----
    function fn_get_tbl_6jian_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${DATE2}';
        "
        tbl_super_dive="
        SELECT t.code, DATE_FORMAT(date1,'%m-%d') as start, 
                       DATE_FORMAT(date2,'%m-%d') as end, ${columns}, c.nmc, chng, 
                       round(100*(t.low  - avrg)/avrg,2) as lchng, 
                       round(100*(t.close- avrg)/avrg,2) as wchng, 
                       round(100*(d.close- avrg)/avrg,2) as avrg_up, 
                       round(100*(d.close-(t.close+t.low)/2)/avrg,2) as trough_up, 
                       round((avrg-d.close)/(d.close-(t.close+t.low)/2),2) as odds, 
                       c.name 
            FROM ${tablex:-tbl_6mai} as t, cap as c, tempday as d
            WHERE t.code = c.code and t.code = d.code HAVING 1 ${COND} ${EXCLUDE}
            ORDER by ${1:-wchng} ${ASC:-asc} limit ${LIMIT:-36}     # COND='nmc<250000 and lchng<-9.7 and off<21'
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_6jian_dive $1
    mysql $mo -t kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?
    
    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"${tempday}SELECT code FROM (${tbl_super_dive}) as tbl" > $file_c 
    up file_to_table $file_c
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_dugu9jian()
{   # date1,date2,amount,open
    columns="off,turnov,avrg,close"
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    DATE2=`mysql -N kts <<< "SELECT date2 from ${tablex:-tbl_9jian} LIMIT 1"`
    [ -s "${exclude0}" ] && EXCLUDE="and code not in (`cat ${exclude0}`)"

    echo ----- COND: $COND -----
    function fn_get_tbl_9jian_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${DATE2}';
        "
        tbl_super_dive="
        SELECT t.code,  DATE_FORMAT(date1,'%m-%d') as start, 
                        DATE_FORMAT(date2,'%m-%d') as end, ${columns}, 
                        round(avrg*(1-${ORACLE:-10}/100),2) as oracle, 
                        c.nmc, chng, 
                        $RISE as rise, 
                        $PEAK as peak, 
                        $TROUGH as trough,
                        round(100*(t.low-avrg)/avrg,2) as lchng, 
                        round(100*(t.close-avrg)/avrg,2) as wchng, 
                        c.name 
           FROM ${tablex:-tbl_9jian} as t, cap as c, tempday as d
           WHERE t.code = c.code and t.code = d.code HAVING 1 ${COND} ${EXCLUDE}
           ORDER by ${1:-lchng} ${ASC:-asc} limit ${LIMIT:-36}      # COND='nmc<250000 and lchng<-9.7 and off<21' 
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_9jian_dive $1
    mysql ${mo:-'-t'} kts <<< "${tempday}${tbl_super_dive}"
    xt_ret ${PIPESTATUS[0]} "${FUNCNAME}" || return $?
    
    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"${tempday}SELECT code FROM (${tbl_super_dive}) as tbl" > $file_c 
    up file_to_table $file_c
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_tao5()
{
   #columns=date_p,date_c,off_p,off_c,tnov_p,tnov_c,avrg_p,avrg_c,ratio
    columns=date_p,off_p,date_c,off_c,tnov_c,avrg_p,avrg_c,ratio,wchng
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    echo ----- COND: $COND -----
    function fn_get_tbl_tao5_dive()
    {
        tbl_super_dive="
        SELECT t.code, ${columns}, c.nmc,c.name 
           FROM ${tablex:-tbl_tao5} as t, cap as c 
           WHERE t.code = c.code HAVING 1 ${COND} limit ${LIMIT:-144}
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_tao5_dive $1
    mysql $mo -t kts <<< "${tbl_super_dive}" |\
        sed -e '1,3s/----+$/\+/g' -e '$s/----+$/\+/g' -e '2s/    |$/|/g'
    xt_ret ${PIPESTATUS[0]} "${FUNCNAME}" || return $?
}

function fn_rdiff()
{
   #columns=date_p,date_c,off_p,off_c,tnov_p,tnov_c,avrg_p,avrg_c,ratio,dbrat
    columns=date_p,date_c,off_p,off_c,tnov_c,close,avrg_p,avrg_c,ratio,cdiff,rdiff,wchng
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    echo ----- COND: $COND -----
    function fn_get_tbl_rdiff_dive()
    {
        tbl_super_dive="
        SELECT t.id,t.code,
        ${columns}, (wchng+2*rdiff+3*cdiff) as fire
           -- , c.nmc, c.name
           FROM ${tablex:-tbl_rdiff} as t, cap as c 
           WHERE t.code = c.code HAVING 1 ${COND} limit ${LIMIT:-144}
        "
        # echo "${tbl_super_dive}"
        fn_name `mysql -N kts <<<"SELECT code FROM ${tablex:-tbl_rdiff} LIMIT 1"`
    }

    fn_get_tbl_rdiff_dive $1
    mysql $mo -t kts <<< "${tbl_super_dive}" 
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_acc() { tablex=tbl_adiff fn_rdiff; }

function fn_pma()
{
    fn_iscode $1
    xt_ret $? "" || return $?

    END=${END:-`fn_maxdate`}
    NUM=${NUM:=5}

    # enable d2，则tov扩大10倍
    echo "
    SELECT close FROM day WHERE code=$1 and date='$END' INTO @iclose;
    SELECT d.code, '${END}' as date, sum(d.amount)/sum(d.volume) as ma${NUM}, @iclose,
        round(100 * (@iclose-sum(d.amount)/sum(d.volume))/@iclose, 2) as pcnt,
        round(100*sum(d.volume)/cap.shares, 2) as tov${NUM}
        FROM 
        (SELECT * FROM day WHERE code=$1 and date<='$END' ORDER by date DESC LIMIT ${NUM}) as d,
        cap WHERE d.code = cap.code ;
    " | mysql -t kts
    # SELECT sum((high-yesc)/yesc) FROM day WHERE code = 2 and date > '2014-11-03'; 
    return $?
}

function fn_name()
{
    fn_iscode ${code:=${1}}
    xt_ret $? "Usage: name code" || exit $?

    echo "SELECT code, 
            TRUNCATE(nmc/10000, 1) as nmc, 
            -- TRUNCATE(shares/10000,2) as shares, 
            name FROM cap WHERE code=${code}
    " | mysql kts
    xt_ret $? "" || return $?
}

function fn_fbi()
{
    # code,datetime_p,datetime_c,dbrat
    columns='off_p,off_c,tnov_c,close,avrg_p,avrg_c,ratio,cdiff,rdiff,wchng'

    fn_name `mysql -N kts <<<"SELECT code FROM ${tablex:-tbl_fdiff} LIMIT 1"`
    echo "
        SELECT id,
        -- datetime_p, 
        TRUNCATE(datetime_p%(1000000000000)/1000000,4) as dt_p,
        -- datetime_c, 
        TRUNCATE(datetime_c%(1000000000000)/1000000,4) as dt_c, ${columns}, 
        round(close+(avrg_c-close)*.618 - close*ratio*.00236, 2) *              -- close as space
           IF((avrg_c-close)*.618 - close*ratio*.00236<0, -1, 1) as oracle,     -- ratio as time
        (wchng+2*rdiff+3*cdiff) as fire
        FROM ${tablex:-tbl_fdiff} LIMIT ${LIMIT:-200}
    " | mysql -t kts
}


function fn_acf() { tablex=tbl_acfdiff fn_fbi; }

function fn_vol()
{
    fn_yist
    get_vol() 
    {
    echo "
    SELECT date, sum(volume), sum(amount), sum(amount)/sum(volume) as trade 
        FROM day WHERE date<='${END}' ${COND} ${inLIST}
        GROUP by date 
        ORDER by date DESC
        LIMIT ${LIMIT:-13};
    " | mysql -t kts
    }

    case $1 in
    0)
        COND='and code<100000'
        ;;
    3)
        COND='and code>=300000 and code<400000'
        ;;
    6)
        COND='and code>=600000 and code<700000'
        ;;
    03)
        COND='and code<400000'
        ;;
    *)
        COND='and code<700000'
        ;;
    esac

    get_vol
    return $?
}

function fn_dorat()
{
    case $1 in
    *)
        # echo DT is ${DT} > /dev/stderr
        [ -n "${DT}" ] && DT=(${DT}) && 
        COND0="WHERE DATE_FORMAT(CONCAT(date, ' ', time), '%Y-%m-%d %T')<='${DT[@]}'"
        odr="ORDER by date DESC, time DESC"
        # date<='${DT[0]}' and time<='${DT[1]}'"
        mysql -N kts<<< "SELECT date,time FROM ( SELECT DISTINCT date, time FROM dorat ) as t ${COND0} ${odr} LIMIT ${LIMIT:-48}"
        #fn_execute -l | grep dorat && exit
        ;;
    esac

    return $?
}


function fn_td_layout()
{
    fn_iscode ${code:=${1}}
    xt_ret $? "" || return $?
    dates=`mysql -N kts <<< "SELECT DISTINCT round(datetime/1000000,0) from fenbi WHERE code=${code}"`

    mysql kts <<< "TRUNCATE tmpfb";

    local i=
    for i in ${dates}; do
        # SELECT date FROM day WHERE code=${code} and date=
        echo "
        INSERT INTO tmpfb(code,datetime,trade,volume,amount)
        SELECT code,datetime%1000000,trade,volume,amount FROM fenbi 
            WHERE code=${code} and round(datetime/1000000, 0)=${i} 
            ORDER by trade ${ASC:-DESC} LIMIT 1; 
        " | mysql kts -t
        xt_ret $? "" || return $?
    done 

    mysql -t kts <<< "SELECT * FROM tmpfb ORDER by datetime DESC";

    return $?
}

function fn_dif120()
{
    if [ -z "${YIST}" ]; then
        fn_iscode $1 
        xt_ret $? "" || { echo "Usage: 120 code... {END}" && exit; }
        YIST=${file_ma120}
        xargs -n1 <<<"${*}" | sed 's/^0*//g' | xargs printf "%06d\n" > ${YIST}
    fi

    fn_yist 
    echo ----- LIST:${#LIST[@]} COND@${END}: $COND -----

    tbl_day="(SELECT * FROM day WHERE date='${END}' ${inLIST})"

    sqls="
    SELECT d.code,d.date,d.close,ma120,100*(d.close-ma120)/ma120 as rise, c.name 
        ${sqls} FROM ${tbl_day} as d, 
        tbl_ma240 as t, 
        cap as c WHERE t.code=d.code and t.code=c.code 
        HAVING 1 ${inLIST} ORDER by rise ASC
    "
    mysql -t kts<<<"${sqls}"
    xt_ret $? "${FUNCNAME}" || return $?

    return 0
}

function fn_ma240_usage()
{
    echo "
    1 x_mid x_one 双线出击
    2 牛市step2 ma240收敛 & cross & 放量上行
    3 联合查询1 x_sho && NUM_RATIO=2 SCREENER 0
    4 联合查询2 强者恒强 平台突破 开山股份
    "
}

function fn_ma240()
{
    # 0. Make sure U've done [SCREENER ma240]?
    columns=code,date,close,ma5                     # ,ma5,ma10,ma20,ma60 # ,ma120,ma240
    columns=ma.${columns//,/,ma.}
    function fn_build_sqls() {
    sqls="SELECT date FROM day WHERE code=900001 and date<='${END}' ORDER by date DESC LIMIT 4,1"
    ago5=`mysql -N kts<<<"${sqls}" 2>/dev/null`
    field=${1:-x_5}
    sqls="
    SELECT ${columns},
        round(100*(ma.close-ma5  )/ma5  ,1)as pma5,
        round(100*(ma.close-ma20 )/ma20 ,1)as pma20,
        round(100*(ma.close-ma60 )/ma60 ,1)as pma60,
        round(100*(ma.close-ma120)/ma120,1)as pma120,
        ${x_5} as x_5, 
        ${x_sho} as x_sho,          -- 5 10 20
        ${x_mid} as x_mid,          -- 20 60 120
        ${x_long} as x_long,        -- 60 120 240
        ${x_sho}+
        ${x_mid}+
        ${x_long} as x_6line,       -- 一阳穿3线
        c.nmc,c.name FROM tbl_ma240 as ma, cap as c
        WHERE ma.code=c.code and ma5!=0 and ma.date>'${ago5}' 
        HAVING 1 and pma5>-5 and pma5<10       -- -5%是趋势必须
        ${COND} ${inLIST} ORDER by ${field} ${ASC:-ASC} limit ${LIMIT:-24}" 
    }

    # .0001 使得新股 x_sho x_long 都为 2.000
    # mid 5day 5week 5month
       x_5="round(abs((ma.close-ma5)/(ma5))*IF((ma.close-ma5)<0, -1, 1), 3)"
     x_sho="round(abs((ma5-ma10)/(ma10))+abs((ma20-ma10)/(ma10)), 3)"
    x_long="round(abs((ma60-ma120)/(ma120))+abs((ma240-ma120)/(ma120)), 3)"
     x_mid="round(abs((ma20-ma60)/(ma60))+abs((ma120-ma60)/(ma60)), 3)"

    fn_yist
    fn_build_sqls $1
    echo ----- LIST:${#LIST[@]} COND@${END}: $COND -----
    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls"

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"SELECT code FROM (${sqls}) as tbl" > $file_ma240
    up file_to_table $file_ma240
    xt_ret $? "${FUNCNAME}" || return $?
}


function fn_hilo()
{
    columns='code,date1,date2,off,turnov,tovpd,rat1,rat2,high,low,close,chng'
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    [ -s "${exclude2}" ] && EXCLUDE="and code not in (`cat ${exclude2}`)"

    function fn_yi_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${CURR}';
        "
        # delete停牌个股
        tbl_super_dive="
        -- rat1:最低日lo量比 rat2:lo+(lo+1)日量比
        SELECT ${columns}, 
        round(100*(d.close-t.high)/t.high, 2) as dive, 
        round(100*(d.close-t.close)/t.close, 2) as rebound, c.nmc, c.name   -- t.close=(open+close)/2
        FROM tbl_hilo as t, tempday as d, cap as c
        WHERE t.code = d.code and t.code=c.code
        HAVING 1 ${COND} ${EXCLUDE}
        ORDER by ${1:-chng} ${ASC:-ASC} LIMIT ${LIMIT:-36}
        "
        echo "${tbl_super_dive}"
    }

    fn_yi_dive $1
    mysql $mo -t kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"${tempday}SELECT code FROM (${tbl_super_dive}) as tbl" > ${file_c}
    xt_ret $? "" || return $?

    up file_to_table $file_c
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_lohi()
{
    columns='code,date1,date2,off,high,low,lohi'
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    DROP="DROP TABLE IF EXISTS "
    iNUM=${NUM:-5}
    TAM=${TAM//END/${END}}                                              # TAM代表mat_lohi中最高日期，亦TEMPDAY的日期
    TAM=${TAM:-`mysql -N kts <<< "SELECT max(end) from mat_lohi"`}      # 开市后才能指定MAT
    iTEMP=${TAM}
    iCURR=`END=${TAM} fn_get_prev`
    iPREV=`END=${iCURR} fn_get_prev`                                    # prev+temp = 灵活推演

    # echo END: ${END} TAM:${TAM} temp:${iTEMP} curr: ${iCURR} prev:${iPREV}; exit

    hilo_temp="( SELECT * FROM mat_lohi WHERE end='${iTEMP}' and num=${iNUM} )"
    hilo_curr="( SELECT * FROM mat_lohi WHERE end='${iCURR}' and num=${iNUM} )"
    hilo_prev="( SELECT * FROM mat_lohi WHERE end='${iPREV}' and num=${iNUM} )"
       d_temp="SELECT * from day where date='${iTEMP}'"     # 最新day数据，可以是开市数据
       d_curr="SELECT * from day where date='${iCURR}'"     # 次新day数据，必是必市后数据

    inout_codes="
    $DROP        d_temp;
    CREATE TABLE d_temp LIKE day;
    INSERT INTO  d_temp ${d_temp};
    $DROP        d_curr;
    CREATE TABLE d_curr LIKE day;
    INSERT INTO  d_curr ${d_curr};

    $DROP        prev_codes;
    CREATE TABLE prev_codes LIKE codes;
    INSERT INTO  prev_codes(code) 
        SELECT code FROM (
            SELECT t.code, round(100*(d.close-t.low)/t.low, 2) as incr
            FROM ${hilo_prev} as t, d_curr as d
            WHERE t.code=d.code ORDER by incr DESC LIMIT ${LIMIT:-40}    -- PREV排名前40
        ) as t;

    $DROP        curr_codes;
    CREATE TABLE curr_codes LIKE codes;
    INSERT INTO  curr_codes(code) 
        SELECT code FROM (
            SELECT t.code, round(100*(d.close-t.low)/t.low, 2) as incr
            FROM ${hilo_curr} as t, d_temp as d
            WHERE t.code=d.code ORDER by incr DESC LIMIT ${LIMIT:-40}    -- CURR排名前40
        ) as t;

    $DROP        sit_codes;
    CREATE TABLE sit_codes LIKE codes;
    INSERT INTO  sit_codes(code) SELECT p.code FROM prev_codes as p, curr_codes as c  WHERE p.code=c.code;

    $DROP        out_codes;
    CREATE TABLE out_codes LIKE codes;
    INSERT INTO  out_codes(code) SELECT code FROM prev_codes WHERE code NOT IN(SELECT code FROM curr_codes);

    $DROP         in_codes;
    CREATE TABLE  in_codes LIKE codes;
    INSERT INTO   in_codes(code) SELECT code FROM curr_codes WHERE code NOT IN(SELECT code FROM prev_codes);
    "

    function fn_in_or_out()
    {
      echo "
      SELECT * FROM (
        SELECT ${columns}, 
        round(100*(d.close-t.low)/t.low, 2)  as incr,
        round(100*(d.close-t.high)/t.low, 2) as decn,
        ${RISE} as rise,
        round((d.volume/t.mavol5), 2) as tov,
        round((d.amount/10000), 1) as eYi,
        round((c.nmc/10000), 1) as nmcYi, c.name  
        FROM ${hilo_curr} as t, d_temp as d, cap as c
        WHERE t.code=d.code and t.code=c.code
        HAVING 1 ${EXCLUDE}
        ORDER by incr ${ASC:-DESC} ) as newton
        WHERE code IN (SELECT code FROM ${1}_codes)                 -- 新进 = 今天前40-(2天的交集)
      HAVING ${HAVING:-1} ORDER by ${field:-incr} ${ASC:-DESC}      -- 淘汰 = 昨天前40-(2天的交集)
      "
    }

    field=$1
    case $1 in
    in|out|sit)
        field=$2
        fn_echo_warn "$1 of TAM=${iTEMP}"
        function fn_yi_descend()
        {
          tempday="${inout_codes}"
          tbl_super_dive=`fn_in_or_out $1`
          fn_echo_erro "${tbl_super_dive}"
        }
        ;;
    l|list)
        DT="${iTEMP} 15:05:00" SELECT dorat | cat -n; exit 0
        ;;
    [0-9]*|'')
        if [ -z "${1}" ]; then
            TEMPDAY="tempday"
            iTEMP=`END=${iTEMP} fn_get_next`    # 仅开市时间使用，取最新。闭市时间，请使用 SELECT lohi 1
            iTEMP=${iTEMP:-${TAM}}
            tempday="
            $DROP tempday; CREATE TABLE tempday LIKE day;
            INSERT INTO tempday SELECT * from day where date='${iTEMP}';
            "
        else
            field=$2
            DT=`DT="${iTEMP} 15:05:00" SELECT dorat | sed -n "${1}p"`
            # echo ${DT}; exit
            DT=(${DT})
            TEMPDAY="(SELECT * FROM dorat WHERE date='${DT[0]}' && time='${DT[1]}')"
        fi
        function fn_yi_descend()
        {
          # delete停牌个股
          tbl_super_dive="
          SELECT * FROM (
            SELECT ${columns}, 
            round(100*(d.close-t.low)/t.low, 2)  as incr,
            round(100*(d.close-t.high)/t.low, 2) as decn,
            round(100*(d.amount/d.volume-d.yesc)/d.yesc, 2) as avri,
            ${RISE} as rise,
            round((d.volume/t.mavol5), 2) as tov,
            round((d.amount/10000), 1) as eYi,
            round((c.nmc/10000), 1) as nmcYi, c.name  
            FROM ${hilo_curr} as t, 
            ${TEMPDAY} as d, cap as c
            WHERE t.code = d.code and t.code=c.code HAVING 1 ${COND} ${EXCLUDE}
            ORDER by incr ${ASC:-DESC} LIMIT ${LIMIT:-40} ) as t
          HAVING ${HAVING:-1} ORDER by ${field:-incr} ${ASC:-DESC}
          "
          echo "${tempday}${tbl_super_dive}"
        }
        ;;
    u|*)
        echo "
        SELECT lohi <param>
            in : exist dates
            out: dates list with num
            0-9: tempday from dorat
            '' : 仅开市时间使用，取最新。闭市时间，请使用 SELECT lohi 1
            *  : usage
        "
        exit
        ;;
    esac

    [ -s "${exclude2}" ] && EXCLUDE="and code not in (`cat ${exclude2}`)"

    fn_yi_descend $1
    mysql $mo -t kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?
    fn_echo_warn "$1 of iTEMP=${iTEMP}"

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return

    mysql -N kts <<<"${tempday}SELECT code FROM (${tbl_super_dive}) as tbl" > ${file_c}.desc
    xt_ret $? "" || return $?

    up file_to_table $file_c.desc
    xt_ret $? "${FUNCNAME}" || return $?
}


function fn_xrd()
{
    mysql kts <<<"SELECT * from xRD WHERE date${OP:->}'${END}' order by ${1:-date} ASC"
    return $?
}

function fn_cap()
{
    if [ -n "${1}" ]; then
        COND="code=${1}"
    elif [ -f "${YIST}" ]; then
        fn_yist
    else
        fn_execute -l && exit
    fi

    mysql -t kts <<<"SELECT * FROM cap WHERE ${COND:-1} ${inLIST} ORDER by nmc DESC;"
    return $?
}

function fn_lhb()
{
    sql="SELECT max(date) FROM lhb"
    max_dt=`mysql -N kts <<< "${sql}"`
    case $1 in
    e|exception)
        mysql -t kts <<<"SELECT DISTINCT cause FROM lhb"
        mysql -t kts <<<"SELECT * FROM lhb WHERE date='${max_dt}' and (
                            cause='tov_to_20' or 
                            cause='rzrq_to_50')"
        ;;
    '')
        fn_execute -l | grep "lhb" && exit
        ;;
    *)
        field=${1:-rise}
            ;;
    esac
    
    return $?
}


function fn_macd()
{
    fn_yist
    case $1 in
    c|clean)
        echo "DROP TABLE IF EXISTS mm55" | mysql kts; 
        fn_echo_succ "succ: clean macd!"; exit 0
        ;;
    [0-9]*)
        COND="and code=$1"
        field=$2
        ;;
    *)
        field=$1
        ;;
    esac

    fields='close,fa15,ma5,ma10,ma20,ma40,ma80,mavol5,mavol20'
    limo='(FM=15)*IF(close>=fa15, 1, -1)*((fa15>=ma5)+(fa15>=ma10)+(fa15>=ma20)+(fa15>=ma40)+(fa15>=ma80))'
    echo "
    SELECT code,FM,datetime%1000000 as time,
        ${fields}, TRUNCATE(mavol5/mavol20, 2) as nb,
        round(abs((close-fa15)/fa15/.01), 2) as abs,
            -- cvgenc, 
            ${limo} as limo, dif,macd FROM mm55
            HAVING 1 ${COND} ${inLIST}
            ORDER by ${field:-code},FM ${ASC:-ASC};
	" | mysql -t kts
    
    return $?
}

function fn_main()
{
    # mysql CURRENT_DATE();
    CURR=`fn_maxdate`
    END=${END:-${CURR}}
    PREV=`fn_get_prev`

    cmdlist=(
    "dugu9jian          [sortfield]           # nine sword"
    "6maishenjian       [sortfield]           # #{DATE2} to specify diff-day"
    "get_comma_cloumns  [tbl_name:-day]       # 逗分列名"
    "get_open_days      [LIMIT:-13 [desc]]    # 开市日列表"
    "wma                [sortfield:tov5]      # 均价+现成513.静态rat"
    "rat                [sortfield:-ratio]    # wma+day-->动态rat，实时速度快"
    "dorat                                    # 时间为表名list"
    "dirtio                                   # diff(dorat)"
    "ma240              [sortfield:-ratio]    # "
    "ma240_usage        {1~9}                 # 分析ma 5 13 34 55"
    "dif120             code...               # cost:(close-ma120) & sort by #{ASC:id}"
    # ----------------  ABOVE IS FIXED SEQUENCE --------------------
    "xrd                field                 # #{OP:->}"
    "ace                                      # +10%"
    "td_layout          code                  # 日内最高价时点分布.10:00am"
    "cap                code                  # 查询nmc&cap"
    "name               code                  # 名"
    "pma                code                  # NUM=5日平均"
    "fbi                                      # tbl_fbi"
    "acc                                      # tbl_adiff"
    "acf                                      # tbl_acfdiff"
    "tao5                                     # "
    "rdiff                                    # tbl_rdiff"
    "vol                {0|3|6|03}            # ^^3市成交^^"
    "ls                 {code|symbol}         # 日线数据 \$LIMIT"
    "lsd                [{top|floor}][field]  # --- END YIST LIMIT 涨幅排名"
    "updown                                   # 近期{NUM=13}涨跌家数统计"
    "hilo               field                 # field to sort by"
    "lohi               field                 # field to sort by"
    "lhb                excption              # 龙虎榜"
    "macd               [clean]               # macd-alarm-sys"
    "tri                                      # 3连阳"
    )

    # `ASC=任意值`时使用'DESC'，弃用
    # ASC=${ASC:+'DESC'}  # ASC=${ASC:-'ASC'}
    # ASC=${ASC:-'ASC'}
    fn_execute "$@"
}

fn_main "$@"

# http://www.cnblogs.com/zhenjing/archive/2011/07/15/process_mutex_race.html
# 获取最大ID的记录

