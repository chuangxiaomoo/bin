#! /bin/bash
. `dirname ${0}`/'dbank' || { echo "dbank err" && exit; }
. /etc/common.rc

function fn_ls()
{
    [ $# -eq "0" ] && fn_execute -l && exit

    fn_iscode ${code:=$1}
    xt_ret $? "Error: [$1] no a code" || return $?

    fields='d.code,d.date,d.yesc,d.open,d.high,d.low,d.close,d.volume,d.amount'
    sqls_pro="SELECT nmc/close FROM cap WHERE code=${code} LIMIT 1 INTO @shares0;" # @shares0供TURNOV0使用
    sqls="
    SELECT * FROM (
        SELECT $fields,
        $RISE as rise, 
        ${sql_avrg}
        $TURNOV0 as tov
        FROM day as d
        WHERE d.code = ${code} and d.date <= '${END}'
        ORDER by date DESC
    ) as tbl HAVING 1 ${COND} ORDER by ${FIELD:-date} DESC LIMIT ${LIMIT:-24}
	"
    fn_imysql_sqls
}


function fn_lsf()
{
    cols='date,time,code,yesc,open,high,low,close,volume,ROUND(amount/10000,2) as eYi'
    echo "
    SELECT ${cols} FROM dorat WHERE date='${END}' AND code=${1} ORDER by time ASC LIMIT ${2:-0},${LIMIT:-20}
    " | mysql -t kts
    fn_echo_succ "Usage: LIMIT=xx lsf code \$2 ---> LIMIT \${2:-${2:-0}},${LIMIT:-20}"
    return $?
}

function fn_update_mavol5()
{
    # 切换日期，则确保OK
    idate=`mysql -N kts <<<"SELECT DISTINCT end FROM t_mavol5"`

    if [ "${idate}" != ${PREV} ]; then
        #fn_echo_succ 'update mavol5...'
        #SCREENER使用全codes后，不再需要修正
        iCOND="num=${NUM:-8}" xCol=end fn_xCol mat_lohi t_mavol5 ${PREV}
        xt_ret $? "To avoid this WARNING: END=${PREV} SCREENER lohi 1" || exit $?
    fi
}

function fn_update_matov5()
{
    # 切换日期，则确保OK
    idate=`mysql -N kts <<<"SELECT DISTINCT date FROM t_matov5"`

    if [ "${idate}" != ${PREV} ]; then
        xCol=date fn_xCol matov5 t_matov5 ${PREV} || { 
            fn_echo_warn "SIMPLE building..., FULL-MATOV5-CMD: END=${PREV} SCREENER matov5 1";
            __FAST__=1 END=${PREV} SCREENER matov5 1; xCol=date fn_xCol matov5 t_matov5 ${PREV} 
        }
        xt_ret $? "To avoid this WARNING: END=${PREV} SCREENER matov5 1" || exit $?
    fi
}

function fn_pro_header_30min()
{
    PARTS=s fn_prop $1 > ${chao}.prop
    PROP0=`fn_carbon get prop0`
    PROP5=`fn_carbon get prop5`
    hhmmss=${iTime:-${date_T}}
   #[ "${hhmmss//:/}" -lt 103000 ] && PROP="$PROP5"  # 是否考虑1小时后用平均值 ${PROP0}
}

function fn_pro_hammer()
{
    [ -z "${is_hammer:-${is_spacer:-${is_wolves}}}" ] && return 1

    _VAX="(${TURNOV}/vax60>${PROP0} && ${TURNOV}/vax3>3.8*${PROP0})"                    # 4倍放量 + 超vax60 = 超放当日
    VBI3="(100*d.volume*c.close/c.nmc)/(.25*t5.tov+.75*vax3)"                           # 平滑大波动tov
    BOOST="GREATEST(${VBI3}/${PROP0}, 1)"                                               # 保范围 1~+OO
    BOOST="2.5*LEAST(${BOOST}-1, 4)"                                                    # 保上限 5

    REALIZ='(ma5/((ma5+ma10+ma20)/3) -1)'
    REALIZED='(d.close/((ma5+ma10+ma20)/3) -1)'                                         # 涨幅 = ma5涨幅 * 相应乘数  .03= 1/5+1/10
    REALIZED2="IF($REALIZED>0, ${REALIZED}, 0)"

   #RIFLE='ROUND(IF(wk12>=wk23, .90*wk12+.20*wk23, .80*wk23+.30*wk12) -1.1, 2)'         # wk12占更大权重
    RIFLE='LEAST(99, ROUND((GREATEST(wk12,wk23)-1)*.2+(LEAST(wk12,wk23)-1)*.8 ,2))'     # tov5接近20%，i_wk在5在内可将阴影消除
    ROCKET='ROUND(IF(dy12>=dy35, .70*dy12+.40*dy35, .60*dy35+.50*dy12) -1.1, 2)'        # dy12占更大权重
    pwr_dy5="LEAST(${ROCKET}, (25/t5.tov), t5.tov) * LEAST(t5.tov,20)"                  # ROCKET的范围(25/t5.tov, t5.tov)，最大换手上限为20
    pwr_vax="${_VAX}*5"
            
    pwr_t10="IF(top10<.1, 1, .95/(1-top10))"
    pwr_nmc="IF(${nmc0}/${pwr_t10}-30<100, ${nmc0}/${pwr_t10}-30, 100)/12"

    sql_ma20="ROUND(100*(d.close/ma20-1), 1) as ma20"
    columns="d.code"

    fn_pro_spacer || \
    fn_pro_wolves || \
    sqls="
    SELECT  $columns,
            $HIRI as hiri,
            $OPRI as opri,
            ${sql_avrg}
            top10 as tp10,
            ROUND(${REALIZED2},2) as rliz,
            ${RIFLE} as i_wk,
            ${ROCKET} as i_dy,
            $TURNOV as tov, t5.tov as tov5,
            ROUND(100*d.volume*c.close/c.nmc/t5.tov, 2) as prop5,
            $RISE as rise,
            ROUND( t5.tov*$pwr_t10 +${pwr_dy5} -100*${REALIZED2} 
                   -${pwr_nmc} +${pwr_vax} +${BOOST}, 1) as space,
            ${_VAX} as vax,
            ${sql_ma20},
            round(d.amount/10000, 2) as eYi,
            ${nmcYi}, c.name
            FROM ${TEMPDAY:-day} d, cap c, t_matov5 t5, mat_ma1020 m, top10 p
            ${WHERE} d.code=m.code && m.date='${PREV}' AND
            d.code = c.code AND d.code=t5.code AND d.code=p.code AND
            d.date = '${END}' && ${iCOND:-1} && ${cCOND:-1}
            HAVING ${HAV:-1} && ${kCOND:-1} ${COND} ORDER BY ${FIELD:-rise} ${ASC:-desc} limit ${LIMIT:-36}
    "
    #echo "${sqls}"; exit
}


function fn_pro_wolves()
{
    [ -z "${is_wolves}" ] && return 1

    fn_isdigit ${iDDE:=1} || fn_list_wolf_times

    let iDDE--
    stime=`mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC LIMIT ${iDDE},1"`
    s_old=`mysql -N kts<<< "SELECT DISTINCT time FROM xdde WHERE date='${END}'                       LIMIT ${iDDE},1"`

    if [ "${stime}" != "${s_old}" ]; then
        iCOND="time='${stime}'${eCOND}" xCol=date fn_xCol mat_dde xdde ${END}
        xt_ret $? "" || return $?
    fi

    sql_accelr='t5.tov>1 AND'

    sqls="
    SELECT  $columns,
            ${RIFLE} as i_wk,
            ${ROCKET} as i_dy,
            $TURNOV as tov, t5.tov as tov5,
            ROUND(${pwr_dy5},1) as PWR5,
--          ROUND((${pwr_t10}-1)*t5.tov,1) as TP10,    # _line_for_wolf_
--          ROUND(-${pwr_nmc}, 1) as _NMC,
            concat(ROUND(${nmc0}*(1-top10)/100,2), '_', top10, '_', ROUND(${REALIZED2}, 2)) as nmc_tp10_rliz,
            CONCAT(LEAST(9.99,ROUND(${VBI3},2)), '_',LEAST(9.9,ROUND(${VBI3}*2/(${PROP0}+${PROP5}),1))) as vbi3BOO,
            $RISE as rise,
            ROUND( t5.tov*${pwr_t10} +${pwr_dy5} -100*${REALIZED2} 
                   -${pwr_nmc} +${pwr_vax} +${BOOST}, 1) as space,
            ${_VAX} as vbi3,
--          ${sql_ma20},
--          CONCAT(IF(net>0,'+','-'), round(abs(net)/w.tov, 2),'_',ROUND((pbuy+nbuy)/w.tov, 2)) as wolf,
            ROUND((pbuy+nbuy)/w.tov, 2) as wolf, ROUND(net/w.tov, 2) as pet,
            round(d.amount/10000, 1) as eYi,
            ${nmcYi}, c.name
            FROM ${TEMPDAY:-day} d, cap c, t_matov5 t5, mat_ma1020 m, top10 p, xdde w
            ${WHERE} d.code=m.code && m.date='${PREV}' AND
            d.code = c.code AND d.code=t5.code AND d.code=p.code AND
                                ${sql_accelr} d.code=w.code AND w.date='${END}' AND                         # _line_for_wolf_
            d.date = '${END}' && ${iCOND:-1} && ${cCOND:-1} 
            HAVING ${HAV:-1} && ${kCOND:-1} ${COND} ORDER BY ${FIELD:-rise} ${ASC:-desc} limit ${LIMIT:-36}
    "
    return $?
}

function fn_pro_spacer()
{
    [ -z "${is_spacer}" ] && return 1

    sqls="
    SELECT  $columns,
            ${RIFLE} as i_wk,
            ${ROCKET} as i_dy,
            $TURNOV as tov, t5.tov as tov5,
            ROUND(${pwr_dy5},1) as PWR5,
--          ROUND((${pwr_t10}-1)*t5.tov,1) as TP10,
--          ROUND(-${pwr_nmc}, 1) as _NMC,
            concat(ROUND(${nmc0}*(1-top10)/100,2), '_', top10, '_', ROUND(${REALIZED2}, 2)) as nmc_tp10_rliz,
            CONCAT(LEAST(9.99,ROUND(${VBI3},2)), '_',LEAST(9.9,ROUND(${VBI3}*2/(${PROP0}+${PROP5}),1))) as vbi3BOO,
            $HIRI as hiri,
            $RISE as rise,
            ROUND( t5.tov*${pwr_t10} +${pwr_dy5} -100*${REALIZED2} 
                   -${pwr_nmc} +${pwr_vax} +${BOOST}, 1) as space,
            ${sql_ma20},
         -- d.close,ma60,
         -- ROUND(100*(m.trade/ma5-1), 1) as ma5,
            ${_VAX} as vax,
            round(d.amount/10000, 1) as eYi,
            ROUND(${nmc0}*(1-top10)/100,2) as nmc,
            c.name
            FROM ${TEMPDAY:-day} d, cap c, t_matov5 t5, mat_ma1020 m, top10 p
            ${WHERE} d.code=m.code && m.date='${PREV}' AND
            d.code = c.code AND d.code=t5.code AND d.code=p.code AND
            d.date = '${END}' && ${iCOND:-1} && ${cCOND:-1} 
            HAVING ${HAV:-1} && ${kCOND:-1} ${COND} ORDER BY ${FIELD:-rise} ${ASC:-desc} limit ${LIMIT:-36}
    "
    #echo "${sqls}" >/dev/stderr; exit
}

function fn_lsdh() { is_hammer=1 fn_lsd ${@} ;}
function fn_lsdw() { is_wolves=1 fn_lsd ${@} ;}
function fn_lsds() { is_spacer=1 fn_lsd ${@} ;}
function fn_lsdt()
{
    nmc_tp10="ROUND(${nmc0}*(1-top10)/100,2) as nmc"
    tbl_tp10=', top10 p'
    con_tp10='AND d.code=p.code'
    div_tp10='(1-top10)'
    fn_lsd ${@}
}

function fn_lsd()
{
    # where d.code = c.code 非常重要，不重叠的FIELD不需要加‘tbl_name.’
    local columns="code,yesc,open,close"
          columns=${columns:-'*'}; columns=d.${columns//,/,d.}

    fn_bist
    fn_yist

    case ${1:-1} in
    t|top)  LIMIT=${LIMIT:-200}; HAV="rise>=${rDOOR:-9.93}"; FIELD=${FIELD:-nmc}; chao2=top ;;
    f|flo)  LIMIT=${LIMIT:-200}; HAV="rise<=-9.93"; FIELD=${FIELD:-nmc} ;;
    c|code) cCOND="d.code=${2:-300059}" ;;
    y|dy5)  ROCKET='ROUND(IF(dy12>=dy35, dy12+.38*(dy35-1), dy35+.64*(dy12-1))-1, 2)';
            fn_name $2
            echo "
            SELECT m.*,${ROCKET} as i_dy,ma20,ma60,vax3,vax60 FROM matov5 m, mat_ma1020 v
            WHERE m.code=v.code AND m.date=v.date AND m.code=${2} and m.date<='${END}' ORDER by date DESC LIMIT 8
            " | mysql -t kts; exit ;;
    l|list) fn_list_iF5_times ;;
    [0-9]*)
        iHMS=$1 # 被fn_scale引用
        iTime=`fn_get_time ${1}`
        xt_ret $? "Please check data.dorat@${END}" || return $?

        FIELD=${FIELD:-rise}
        HAV="${HAV:-1}"
        TEMPDAY=xtempday
        FEN=${iTime} DAY=dorat fn_xtempday      # faster than sub-select
        xt_ret $? "" || return $?
        #fn_echo_warn ${iTime}
        ;;
    u|h|usage)
        echo "
    Usage: SELECT lsd <param>
        u|h     show usage
        list    list 5min table
        {0-9}*  index from 5min table
        top|''  10%
        flo     -10%
        c code

    Brother:
        lsdh    space+vax+hiri+opri
        lsdw    space+vax+wolf
        lsds    space=TP10+_NMC+PWR5+BOO

    PPLUS:
        E       一字到底
        G       非一字open
        N       非一字到底
        V       tov5>=${vDOOR:-4}
        K       space+rise>${kDOOR:-5}
        KK      space+rise>${kDOOR:-5} && (i_wk*100+tov5>0 || tov5>=15)
        vax     昨量创新高
        "
        exit
        ;;
    esac

    function fn_sql()
    {
        fn_pro_header_30min
        fn_update_matov5
        xt_ret $? "" || return $?

        c_natural='(d.high!=d.low||d.close/yesc<1.093)'
        c_Volkswagen="AND(t5.tov>2&&(t5.tov/(1-top10)>${vDOOR:-4}))"

        case ${PPLUS} in
        N|n) iCOND="${c_natural}"                                                       ;;  # 可一字open 
        G|g) iCOND="${c_natural} && d.open/yesc<1.093"                                  ;;  # 非一字open
        E|e) iCOND="!${c_natural}"                                                      ;;  # 一字板，全天不开板
        V|v) iCOND="${c_natural} && d.open/yesc<1.093"                                      # exclude<一字开板>
             LIMIT=${LIMIT:-24};HAV="tov5>=${vDOOR:-3.5}&&${HAV:-1}"                    ;;
        vax) iCOND="${c_natural}${c_Volkswagen} &&dy12>1.8&&vax3/vax60>=.88"            ;;  # 昨天量创新高
        K|k) kCOND="${kCOND:-space+rise>${kDOOR:-5}}"                                       # kCOND可以指定
             kCOND="${kCOND}&&tov5>=${vDOOR:-3.5} "
             iCOND="${c_natural}"                                                           # include<一字开板>
             LIMIT=${LIMIT:-24};HAV="${HAV:-1}"                                   ;;
        esac

        fn_pro_hammer || \
        sqls="
        SELECT  $columns,
                $OPRI as opri,
                $HIRI as hiri,
                $LORI as lori,
                ${sql_avrg}
                $RISE as rise,
                ROUND(100*d.volume*c.close/c.nmc/${div_tp10:-1}, 2) as tov, 
         --     ROUND(100*d.volume*c.close/c.nmc/t5.tov, 2) as prop5,
                round(d.amount/10000, 3) as eYi,
                ${nmc_tp10:-${nmcYi}}, c.name
                FROM ${TEMPDAY:-day} d, cap c ${tbl_tp10}
         --     , t_matov5 t5
                ${WHERE} d.code=c.code ${con_tp10}
         --     and d.code=t5.code
                && d.date = '${END}' && ${iCOND:-1} && ${cCOND:-1}
                HAVING ${HAV:-1} ${COND} ORDER BY ${FIELD:-rise} ${ASC:-desc} limit ${LIMIT:-36}
        "
        #echo "${sqls}" > /dev/stderr; exit
    }

    fn_sql $@

    case ${PARTS:-o} in
    s) return                       ;; # 只获取$sqls
    f) CHAO=1                       ;; # 只输出文件chao.chao2
    o) fn_imysql_sqls | fn_hew_tail ;; # 只输出STDOUT
    esac

    fn_chao ${chao}.${chao2:-lsd}
    fn_echo_warn "${END}.${iTime:-latest} LIST:${#LIST[@]} HAV:${HAV//SEL*=/} COND@:$COND + iCOND:${iCOND}"
    fn_echo_succ "PROP:${PROP0}~${PROP5} COND:${kCOND}"
    return 0
}

function fn_ace()
{
    dates=(`fn_get_date ${1:-1} ${2:-10}`)

    function fn_sql()
    {
        sqls="SELECT ${2} FROM day as d,cap as c where d.code=c.code && d.date = '$1' and ${RISE}>=9.93 ${@:3}"
        # echo "${sqls}"; exit 1
        mysql -N kts <<<"${sqls}"
    }

    local i=
    echo "100为基数，第20/80名的情况看出标的的nmc,amount的大小，从而得游资投入资金"
    printf "%-12s%6s\t%6s\t%6s\t%6s\t%6s\n" date rows nmc20 nmc80 amt20 amt80
    for i in ${dates[@]}; do
        rows=`fn_sql $i "count(d.code)"`
        pct20=`bc <<< "${rows}*20/100"`
        pct80=`bc <<< "${rows}*80/100"`
        nmc20=`fn_sql $i nmc ORDER    by nmc    ASC LIMIT ${pct20},1`
        nmc80=`fn_sql $i nmc ORDER    by nmc    ASC LIMIT ${pct80},1`
        amt20=`fn_sql $i amount ORDER by amount ASC LIMIT ${pct20},1`
        amt80=`fn_sql $i amount ORDER by amount ASC LIMIT ${pct80},1`

        echo ${i} ${rows} ${nmc20} ${nmc80} ${amt20} ${amt80} |
        awk '{printf "%s  %6d\t%6.2f\t%6.2f\t%6.2f\t%6.2f\n", $1, $2, $3/10000,$4/10000,$5/10000,$6/10000 }'
    done

    return $?
}

function fn_comma()
{
    # code,date,yesc,open,high,low,close,volume,amount
    # echo "SELECT * FROM ${1:-day} limit 1" | mysql kts  | head -1  | tr '\t' ','
    mysql kts -N<<<"DESCRIBE ${1:-day};" | awk '{printf "%s,", $1} END{printf "\n"}' | sed 's/,$//g'
}


function fn_dt_hyphen_2_normal()
{
    dt0=${1:0:10}
    dt1=${1:11:8}
    echo "${dt0//_/-} ${dt1//_/:}"
    return $?
}

function fn_dt_normal_2_hyphen()
{
    echo "${1//-/_}_${2//:/_}"
    return $?
}

# fn_dt_hyphen_2_normal 2015_08_11_11_02_21
# fn_dt_normal_2_hyphen 2015-08-11 11:02:21

function fn_rat()
{
    # 0. Make sure U've done [up 4]?
    # 1. 以PREV为标，自动处理生成 tbl_mavol520s，只需上午更新一次 tbl_mavol520s
    # 2. 使用多表tbl_mavol520s tbl_day`联合查询`得到数据
    HMS=${HMS:-`fn_get_time 1`}
    FIELD=${1:-v1v5}
    SCALE=`fn_get_ratio_close2open`
    # echo ${SCALE}; exit
    tov="round(100*(d.volume)/(c.nmc/c.close),2)"
    tovf="round(100*(ma.vol5)/(c.nmc/c.close),2)"
    tov20="round(100*(ma.vol20)/(c.nmc/c.close),2)"
    v1v5="round(5*d.volume*${SCALE}/(ma.vol5),2)"
    # v5vT="round(4*ma.vol5/(ma.vol20),2)"
    # ${v5vT} as v5vT,

    TBL=${TBL:-cap} END=${PREV} ./SCREENER wma

    fn_yist
    tbl_day="(SELECT * FROM dorat WHERE date='${END}' && time='${HMS}' ${inLIST})"

    function fn_build_sqls() {
    sqls="
    SELECT d.code,DATE_FORMAT(d.date,'%m-%d')as date,d.yesc,d.open,d.low,d.close,
        round(100*((d.open+low)/2-d.yesc)/d.yesc,2) as av_open,
        round(100*(d.close-(d.open+low)/2)/((d.open+low)/2),2) as av_rise,
        round(100*(d.close-d.yesc)/d.yesc,2) as rise,
        ${tov} as tov,
        ${tov20}as tov20,
        ${v1v5} as v1v5,
        d.amount,c.nmc,c.name FROM tbl_mavol520s as ma,
        ${tbl_day} as d, cap as c
        WHERE ma.code=d.code and ma.code=c.code
        HAVING 1 ${COND} ORDER by ${FIELD} ${ASC:-DESC} limit ${LIMIT:-36}"
    }
    fn_build_sqls

    echo "$sqls">/dev/stderr
    mysql -t kts<<<"$sqls"

    fn_chao $chao.rat
}

function fn_tri()
{
    FIELD=${1:-rising}
    STEP=${STEP:-7}

    D2=${END}
    D1=`fn_get_date 1`
    D0=`fn_get_date ${STEP}`
    t2="(SELECT * FROM day WHERE date='${D2}')"
    t1="(SELECT * FROM day WHERE date='${D1}')"
    t0="(SELECT * FROM day WHERE date='${D0}')"

    function fn_build_sqls() {
    product="TRUNCATE(100*(tbl.close-(tbl.amount/tbl.volume))/tbl.close,2)"
    sqls="
    SELECT * FROM (SELECT '${END}' as date, d.code, d.close,
        $RISE as rise,
        round(100*(t1.close-t0.yesc)/t0.yesc, 2) as rising, ${STEP}+1 as D,
        c.nmc, c.name FROM
        ${t2} as d,
        ${t1} as t1,
        ${t0} as t0, cap as c
        WHERE d.code=t1.code && d.code=t0.code and d.code=c.code   -- 取样本数40 = 2000*20%，7天可翻倍
              ORDER by rising DESC limit 40 ) as t
        ${COND} ORDER by ${FIELD:-rising} ${ASC:-DESC} limit ${LIMIT:-40}
    "
    }
    fn_build_sqls
    echo "$sqls">/dev/stderr
    mysql -t kts<<<"$sqls"

    fn_chao
}

function fn_dif3()
{
    [ -n "${iHMS}" ] && \
     HMS=`fn_get_time ${iHMS}`                  # 第3张可由iHMS指定
    HMS1=`fn_get_time $1`                       # 第1张
    HMS2=`fn_get_time $2`                       # 第2张
    HMS3=`HMS=${HMS} iASC=DESC fn_get_time 1`   # 最新，亦可由HMS指定

    TEMPORARY=TEMPORARY
    iCOND="num=${NUM:-8}" xCol=end fn_xCol mat_lohi curr_lohi ${PREV}
    xt_ret $? "To avoid this WARNING: END=${PREV} SCREENER lohi 1" || exit $?

    echo "
    DROP   TABLE IF EXISTS dif3;
    CREATE TABLE IF NOT EXISTS dif3 (
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        yesc        DECIMAL(6,2) NOT NULL DEFAULT 0,
        open        DECIMAL(6,2) NOT NULL DEFAULT 0,
        high        DECIMAL(6,2) NOT NULL DEFAULT 0,
        low         DECIMAL(6,2) NOT NULL DEFAULT 0,

        close       DECIMAL(6,2) NOT NULL DEFAULT 0,
        av1         DECIMAL(6,2) NOT NULL DEFAULT 0,
        av2         DECIMAL(6,2) NOT NULL DEFAULT 0,
        av3         DECIMAL(6,2) NOT NULL DEFAULT 0,
        ri1         DECIMAL(6,2) NOT NULL DEFAULT 0,
        ri2         DECIMAL(6,2) NOT NULL DEFAULT 0,
        ri3         DECIMAL(6,2) NOT NULL DEFAULT 0,
        shou        DECIMAL(12,2) NOT NULL DEFAULT 0,
        volume      DECIMAL(12,2) NOT NULL DEFAULT 0,
        amount      DECIMAL(12,2) NOT NULL DEFAULT 0,

        opri        DECIMAL(6,2) NOT NULL DEFAULT 0,
        hiri        DECIMAL(6,2) NOT NULL DEFAULT 0,
        lori        DECIMAL(6,2) NOT NULL DEFAULT 0,

        dirt        DECIMAL(6,2) NOT NULL DEFAULT 0,            -- 增量量比 dif-vol-ratio
        INDEX(code)
    );
    DROP   $TEMPORARY TABLE IF EXISTS t2,t1;
    CREATE $TEMPORARY TABLE IF NOT EXISTS t2 (
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        close       DECIMAL(6,2) NOT NULL,
        volume      DECIMAL(12,2) NOT NULL,
        amount      DECIMAL(12,2) NOT NULL,
        INDEX(code)
    );
    CREATE $TEMPORARY TABLE t1 LIKE t2;
    INSERT INTO dif3(code,yesc,open,high,low,close,volume,amount) SELECT code,yesc,open,high,low,
                               close,volume,amount FROM dorat WHERE date='${END}' and time='${HMS3}';
    INSERT INTO t2 SELECT code,close,volume,amount FROM dorat WHERE date='${END}' and time='${HMS2}';
    INSERT INTO t1 SELECT code,close,volume,amount FROM dorat WHERE date='${END}' and time='${HMS1}';

    UPDATE dif3 t3 INNER JOIN curr_lohi on t3.code=curr_lohi.code
                SET opri=100*(t3.open-yesc)/yesc,
                    hiri=100*(t3.high-yesc)/yesc,
                    lori=100*(t3.low- yesc)/yesc,
                    shou=curr_lohi.volume;
    UPDATE dif3 t3 INNER JOIN t2 on t3.code=t2.code
                   INNER JOIN t1 on t2.code=t1.code
                      SET av3=100*((t3.amount/t3.volume)-yesc)/yesc,
                          av2=100*((t2.amount/t2.volume)-yesc)/yesc,
                          av1=100*((t1.amount/t1.volume)-yesc)/yesc,
                          ri3=100*(t3.close-yesc)/yesc,
                          ri2=100*(t2.close-yesc)/yesc,
                          ri1=100*(t1.close-yesc)/yesc,
                          dirt=100*(high-low)/yesc
    " | mysql kts
    xt_ret $? "fail: mysql" || return $?
}

function fn_dirt_interval()
{
    step=${1:-10}
    [ -z "${iHMS}" ] && \
    iHMS=`fn_get_nr_time`
    let it2=iHMS-step
    let it1=it2-step

    [ "${it1}" -gt 0 ]
    xt_ret $? "[iHMS:${iHMS}] must_gt 2*[step:${step}]" || return $?

    fn_dirtio ${it1} ${it2} $2
}


function fn_dirtio()
{
    usage="
    SELECT dirtio           TT=t1 avri默认属表
    u                       print usage
    l                       print iF5-list
    st                      print wolf-time-list
    i step                  start-offset mode
    HMS1 HMS2 [wolf]        HMS3由{iHMS|HMS}指定
    COND='ri2>ri1 && hiri<9.93&&dirt<10'
    "
    case $1 in
    l) fn_list_iF5_times        ;;
    w) fn_list_wolf_times       ;;
    i) fn_dirt_interval ${@:2}  ;;
    #  bash -n 检查下行时会报错，因shopt.-s.extglob
    +([0-9]))
        fn_isdigit $1
        xt_ret $? "argv.1[$1] must be a iF5 num" || return $?
        fn_isdigit $2
        xt_ret $? "argv.2[$2] must be a iF5 num" || return $?

        # 方便双查询
        [ "${3}" = 'w' ] && fn_list_wolf_times
        fn_isdigit ${sta:=${3:-1}} || fn_list_iF5_times
        let sta--
        stime=`mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC LIMIT ${sta},1"`
        iCOND="time='${stime}'${eCOND}" xCol=date fn_xCol mat_dde xdde ${END}
        xt_ret $? "" || return $?

        # dif
        fn_dif3 ${@}
        fn_yist
        columns="close,av1,av2,av3,ri1,ri2,ri3,${opri:=opri},${hiri:=hiri},dirt"
        columns=d.${columns//,/,d.}

        function fn_build_sqls() {
        sqls="
          SELECT d.code, ${columns},
            ROUND((pbuy+nbuy)/w.tov, 2) as wolf,
            round(net/tov, 2) as pet,
            round((volume/d.shou), 2) as prop,
            ROUND(tov, 1) as tov,
            round(w.amount/10000, 1) as eYi,
            ROUND(nmc, 1) as nmc,
            w.name
            FROM dif3 as d, xdde as w
            $WHERE d.code=w.code && nmc<${nmc:=${nmc_wolf}}
            HAVING 1 ${COND}
            ORDER by ${FIELD:=wolf} ${ASC:-DESC} limit ${LIMIT:-40}"
        # echo "$sqls">/dev/stderr; exit
        }
        fn_build_sqls
        fn_imysql_sqls | fn_hew_tail
        xt_ret $? "" || return $?
        fn_echo_succ "nmc.[${nmc}] ${END}.[$HMS1 $HMS2 $HMS3] wolf.[${stime}] [opri.$opri hiri.$hiri] by [${FIELD}]"

        fn_chao ${chao}.dir
        ;;
    *|u|usage)
        echo "${usage}"
        ;;
    esac
}

function fn_wma()
{
    # 1. Make sure U've done [SCREENER 2]?
    # 2. 使用单表tbl_mavol520s作差得到数据
    SCALE=`fn_get_ratio_close2open`
    columns=code,close,ma5,ma10,ma20
    columns=t.${columns//,/,t.}

    fn_yist
    fn_echo_warn "----- LIST:${#LIST[@]} COND@${END}: $COND -----"

    sqls="
    SELECT ${columns},
    ${SCALE}*vol       as mavol,
    round(vol5 / 5,2)  as mavol5,
    round(vol20/ 20,2) as mavol20,
    round(vol60/ 60,2) as mavol60,
    round(4*${SCALE}*vol/(vol5-vol),2)  as v1v4,
    c.nmc, c.name
    FROM tbl_mavol520s as t, cap as c WHERE t.code=c.code
    HAVING 1 ${COND} ${inLIST}
    ORDER by ${1:-v1v4} ${ASC:-DESC} LIMIT ${LIMIT:-24}
    "
    echo "${sqls}" | tee /dev/stderr | mysql $OPT -t kts

    fn_chao
}

function fn_updown()
{
    case $1 in
    +([0-9])) 
        HMS=`iASC=${iASC:-DESC} fn_get_time ${1}` || exit; NUM=1        ;;
    l)  iASC=DESC fn_list_iF5_times                                     ;;
    h)  echo "Usage: iASC=ASC NUM=5 SELECT updown # ASC 09:25:00"; exit ;;
    yiz)
        fn_echo_succ "PARTS=f@非一字板连板"
        PARTS=f CHAO=1 END=$PREV COND="rise>=9.93" PPLUS=N FIELD=rise LIMIT=400 SELECT lsd
        YIST=${chao}.lsd   COND="rise>=9.93" SELECT lsd
        exit
        ;;
    esac

    START=`fn_get_date ${NUM:-5}`

    fn_echo_succ "[NUM:${NUM:-5}] records from ${START} to ${END}.${HMS}..."

    cd $cdpath
    > $mps_god
    head -n -5 $mps_org >> $mps_god

    cols1=date,cnt,yiz10,inc10,hit10,
    cols2=inc,dec0,eq0,inc7p,inc5p,inc2p,inc0p,dec0d,dec2d,dec5d,dec7d,hit00,dec10


    echo "
    SET @NUM=${NUM:-5};
    SET @END='${END}';
    SET @START='$START';
    SET @HMS='${HMS:-00:00:00}';
    call sp_stat_change();
    SELECT ${cols1} ROUND(100*inc10/hit10,2) as succ, ${cols2}
    FROM tbl_stat_change WHERE 1 ${COND}
    ORDER by ${FIELD:-date} ${ASC:-ASC};
    " >> $mps_god
    # | tee /dev/stderr >> $mps_god

    mysql $OPT -t kts <<< "source $mps_god"

    return
}

function fn_6maishenjian()
{   # date1,date2,amount,
    columns="off,open,close,turnov"
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    DATE2=${DATE2:-${END}}

    echo ----- COND: $COND -----
    function fn_get_tbl_6jian_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${DATE2}';
        "
        tbl_super_dive="
        SELECT t.code, DATE_FORMAT(date1,'%m-%d') as start,
                       DATE_FORMAT(date2,'%m-%d') as end, ${columns}, chng,
                       round(100*(t.low  - avrg)/avrg,2) as lchng,
                       round(100*(t.close- avrg)/avrg,2) as wchng,
                       round(100*(d.close- avrg)/avrg,2) as avrg_up,
                       round(100*(d.close-(t.close+t.low)/2)/avrg,2) as trough_up,
                       round((avrg-d.close)/(d.close-(t.close+t.low)/2),2) as odds,
                       ${nmcYi}, c.name
            FROM ${tablex:-tbl_6mai} as t, cap as c, tempday as d
            WHERE t.code = c.code and t.code = d.code HAVING 1 ${COND}
            ORDER by ${1:-wchng} ${ASC:-asc} limit ${LIMIT:-36}     # COND='nmc<250000 and lchng<-9.7 and off<21'
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_6jian_dive $1
    mysql $OPT -t kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao
}

function fn_dugu9jian()
{   # date1,date2,amount,open
    columns="off,turnov,avrg,close"
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    DATE2=`mysql -N kts <<< "SELECT date2 from ${tablex:-tbl_9jian} LIMIT 1"`

    echo ----- COND: $COND -----
    function fn_get_tbl_9jian_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${DATE2}';
        "
        tbl_super_dive="
        SELECT t.code,  DATE_FORMAT(date1,'%m-%d') as start,
                        DATE_FORMAT(date2,'%m-%d') as end, ${columns},
                        round(avrg*(1-${ORACLE:-10}/100),2) as oracle,
                        chng,
                        $RISE as rise,
                        $PEAK as peak,
                        $TROUGH as trough,
                        round(100*(t.low-avrg)/avrg,2) as lchng,
                        round(100*(t.close-avrg)/avrg,2) as wchng,
                       ${nmcYi}, c.name
           FROM ${tablex:-tbl_9jian} as t, cap as c, tempday as d
           WHERE t.code = c.code and t.code = d.code HAVING 1 ${COND}
           ORDER by ${1:-lchng} ${ASC:-asc} limit ${LIMIT:-36}      # COND='nmc<250000 and lchng<-9.7 and off<21'
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_9jian_dive $1
    mysql ${OPT:-'-t'} kts <<< "${tempday}${tbl_super_dive}"
    xt_ret ${PIPESTATUS[0]} "${FUNCNAME}" || return $?

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao
}

function fn_tao5()
{
   #columns=date_p,date_c,off_p,off_c,tnov_p,tnov_c,avrg_p,avrg_c,ratio
    columns=date_p,off_p,date_c,off_c,tnov_c,avrg_p,avrg_c,ratio,wchng
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    echo ----- COND: $COND -----
    function fn_get_tbl_tao5_dive()
    {
        tbl_super_dive="
        SELECT t.code, ${columns}, c.nmc,c.name
           FROM ${tablex:-tbl_tao5} as t, cap as c
           WHERE t.code = c.code HAVING 1 ${COND} limit ${LIMIT:-144}
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_tao5_dive $1
    mysql $OPT -t kts <<< "${tbl_super_dive}" |\
        sed -e '1,3s/----+$/\+/g' -e '$s/----+$/\+/g' -e '2s/    |$/|/g'
    xt_ret ${PIPESTATUS[0]} "${FUNCNAME}" || return $?
}

function fn_rdiff()
{
   #columns=date_p,date_c,off_p,off_c,tnov_p,tnov_c,avrg_p,avrg_c,ratio,dbrat
    columns=date_p,date_c,off_p,off_c,tnov_c,close,avrg_p,avrg_c,ratio,cdiff,rdiff,wchng
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    echo ----- COND: $COND -----
    function fn_get_tbl_rdiff_dive()
    {
        tbl_super_dive="
        SELECT t.id,t.code,
        ${columns}, (wchng+2*rdiff+3*cdiff) as fire
           -- , c.nmc, c.name
           FROM ${tablex:-tbl_rdiff} as t, cap as c
           WHERE t.code = c.code HAVING 1 ${COND} limit ${LIMIT:-144}
        "
        # echo "${tbl_super_dive}"
        fn_name `mysql -N kts <<<"SELECT code FROM ${tablex:-tbl_rdiff} LIMIT 1"`
    }

    fn_get_tbl_rdiff_dive $1
    mysql $OPT -t kts <<< "${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_accdiff() { tablex=tbl_adiff fn_rdiff; }

function fn_pma()
{
    fn_iscode $1
    xt_ret $? "" || return $?

    END=${END:-`fn_maxdate`}
    NUM=${NUM:=5}

    # enable d2，则tov扩大10倍
    echo "
    SELECT close FROM day WHERE code=$1 and date='$END' INTO @iclose;
    SELECT d.code, '${END}' as date, sum(d.amount)/sum(d.volume) as ma${NUM}, @iclose,
        round(100 * (@iclose-sum(d.amount)/sum(d.volume))/@iclose, 2) as pcnt,
        round(100*sum(d.volume)/cap.shares, 2) as tov${NUM}
        FROM
        (SELECT * FROM day WHERE code=$1 and date<='$END' ORDER by date DESC LIMIT ${NUM}) as d,
        cap WHERE d.code = cap.code ;
    " | mysql -t kts
    # SELECT sum((high-yesc)/yesc) FROM day WHERE code = 2 and date > '2014-11-03';
    return $?
}

function fn_fbi()
{
    # code,datetime_p,datetime_c,dbrat
    columns='off_p,off_c,tnov_c,close,avrg_p,avrg_c,ratio,cdiff,rdiff,wchng'

    fn_name `mysql -N kts <<<"SELECT code FROM ${tablex:-tbl_fdiff} LIMIT 1"`
    echo "
        SELECT id,
        -- datetime_p,
        TRUNCATE(datetime_p%(1000000000000)/1000000,4) as dt_p,
        -- datetime_c,
        TRUNCATE(datetime_c%(1000000000000)/1000000,4) as dt_c, ${columns},
        round(close+(avrg_c-close)*.618 - close*ratio*.00236, 2) *              -- close as SPACE
           IF((avrg_c-close)*.618 - close*ratio*.00236<0, -1, 1) as oracle,     -- ratio as TIME
        (wchng+2*rdiff+3*cdiff) as fire
        FROM ${tablex:-tbl_fdiff} LIMIT ${LIMIT:-200}
    " | mysql -t kts
}


function fn_acf() { tablex=tbl_acfdiff fn_fbi; }

function fn_dorat()
{
    case $1 in
    h|u|usage)
        echo "
        SELECT dorat <param>
        u   usage
        ld  date
        *   date time
        "
        ;;
    ld)
        odr="ORDER by date ASC"
        mysql -N kts<<< "SELECT DISTINCT date FROM dorat"
        ;;
    *)
        # 只提供当天的times
        if [ -n "${DT}" ]; then
            DT=(${DT})
            END=${DT[0]}
            HMS=${DT[1]}
        fi
        odrLimit="ORDER by time ${iASC:-DESC} LIMIT ${LIMIT:-82}"
        mysql -N kts<<< "SELECT DISTINCT date,time FROM dorat WHERE date='${END}' && time<='${HMS:-15:05:00}' ${odrLimit}"
        ;;
    esac

    return $?
}


function fn_td_layout()
{
    fn_iscode ${code:=${1}}
    xt_ret $? "" || return $?
    dates=`mysql -N kts <<< "SELECT DISTINCT round(datetime/1000000,0) from fenbi WHERE code=${code}"`

    mysql kts <<< "TRUNCATE tmpfb";

    local i=
    for i in ${dates}; do
        # SELECT date FROM day WHERE code=${code} and date=
        echo "
        INSERT INTO tmpfb(code,datetime,trade,volume,amount)
        SELECT code,datetime%1000000,trade,volume,amount FROM fenbi
            WHERE code=${code} and round(datetime/1000000, 0)=${i}
            ORDER by trade ${ASC:-DESC} LIMIT 1;
        " | mysql kts -t
        xt_ret $? "" || return $?
    done

    mysql -t kts <<< "SELECT * FROM tmpfb ORDER by datetime DESC";

    return $?
}

function fn_ma240_usage()
{
    echo "
    1 x_mid x_one 双线出击
    2 牛市step2 ma240收敛 & cross & 放量上行
    3 联合查询1 x_sho && NUM_RATIO=2 SCREENER 0
    4 联合查询2 强者恒强 平台突破 开山股份
    "
}

function fn_ma240()
{
    # 0. Make sure U've done [SCREENER ma240]?
    columns=code,date,close,ma5                     # ,ma5,ma10,ma20,ma60 # ,ma120,ma240
    columns=ma.${columns//,/,ma.}


    function fn_build_sqls()
    {
    sqls="SELECT date FROM day WHERE code=900001 and date<='${END}' ORDER by date DESC LIMIT 4,1"
    ago5=`mysql -N kts<<<"${sqls}" 2>/dev/null`
    FIELD=${1:-x_sho}
    sqls="
    SELECT ${columns},
        round(100*(ma.close-ma5  )/ma5  ,1)as pma5,
        round(100*(ma.close-ma20 )/ma20 ,1)as pma20,
        round(100*(ma.close-ma40 )/ma40 ,1)as pma40,
        round(100*(ma.close-ma60 )/ma60 ,1)as pma60,
        round(100*(ma.close-ma120)/ma120,1)as pma120,
        ${x_sho} as x_sho,          -- 5 10 20
        ${x_mid} as x_mid,          -- 20 60 120
        ${x_long} as x_long,        -- 60 120 240
        ${x_sho}+
        ${x_mid}+
        ${x_long} as x_6line,       -- 一阳穿3线
        c.nmc,c.name FROM tbl_ma240 as ma, cap as c
        ${WHERE} ma.code=c.code and ma5!=0 and ma.date>'${ago5}'
        HAVING 1 and code<600000 && nmc<1500000 && pma5>-2 ${COND}
        ORDER by ${FIELD} ${ASC:-ASC} limit ${LIMIT:-24}"
    }

    # .0001 使得新股 x_sho x_long 都为 2.000
    # mid 5day 5week 5month
    x_sho="round(100*(abs((ma5-ma10)/(ma10))+abs((ma20-ma10)/(ma10))  ), 1)"
    x_mid="round(100*(abs((ma10-ma20)/(ma20))+abs((ma40-ma20)/(ma20)) ), 1)"
    x_long="round(100*(abs((ma40-ma60)/(ma60))+abs((ma120-ma60)/(ma60))), 1)"

    ABBR=ma fn_yist
    fn_build_sqls $1
    fn_echo_warn "----- LIST:${#LIST[@]} COND@${END}: $COND -----"
    echo "$sqls">/dev/stderr
    mysql -t kts<<<"$sqls"

    fn_echo_warn "Suggest: COND=''"

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return
    fn_chao ${chao}.240
}

function fn_hilo()
{
    columns='code,date1,date2,off,high,low,close'
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    function fn_yi_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${CURR}';
        "
        # delete停牌个股
        tbl_super_dive="
        SELECT ${columns},
        round(100*(t.high -LEAST(t.low,d.low))/t.high,1) as jump,
        round(100*(d.close-LEAST(t.low,d.low))/t.high,1) as rebound,
        ${nmcYi0}, c.name
        FROM tbl_hilo as t, tempday as d, cap as c
        WHERE t.code = d.code and t.code=c.code
        HAVING 1 ${COND}
        ORDER by ${FIELD:-jump} ${ASC:-DESC} LIMIT ${LIMIT:-36}
        "
        echo "${tbl_super_dive}"
    }

    fn_yi_dive $1
    mysql $OPT -t kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao
}

function fn_lohi_wind()
{
    echo "
    SELECT * FROM (
    SELECT A.date, A.incr, A.rise, A.hico, A.red, (A.incr-B.incr)as dif
               FROM wind A INNER JOIN
                    wind B on(A.id=B.id-1) GROUP BY A.id
    ) as t ORDER by ${FIELD:-date} DESC
    " | mysql -t kts
}

function fn_lohi_wolf()
{
    LIMIT=${LIMIT:-60}

    echo "
    $DROP wind;
    $CREATE wind (
        id          INT PRIMARY key AUTO_INCREMENT NOT NULL,
        date        date NOT NULL,
        incr        DECIMAL(6,2) NOT NULL DEFAULT 0,
        rise        DECIMAL(6,2) NOT NULL DEFAULT 0,
        hico        DECIMAL(6,2) NOT NULL DEFAULT 0,
        red         INT
    ) " | mysql kts
    xt_ret $? "" || return $?

    dates=(`fn_get_date 1 ${BLK:-20}`)
    local i
    for (( i=0,j=2; i<${#dates[@]}; i++,j++ )); do
        let imod=i%5
        [ "${imod}" = 0 ] && echo ${dates[$i]} ${i}...
        export END=${dates[$i]}

        # uncomment below 2 lines to 统计最高高度
        CHAO=1 chao2=mi5 PARTS=f END= iEND=$j SELECT lohi i
        export YIST=${chao}.mi5

        LIMIT=${LIMIT} FIELD=incr PARTS=s fn_lohi i
        echo "
        ${tempday}
        INSERT INTO wind(date,incr,rise,hico,red)
        SELECT '${END}', sum(incr)/${LIMIT}, sum(rise)/${LIMIT}, sum(rise-hiri)/${LIMIT} as hico, sum(rise>${rDOOR:-0})
        FROM ( ${tbl_super_dive} ) as iwolf
        " | mysql -N  kts
        # echo "${tbl_super_dive}"; exit
        xt_ret $? "" || return $?
    done

    return $?
}

function fn_lohi_mi5()
{
    LIMIT=${LIMIT:-60}
    let jEND=${iEND:-1}+1
    CHAO=1 chao2=mi5 PARTS=f iEND=$jEND SELECT lohi i
    export YIST=${chao}.mi5

    echo "
    $DROP f5rise;
    $CREATE f5rise (
        id          INT PRIMARY key AUTO_INCREMENT NOT NULL,
        time        time NOT NULL,
        f5rise      DECIMAL(6,2) NOT NULL DEFAULT 0,
        hico        DECIMAL(6,2) NOT NULL DEFAULT 0,
        red         INT
    ) " | mysql kts
    xt_ret $? "" || return $?

    HMSs=(`fn_get_time 1 ${BLK:-120}`)
    nr=${#HMSs[@]}

    if [ "${nr}" -gt 90 ]; then
        iSTEP=${iSTEP:-3}
    elif [ "${nr}" -gt 60 ]; then
        iSTEP=${iSTEP:-2}
    elif [ "${nr}" -gt 30 ]; then
        iSTEP=${iSTEP:-1}
    fi
    local i
    for (( i=0; i<${nr}; i+=${iSTEP:-2} )); do
        let imod=i%5
        [ "${imod}" = 0 ] && echo ${HMSs[$i]} ${i}...
        export HMS=${HMSs[$i]}
        LIMIT=${LIMIT} FIELD=incr PARTS=s fn_lohi i 0
        echo "
        ${tempday}
        INSERT INTO f5rise(time,f5rise,hico,red)
        SELECT '${HMS}', sum(rise)/${LIMIT} as wolf, sum(rise-hiri)/${LIMIT} as hico, sum(rise>${rDOOR:-0}) FROM (
        ${tbl_super_dive}
        ) as iwolf
        " | mysql -N  kts
        #echo "${tbl_super_dive}"; break;
        xt_ret $? "" || return $?
    done
    fn_echo_succ "${END}"
    echo "
    SELECT * FROM f5rise
    " | mysql -t kts

    return $?
}

function fn_lohi()
{
    iNUM=${NUM:-8}                          # PREV=`mysql -N kts <<< "SELECT max(end) from mat_lohi"`
    iCURR=`fn_get_prev`
    iPREV=`END=${iCURR} fn_get_prev`        # prev+temp = 灵活推演

    # echo END: ${END} curr: ${iCURR} prev:${iPREV}; exit

    hilo_temp="( SELECT * FROM mat_lohi WHERE end='${END}' and num=${iNUM} )"
    hilo_curr="( SELECT * FROM mat_lohi WHERE end='${iCURR}' and num=${iNUM} )"
    hilo_prev="( SELECT * FROM mat_lohi WHERE end='${iPREV}' and num=${iNUM} )"
       d_temp="SELECT * from day where date='${END}'"       # 最新day数据，可以是开市数据
       d_curr="SELECT * from day where date='${iCURR}'"     # 次新day数据，必是必市后数据

    case $1 in
    l|list)
        iASC=DESC fn_list_iF5_times
        ;;
    d|date)
        SCREENER lohi l; exit 0
        ;;
    i|bvri)
        iF5=$2
        if [ "${1}" = bvri ]; then
            # 大放量.抄底反包股如<天银机电2015-12-29>
              CONDb="((avri-bvri>${DOORb:-1.1})||(prop>.938&&rise>${YRISE:-1.23}))"
            # 熔断缩量版本
            # CONDb="((avri-bvri>${DOORb:-2.0})||(prop>0.8&&rise>0))"
            END=${PREV} COND="${CONDb}" LIMIT=2000 PARTS=f chao2=bvri SCALE= SELECT lohi i
            YIST=${chao}.bvri
        fi

        if [ -z "${iF5}" ]; then
            TEMPDAY="tempday"
            tempday="
            $DROP tempday; CREATE TABLE tempday LIKE day;
            INSERT INTO tempday SELECT * from day where date='${END}';"
        else
            # TEMPDAY="(SELECT * FROM dorat WHERE date='${END}' && time='${HMS}')"
            # tempday=
            # 使用 tempday比SELECT子语句快10倍
            HMS=${HMS:-`fn_get_time ${iF5}`}
            TEMPDAY="tempday"
            tempday="
            $DROP tempday; CREATE TABLE tempday LIKE day;
            INSERT INTO tempday SELECT code,date,yesc,open,high,low,close,volume,amount
            FROM dorat WHERE date='${END}' && time='${HMS}';
            "
        fi

        # echo HMS ${HMS}; exit

        if [ "${SCALE:-0}" = 'A' ]; then
            HMS=${HMS:-`fn_get_time 1`}
            SCALE=`HMS=${HMS} fn_scale SCALE`
            fn_echo_succ SCALE ${SCALE}
        fi

        #  默认不使用vtov
        if [ "${CIXIN:=0}" = 0 ]; then
            sql_tov="${TURNOV} as tov"
            tbl_condi=
            sql_eqcode='&& d.high != d.low'
        elif [ "${CIXIN}" = 1 ]; then
            sql_tov="${TURNOV} as tov"
            tbl_condi=
            sql_eqcode=
            fn_notin_blk 40
        elif [ "${CIXIN}" = 2 ]; then
            sql_tov="${TURNOV} as tov"
            tbl_condi=
            sql_eqcode=
            YIST='.blk.cixin'
        else
            sql_tov="ROUND((100*d.volume*c.close/c.nmc)/(1-top10_ajst_aR), 2) as vtov"
            tbl_condi='top10,'
            sql_eqcode="&& t.code=${tbl_condi//,/}.code"
            fn_notin_blk 40
        fi

        ABBR=t fn_yist

        function fn_yi_descend()
        {
          columns="d.code,DATE_FORMAT(t.date1,'%m-%d')as date1,t.off" #,t.lohi,t.low,

          tbl_super_dive="
          SELECT * FROM (
            SELECT ${columns},
            round(100*(d.close-t.low)/t.low, 2) as incr,
         -- round(100*(GREATEST(t.high,d.close)-d.close)/GREATEST(t.high,d.close), 2) as decn,
            round(100*(t.amount/t.volume-d.yesc)/d.yesc, 1) as bvri,
            d.close,
            $OPRI as opri,
            round(100*(d.high-d.yesc)/d.yesc, 2) as hiri,
            round(100*(d.amount/d.volume-d.yesc)/d.yesc, 1) as avri,
            ${RISE} as rise,
            ${sql_tov},
            round((${SCALE:-1}*d.volume/t.mavol5), 2) as prop5,
            round((${SCALE:-1}*d.volume/t.volume), 2) as prop, t.scale,
            round((d.amount/10000), 1) as eYi,
         -- round((t.amount/10000), 1) as zYi,
            ${nmcYi0}, c.name
            FROM ${hilo_curr} as t, ${tbl_condi}
            ${TEMPDAY} as d, cap as c
            ${WHERE} t.code = d.code and t.code=c.code ${sql_eqcode}
            HAVING 1 ${COND}
            ${notinBLK}
            ORDER by incr ${ASC:-DESC} ) as t
          HAVING ${HAV:-1} ORDER by ${FIELD:=incr} ${ASC:-DESC} LIMIT ${LIMIT:-36}
          "
          [ ${DEBUG:-0} -eq 1 ] && echo "${tempday}${tbl_super_dive}" && exit
        }
        ;;
    wolf)
        fn_lohi_wolf;
        fn_lohi_wind; exit ;;
    wind)
        fn_lohi_wind; exit ;;
    mi5)
        fn_lohi_mi5; exit ;;
    u|*)
        nouse="
            in        : exist dates
            out       : dates list with num"
        echo "
        SELECT lohi <param>
            l|list    : list of iF5
            d|date    : list of date
            bvri  iF5 : bvri 增长
            i     iF5 : from dorat，iF5为空时取最新
            wolf      : 统计#{BLK:-8}日内#{LIMIT:-60}支最活跃股的最高涨幅wind
            wind      : show.wind
            mi5       : 统计#{BLK:-8}个5分钟走势
            *         : usage
        指标说明：
            --------------------------大盘不稳皆是浮动-------------------------
            incr: 总涨幅，大于22%抛压增大
            hiri: high出现与大盘最高点应该同步，dif(avrg)不应该把量能掏空了
       avri/bvri: 今日/昨日 均价    均衡股<天喻信息>，十字星，尾部发力与黄线重合最佳(有主力护航)
           YRISE: 昨日的涨幅门限<1.23>，大跌时降低，大涨时调高
      prop/scale: 今日/昨天 量比    强势股的概念及板块很重要，scale<2可以确保资金安全.
        "
    fn_echo_succ "
    0. 恒量
    abs(prop-1)<.2 && abs(scale-1)<.2
    1. 逐级放量，avri逐步抬高
    COND='vtov>.5 && (avri>bvri||(rise>3&&avri+1>bvri)) && scale>1.23&&prop>1.23 && scale<4&&prop<3' SELECT lohi bvri
    2. 1级放量小，avri逐步抬高
    COND='vtov>.5 && (avri>bvri||(rise>3&&avri+1>bvri)) && scale>1.06&&prop>1.00 && scale<4&&prop<3' SELECT lohi bvri
    3. 大放量后微缩量
    COND='vtov>.5 && (avri>bvri&&prop<=1.1)             && scale>2.00&&prop5>1.3 && scale<5&&prop<4' SELECT lohi bvri
    4. 底分型(最低日:缩量微涨)
    iEND=2 CHAO=1 LIMIT=2000 chao2=prev  COND='vtov>.5  && avri<bvri && rise>-1 && prop>.8&&prop<1.1' SELECT lohi i
    YIST=${chao}.prev COND='prop>1.4 && rise>0' SELECT lohi i       # 超跌至前低+连续两日DDE为正(中毅达.飞乐音响.当日冲涨停板)
    5. WEEK级别
    COND='w1>1.1&&w2>1' NUM=3 SELECT wee; COND='w1>1.1&&w2>1' NUM=4 SELECT wee
    " 2>&1 # | sed 's/^  *//g'
        exit
        ;;
    esac

    fn_yi_descend

    case ${PARTS:-o} in
    s) return                                                   ;; # 不输出chao，不输出mysql结果
    f) CHAO=1                                                   ;; # 只输出chao
    o) mysql ${OPT:--t} kts <<< "${tempday}${tbl_super_dive}"   ;;
    esac

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao ${chao}.${chao2:-lohi}
    fn_echo_warn "END=$END time=${HMS} index=${iF5} FIELD=${FIELD}"
}

function fn_ban()
{
    iDATE=`fn_get_prev`
    tempday="(SELECT * FROM day WHERE date='${iDATE}')"
    sql="SELECT round(d.close*shares/10000,1) as col FROM cap as c, ${tempday} as d WHERE c.code=d.code ORDER by col ASC LIMIT 770,1"
    smlYi=`mysql -N kts <<<"${sql}"`
    sql="SELECT round(d.close*shares/10000,1) as col FROM cap as c, ${tempday} as d WHERE c.code=d.code ORDER by col ASC LIMIT 1540,1"
    midYi=`mysql -N kts <<<"${sql}"`
    sql="SELECT round(d.volume/shares, 4)     as col FROM cap as c, ${tempday} as d WHERE c.code=d.code ORDER by col ASC LIMIT 1160,1"
    tov=`mysql -N kts <<<"${sql}"`

    fn_echo_succ ${tov} ${smlYi} ${midYi}

    factor=${ZIZE:-0.25}    # tov(30min) ~= 25%，3个10分钟分别是：<12:8:5> * 优秀因子1.5 0940 0945 0950=>  0.18 0.25 0.30

    fn_run()
    {
    # 有时小票连续3板也是好票 <300314	戴维医疗>，特别是10点前封板票
    incr="incr<${incr:-22}"
    COND="${incr}" LIMIT=1400 HAV="avri>2&&rise>avri-.6 && tov>${factor}&&tov<.8 && ${xCOND}" SELECT lohi ${1:-1}
    }

    fn_echo_blue "small"
    incr=30 xCOND="eYi>nmcYi*${factor}*${tov} && nmcYi<=${smlYi}"
    fn_run $1
    xt_ret $? "" || return $?

    fn_echo_succ "middle"
    xCOND="eYi>nmcYi*${factor}*${tov} && nmcYi>${smlYi}&&nmcYi<${midYi}"
    fn_run $1 2>/dev/null
    xt_ret $? "" || return $?

    fn_echo_warn "large"
    xCOND="eYi>nmcYi*${factor}*${tov} && nmcYi>=${midYi}"
    fn_run $1 2>/dev/null
    xt_ret $? "" || return $?

    # 底部、中部，拒绝顶部
    fn_echo_warn "scale<1.2"
    xCOND="eYi>nmcYi*${factor}*${tov}"
    COND='incr>=22 && scale<1.2' LIMIT=1400 HAV="avri>2&&rise>avri-.6 && tov>${factor} and ${xCOND}" SELECT lohi ${1:-1} 2>/dev/null
    xt_ret $? "" || return $?
}

function fn_xRD()
{
    sqls="SELECT * from xRD WHERE date >= '${END}' && date<='${date_F}' HAVING 1 ${COND} ORDER BY ${FIELD:-date} DESC"
   #END=${date_F}
   #sqls="SELECT * from xRD WHERE date='${END}' HAVING 1 ${COND} ORDER BY ${FIELD:-date} DESC"
    fn_imysql_sqls
    xt_ret $? "" || return $?

    fn_chao ${chao}
}

function fn_cap()
{
    if [ -n "${1}" ]; then
        COND="code=${1}"
    elif [ -f "${YIST}" ]; then
        fn_yist
    else
        echo "Usage: SELECT cap code"
        echo "       YIST=x SELECT cap"; exit
    fi

    mysql -t kts <<<"SELECT * FROM cap WHERE ${COND:-1} ${inLIST} ORDER by nmc DESC;"
    return $?
}

function fn_lhb()
{
    if [ -n "${CAUSE}" ]; then
        CAUSE=` sed -e "s/c3/cause='3up20'/"        \
                    -e "s/c7/cause='up7'/"          \
                    -e "s/cs/cause='s3up12'/"       \
                    -e "s/ct/cause='tov20'/"        \
                    -e 's/A/\&\&/g'                 \
                    -e 's/O/||/g' <<< "${CAUSE}"`
        CAUSE="and (${CAUSE})"
        # echo ${CAUSE}; exit
    fi

    sql_maxdate="SELECT max(date) FROM lhb"
    max_dt=`mysql -N kts <<< "${sql_maxdate}"`
    case $1 in
    C|cause)
        mysql -t kts <<<"SELECT DISTINCT cause FROM lhb"
        ;;
    l|dates)
        fn_list_date $2
        ;;
    d|del)
        date=`fn_get_date ${2:-1}`
        mysql kts <<< "DELETE FROM lhb WHERE date='${date}'"
        xt_ret $? "del fail" || return $?
        fn_echo_succ "del from lhb@${date}"
        ;;
    +10|g)
        sta=`fn_get_date ${2:-1}`
        off=`mysql -N kts <<< "SELECT count(*) from day WHERE code=900001 and date>='${sta}' && date<='${END}'"`

        if [ "${1}" = '+10' ]; then
            tbl="SELECT * FROM day WHERE date>='${sta}' && date<='${END}' and (close-yesc)/yesc>.0993"
            sql="SELECT code,count(code) as num FROM (${tbl}) as t GROUP by code ORDER by num DESC LIMIT ${LIMIT:-30}"
        else
            wsql="WHERE date>='${sta}' && date<='${END}' && (chng>=3.82)"
            sql="SELECT code,count(code) as num FROM lhb ${wsql} GROUP by code ORDER by num DESC LIMIT ${LIMIT:-30}"
        fi

        sql="SELECT * FROM ($sql) as t HAVING 1 ${COND}"
        mysql -t kts <<<"${sql}"
        fn_echo_succ "${sta} wday:`date --date=${sta} +'%w'` off:${off}"
        sqls=${sql} fn_chao ${chao}
        ;;
    i|c)
        if [ $1 = c ]; then
            fn_iscode $2
            xt_ret $? "code:${2}" || return $?
            fn_xtempday $2
            xt_ret $? "xtempday error" || return $?
            COND="${COND} and code=${2}"
            col_date='date,'
            FIELD=${FIELD:-date}
            sql_relate="&& l.date=d.date"
            sql_xtempday=", xtempday as d"
            LIMIT=${LIMIT:-8}
        else
            fn_isdigit ${2:-1}
            xt_ret $? "\$2[$2] must be digit" || return $?
            date=`fn_get_date ${2:-1}`

            fn_xtempday ${date}
            xt_ret $? "xtempday error" || return $?

            sql_relate="&& l.code=d.code && l.date='$date'"
            sql_xtempday=", xtempday as d"

            # 自动处理apple
            RET=`mysql -N kts <<< "SELECT IF('${date}'<'${CURR}', 1, 0)"`
            if [ "${RET}" -eq 1 ]; then
                xdate=`END=${date} fn_get_next`

                TBL=x fn_xtempday ${xdate}
                xt_ret $? "xtempday error" || return $?
                sql_relate="&& l.code=x.code ${sql_relate}"
                sql_xtempday="${sql_xtempday}, x"
                sql_next="
                ${APPLE} as apple,
                ROUND(100*(x.high-x.yesc)/x.yesc, 1) as hiri,
                "
                FIELD=${FIELD:-apple}
            fi
        fi

        ABBR=l fn_yist

        columns="${col_date}code,cause"
        columns=l.${columns//,/,l.}

        sqls="
            SELECT ${columns}, 
            ${OPRI} as opri,
            ${RISE} as rise,
            ${sql_avrg}
            ${sql_next}
            ${sql_tov}
         -- round(bloo/sloo, 2) as bsp,
            round(sloo/ 100, 2) as sell,
            round(bloo/ 100, 2) as buy,                         -- 成交占比
            round(bloo/100-sloo/100, 2) as pet,                 -- 净买入占比

            round(sell/10000,2) as eSell,
            round(buy/10000, 2) as eBuy,                        -- 额度(亿)
            round((buy-sell)/10000, 2) as eNet,

            round(l.buy/bloo/100, 2) as eYi, ${nmcYi0},
            c.name FROM lhb as l,cap as c ${sql_xtempday}
            $WHERE l.code=c.code ${sql_relate}
            HAVING 1 ${CAUSE} ${COND} ORDER by ${FIELD:=buy} DESC LIMIT ${LIMIT:-36}
        "
        #echo "${sqls}"; exit
        mysql -t kts <<<"${sqls}"
        fn_echo_warn "lhb of ${date} ${COND} [${FIELD}] suggest[ buy>.15&&eBuy>.5 ]"
        fn_chao ${chao}.lhb
        ;;
    *)
        fn_echo_succ "\tlhb max_date@${max_dt}"
        echo "
        SELECT lhb <param>
        l       上榜日期list
        d [i]   删除数据，i即iEND
        C|cause 上榜原因list
        g|+10 n n日内{+3.82%|涨停}次数统计
        c code  指定代码
        i [i]   SELECT日期，i即iEND

        CAUSE='c3Oc7Oct'
        c3   3up20
        c7   up7
        cs   s3up12
        ct   tov20
             tov!>20 && avrg>7 && opri>3 (tov太大即3日内到头 && 和大猪在一起 && 起飞的欲望)

        FIELD=eYi COND='eYi>.5' CAUSE='c3Oc7Oct' SELECT lhb s
        COND='rise>0&&eYi>.5&&buy>.18' FIELD=buy SELECT lhb i
        iEND=2 COND='rise>0&&eYi>.5&&buy>.18' FIELD=hiri SELECT lhb i
        "
        ;;
    esac

    return $?
}

function fn_scale()
{
    HMS=${HMS:-`fn_get_time ${iHMS}`}
    SEC_150000=54000
    SEC_113000=41400
    SEC_093000=34200
    SEC_110000=39600
    col_open="IF( TIME_TO_SEC('$HMS') <= ${SEC_113000}, TIME_TO_SEC('$HMS')-${SEC_093000}, TIME_TO_SEC('$HMS')-${SEC_110000} )"
    col_scale="IF(TIME_TO_SEC('$HMS') <= ${SEC_150000}, ${col_open}, 60*60*4)"


    index=`mysql -N kts <<<"SELECT FLOOR( (${col_scale} + 30)/(60*6))-1"`
      mod=`mysql -N kts <<<"SELECT FLOOR( (${col_scale} + 30)/(60*3))%2"`

    # 每6分钟一个校正
    # iEND=5 CHAO=1 LIMIT=2000 COND="tov>2.5 && tov<7.5" SELECT lsd
    # tov<7.5，11:18:00达到50%
    # tov>7.5，为<7.5更快到达，但总体误差是很小的

    iRATIO=(
        .051 .092 .130 .166 .198 .230 .258 .284 .308 .331 # 10  .331  -- 1.64
        .353 .375 .395 .415 .433 .451 .474 .498 .517 .534 # 20  .203            -- 成交呈3223月牙状，中间两中时较稳定
        .553 .569 .590 .611 .629 .654 .673 .692 .709 .733 # 30  .201            -- 如果1st+，且调低预期，3rd+，则要调高最后预期
        .756 .775 .796 .816 .834 .856 .884 .913 .950 1.00 # 40  .267  -- 1.34
    )
    #echo index:${index} mod:${mod} iRATIO+mod: `bc -l<<<"scale=3;${iRATIO[${index}]}*(1+${mod}/80)"`; exit

    # 成交量估算值 = tov * K = tov / 时间百分比 * 动态倍数
    # K = 动态倍数/时间百分比

    case $1 in
    SCALE)  sqls="SELECT ROUND( 1 / (${iRATIO[${index}]}*(1+${mod}/80) ), 3)"   ;;
    PROP)   sqls="SELECT ROUND( ${iRATIO[${index}]}*(1+${mod}/80),2 )"          ;;
    *)      echo "带权    不带权  prop"
            sqls="SELECT ROUND( 1 / (${iRATIO[${index}]}*(1+${mod}/80) ), 3),
                    ROUND((60*60*4)/${col_scale}, 3), 
                    ROUND( ${iRATIO[${index}]}*(1+${mod}/80),2)"                ;;
    esac
    #echo "${sqls}"; exit
    mysql -N kts <<< "${sqls}"
}

function fn_list_wolf_dates()
{
    fn_echo_warn "date of wolfes"
    mysql -N kts<<< "SELECT DISTINCT date FROM mat_dde ORDER by date DESC LIMIT ${LIMIT:-10}" | cat -n
    exit
}

function fn_list_wolf_times()
{
    fn_echo_warn "time @${END}"
    mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC" | cat -n
    exit
}

function fn_enum_wolf_times()
{
    mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC" | wc -l
}

function fn_proc_eCOND_scale()
{
    if fn_issqltrue "'${stime}'>'12:00:00'"; then
        eCOND=${eCOND//iSCALE/13}
    elif fn_issqltrue "'${stime}'>'10:30:00'"; then
        eCOND=${eCOND//iSCALE/8}
    elif fn_issqltrue "'${stime}'>'10:00:00'"; then
        eCOND=${eCOND//iSCALE/5}
    elif fn_issqltrue "'${stime}'>'09:47:00'"; then
        eCOND=${eCOND//iSCALE/3}
    else
        eCOND=${eCOND//iSCALE/1}
    fi
}

function fn_wolf_turnov()
{
    sql_stime="SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC LIMIT ${sta:-0},1"
    stime=`mysql -N kts<<< "${sql_stime}"`
    iCOND="time='${stime}'" xCol=date fn_xCol mat_dde xdde ${END}
    sqls="
    SELECT
        date,
        ROUND(sum(rise>0)/count(code), 2) as rise,
        ROUND(sum((pbuy+nbuy)/tov)/count(code), 2) as wolf,
        ROUND(sum((psell+nsell)/tov)/count(code), 2) as nolf,
        ROUND(sum((pbuy+nbuy-psell-nsell)/tov)/count(code), 2) as net,
        ROUND(sum(amount*(pbuy+nbuy)/tov/10000), 2) as eWolf,
        ROUND(sum(amount)/10000,2) as eYi
    FROM (SELECT * FROM xdde ORDER by tov DESC LIMIT 50) as tbl
    "
}

function fn_wolf_tof()
{
    echo
}

function fn_wolf_top50()
{
    columns="date,rise,wolf,nolf,net,eWolf,eYi"
    sqls="$DROP wolf_tov; $CREATE wolf_tov LIKE wolf_turnover;"
    mysql -N kts <<< "${sqls}"

    dates=(`fn_get_date 1 ${NUM:-10}`)
    local i
    for (( i=0,j=1; i<${#dates[@]}; i++,j++ )); do
        END=${dates[$i]} fn_wolf_turnov
        # no time,
        sqls="INSERT INTO wolf_tov(${columns}) ${sqls} "
        # echo "${sqls}"
        mysql -t kts <<< "${sqls}"
    done

    sqls="SELECT ${columns} FROM wolf_tov"
    mysql -t kts <<< "${sqls}"
    mysql -N kts <<< "${sqls}" | \
        awk 'BEGIN {sum=0} {sum=sum+$6;} END {printf "avrg: %.2f, avrg.8: %.2f\n", sum/FNR, .8*sum/FNR}'
}

function fn_enable_xbb()
{
    [ "${XBB:-0}" = 0 ] && return
    xbb_col="speed as xbb,"
    xbb_update="UPDATE xdde,xbb SET xdde.speed=xbb.xbb WHERE xdde.code=xbb.code;"
}

function fn_lohi_shift()
{
    let NUM=LIMIT+2     # echo $NUM $LIMIT
    sql_shift="DELETE FROM $t_tov5 WHERE end='${END}'\n"
    dates=(`fn_get_date 1 ${NUM}`)

    for (( i=0,j=1; i<${#dates[@]}-1; i++,j++ )); do
        iFrom=${dates[$j]};
        iTo=${dates[$i]};
        sql_shift="${sql_shift}; UPDATE $t_tov5 SET end='${iTo}' WHERE end='${iFrom}';\n"
        # echo $i From ${iFrom} to ${iTo}
    done
    echo -e "${sql_shift}" | mysql -N kts
}

function fn_wolf_code()
{
    fn_iscode $2
    xt_ret $? "Usage: SELECT wolf c code" || {
    mysql -N kts<<< "SELECT DISTINCT date,time FROM dde ORDER by date DESC LIMIT ${LIMIT:-10}" | cat -n
    return 1
    }

    if [ "${1}" = c ]; then
        jCOND="date<='${END}'"
        col_date="w.date,"
        ORDER="ORDER by ${FIELD:-date} DESC"
        iTBL=dde
    else
        jCOND="date='${END}'"
        col_date="w.date,time,"
        ORDER="ORDER by date DESC, time DESC"
    fi

    t_tov5='t_mavol5c'
    iCOND="num=${NUM:-8}"   xCol=code fn_xCol mat_lohi ${t_tov5} ${2}
    xt_ret $? "" || return $?

    iCOND="${jCOND}"        xCol=code fn_xCol ${iTBL:-mat_dde} xdde ${2}
    xt_ret $? "" || return $?

    LIMIT=${LIMIT:-12}
    fn_lohi_shift;          # 进行数据平移

    sql_cond="&& w.code=${2} && w.date=h.end"
    col_name=
    fn_name ${2}
    DOOR=-.5 fn_wolf_sqls
    mysql ${OPT:-'-t'} kts <<<"${xbb_update}${sqls}"
    #mysql -t kts <<<"${sqls}"
    fn_chao
    return $?
}

function fn_wolf_sqls()
{
    col_tet="ROUND(net/(1-top10_ajst_aR), 2) as Tet,"
    FIELD=${FIELD:-eWolf}
    DOOR=${DOOR:--1/5}
    yesc='(trade/(1+rise/100))'
    sqls="
        SELECT ${col_date} w.code, w.rise,
        ROUND( (100*(w.amount/shou-$yesc)/$yesc), 1) as avri,
        ${sql_opri} ${sql_hiri} ${col_trade}
        round(100*(trade-h.low)/h.low, 1) as incr,
    --  round(100*(h.high-LEAST(lohi,trade))/LEAST(lohi,trade),1) as jump,
        tov,
        ROUND((pbuy+nbuy)/w.tov, 2) as eWolf,   -- 若使用(amount/nmc/100)代替tov,在价涨时结果偏大，价跌时偏小
        (pbuy+nbuy) as buy,                     -- (psell+nsell) as sell,pbuy,nbuy,
        round(net/tov, 2) as pet,
        ROUND(100*( LEAST(w.amount/shou,trade) - (h.amount/h.volume) )/(h.amount/h.volume), 1) as cise, -- COSE-RISE
    --  round((pbuy/nbuy), 2) as Go, round((pbuy+nbuy)/(psell+nsell),1) as bsp,
        ${xbb_col}
        round((w.shou/h.volume), 2) as prop, h.scale,
        round((w.tov*h.mavol5/w.shou), 1) as tov5,
        round(w.amount/10000, 1) as eYi,
        ROUND(nmc, 1) as nmcYi
        ${col_name}
        FROM xdde as w, ${t_tov5:-t_mavol5} as h ${tbl_temp}
        ${WHERE} w.code=h.code ${sql_cond} && net/tov>${DOOR} ${sql_pplus}
        HAVING 1 ${COND} ${ORDER:-ORDER by ${FIELD} ${ASC:-DESC}} LIMIT ${LIMIT:-36}
    "
    #echo "${sqls}"; exit
    fn_echo_warn "wolf of ${date:-${END}}.${stime:-latest} [nmc:$nmc_lion eYi:$eYi DOOR:${DOOR}] [COND: ${COND}] ${FIELD}"
}

function fn_wolf()
{
    sql_maxdate="SELECT max(date) FROM dde"
    max_dt=`mysql -N kts <<< "${sql_maxdate}"`
    sql_mindate="SELECT min(date) FROM dde"
    min_dt=`mysql -N kts <<< "${sql_mindate}"`
    [ "${max_dt}" != ${CURR} ] && { fn_echo_fail "${max_dt} != ${CURR}, dde is lagged"; return 1; }
    sql_maxend="SELECT max(end) FROM mat_lohi"
    max_end=`mysql -N kts <<< "${sql_maxend}"`
    fn_issqltrue "'${max_end}' >= '${PREV}'"
    [ "${?}" -ne 0 ] && { fn_echo_fail "lohi is lagged, updating..."; SCREENER lohi 1; return 1; }
    fn_enable_xbb

    case $1 in
    l)  fn_list_wolf_dates $2   ;;
    st) fn_list_wolf_times      ;;
    top)fn_wolf_top50           ;;
    c)  fn_wolf_code $1 $2      ;;
    cf) fn_wolf_code $1 $2      ;;
    i)
        sql_hiri="$LORI as lori,"
    #   sql_hiri="$HIRI as hiri,"
        sql_opri="$OPRI as opri,"
        col_name=',w.name'
        fn_bist
        ABBR=w fn_yist
        fn_isdigit ${sta:=${2:-1}} || fn_list_wolf_times
        let sta--
        fn_proc_eCOND_scale
        stime=`mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC LIMIT ${sta},1"`
        iCOND="time='${stime}'${eCOND}" xCol=date fn_xCol mat_dde xdde ${END}
        xt_ret $? "" || return $?

        PREV=`END=${date:-${END}} fn_get_prev ${iPASS}`
        fn_update_mavol5

        fn_xtempday
        xt_ret $? "" || return $?

        tbl_temp=", xtempday as d"
        sql_cond="&& w.code=d.code"
        c_natural='d.high!=d.low&&d.close/yesc<1.15'

        case ${PPLUS} in
        V|v) sql_pplus="&& ${c_natural} && d.open/yesc<1.093 && (w.tov*h.mavol5/w.shou)>=${vDOOR:-4}"   ;;
        esac

        fn_wolf_sqls

        case ${PARTS:-o} in
        s) return                                                       ;; # 只获取$sqls
        f) CHAO=1                                                       ;; # 只输出文件chao.chao2
        o) sqls="${xbb_update}${sqls}" fn_imysql_sqls | fn_hew_tail     ;; # 只输出STDOUT
        esac
        fn_chao ${chao}.${chao2:-wolf}
        ;;
    a|e|E)
        col_trade='trade,'
        HMS=${HMS:-`fn_get_time 1`}
        eYi=${eYi:-.1}                  # tag_伸缩处理
        case $1 in
        a) eCOND="&&amount>${eYi}*10000"                                                ;;
        e) eCOND="&&amount>${eYi}*10000*iSCALE && nmc<=${nmc_wolf}"; nmc_lion=$nmc_wolf ;;
        E) eCOND="&&amount>${eYi}*10000*iSCALE && nmc> ${nmc_wolf} && nmc<${nmc_lion}"  ;;
        esac

        FIELD=${FIELD:-eWolf} fn_wolf i ${2:-1}
        ;;
    *)
        fn_echo_succ "\twolf date ${min_dt}~${max_dt}"
        echo "
        SELECT wolf <param>
        l               date-list
        st              time-list
        i|a|e|E [iF5]   SELECT time or list-times
        c       code    按日统计
        cf      code    按15分钟统计
        top             NUM日统计top50 tov
        " 2>&1 # | sed 's/^  *//g'
        ;;
    esac

    return $?
}

function fn_fmacd()
{
    mysql -t kts <<< "SELECT * FROM fmacd";
}

function fn_macd()
{
    fn_yist
    case $1 in
    c|clean)
        echo "DROP TABLE IF EXISTS mm55" | mysql kts;
        fn_echo_succ "succ: clean macd!"; exit 0
        ;;
    [0-9]*)
        COND="and code=$1"
        FIELD=$2
        ;;
    u|h)
        echo "
        c           # clean mm55
        000002      # 只显示单个代码的macd
        "
        exit
        ;;
    *)
        FIELD=$1
        ;;
    esac

    fields='close,fa20,ma5,ma10,ma20,ma40,ma80'
    limo='(FM=15)*IF(close>=fa20, 1, -1)*((fa20>=ma5)+(fa20>=ma10)+(fa20>=ma20)+(fa20>=ma40)+(fa20>=ma80))'
    echo "
    SELECT code,FM,datetime%1000000 as time,
        ${fields},
        round(100*( abs(ma5-ma10)/ma10 + abs(ma20-ma10)/ma10 ), 2) as abs,
            cvgenc,
            ${limo} as limo, d1,m1,dif,macd FROM mm55
            HAVING 1 ${COND} ${inLIST}
            ORDER by ${FIELD:-code},FM ${ASC:-ASC};
	" | mysql -t kts

    return $?
}

function fn_prop()
{
    # tempday
    [ -z "${iTime}" ] && {
        iTime=`fn_get_time ${1}`
        xt_ret $? "Please check data.dorat@${END}" || return $?
        TEMPDAY=xtempday
        FEN=${iTime} DAY=dorat fn_xtempday      # faster than sub-select
        xt_ret $? "" || return $?
    }

    NUM=${NUM:-4}   # 2，与昨日比较是否放量
    let CNT=NUM-1
    PREV4=`fn_get_date ${NUM}`
    sqls="
    $CREATE tov8 (
        code    INT(6) ZEROFILL NOT NULL,
        tov     DECIMAL(6,2) NOT NULL DEFAULT 0,
        shou    DECIMAL(6,2) NOT NULL DEFAULT 0,
        INDEX(code)
    );
    TRUNCATE tov8;
    INSERT INTO tov8
    SELECT code,tov,shou FROM (
      SELECT code, sum(tov)/${CNT} as tov, sum(shou)/${CNT} as shou, SUM(tov>=${propDOOR:-5}) as num, name 
        FROM dde WHERE date>='${PREV4}' and date<='${PREV}' 
        GROUP by code
        HAVING num=${CNT} ORDER by code ASC
    ) as t;

    SELECT COUNT(d.code),ROUND( sum(d.volume/t.shou)/COUNT(d.code), 3) 
        FROM xtempday d, tov8 t WHERE d.code=t.code INTO @c_all, @propa;

    SELECT 
        COUNT(d.code) as num,
        ROUND( sum(d.volume/t.shou)/COUNT(d.code), 3) as prop
        FROM xtempday d, tov8 t WHERE d.code=t.code && d.volume/t.shou>@propa 
        INTO @nump, @propp;

    UPDATE carbon SET prop0=@propa, prop5=@propp;
    "
    sqls_sufix="
    SELECT
        '${END}' as date,
        '${iTime}' as time,
        @c_all as num,
        @propa as propa,    -- a is avrg
        @nump as nump,
        @propp as propp;    -- p is power

    SELECT d.code,ROUND(d.volume/t.shou, 3) as prop 
        FROM xtempday d, tov8 t WHERE d.code=t.code HAVING 1 ${COND} ORDER by prop DESC;
    "

    [ "${PARTS:-o}" = o ] && sqls="${sqls}${sqls_sufix}"    # s silent, o output

    #echo "${sqls}"; exit
    mysql -t kts <<< "${sqls}"
}

function fn_tovprop()
{
    # tempday
    [ -z "${HMS}" ] && {
        HMS=`fn_get_time ${1}`
        xt_ret $? "Please check data.dorat@${END}" || return $?
        TEMPDAY=xtempday
        FEN=${HMS} DAY=dorat fn_xtempday      # faster than sub-select
        xt_ret $? "" || return $?
    }

    NUM=${NUM:-4}   # 2，与昨日比较是否放量
    let CNT=NUM-1
    PREV4=`fn_get_date ${NUM}`
    sqls="
    $CREATE tovprop LIKE tov8;
    TRUNCATE tovprop;
    INSERT INTO tovprop
        SELECT code, sum(tov)/COUNT(code) as tov, sum(shou)/COUNT(code) as shou 
        FROM dde WHERE date>='${PREV4}' and date<='${PREV}' 
        GROUP by code 
        ORDER by code ASC;

    -- LEAST(1.25)是为了更加平滑
    SELECT COUNT(d.code),ROUND(sum(LEAST(d.volume/t.shou, 1.25))/COUNT(d.code), 3)
        FROM xtempday d, tovprop t WHERE d.code=t.code INTO @c_all, @propa;

    SELECT 
        COUNT(d.code) as num,
        ROUND( sum(LEAST(d.volume/t.shou, @propa*1.25))/COUNT(d.code), 3) as prop
        FROM xtempday d, tovprop t WHERE d.code=t.code && d.volume/t.shou>@propa 
        INTO @nump, @propp;

    UPDATE carbon SET propa=@propa, propp=@propp;
    "
    sqls_sufix="
    SELECT
        '${END}' as date,
        '${iTime}' as time,
        @c_all as num,
        @propa as propa,    -- a is avrg
        @nump as nump,
        @propp as propp;    -- p is power

    SELECT d.code,ROUND(d.volume/t.shou, 3) as prop 
        FROM xtempday d, tovprop t WHERE d.code=t.code HAVING 1 ${COND} ORDER by prop DESC LIMIT 1;
    "

    [ "${PARTS:-o}" = o ] && sqls="${sqls}${sqls_sufix}"    # s silent, o output

    #echo "${sqls}"; exit
    mysql -t kts <<< "${sqls}"
}

function fn_flat()
{
    ABS=$1      # 支持ABS以过滤反弹
    fn_bist
    fn_yist

    PREV5=`fn_get_date ${NUM:-5}`
    sqls="
    SELECT d.code, 
        sum(${ABS}(close/yesc-1)<=.05) as cnt,
        sum(${ABS}(close/yesc-1)) as sumrise
    FROM day d $WHERE date>='${PREV5}' and date<='${PREV}'
    GROUP by code HAVING cnt>=${DOOR:-4} && sumrise<8
    ORDER by sumrise DESC
    "

    [ "${PARTS:-f}" = o ] && mysql -t kts <<< "${sqls}"
    fn_echo_succ "PARTS:${PARTS:-f} flat@${END} feed cond [${ABS}(rise.cnt) <= 5%]"
    CHAO=1 fn_chao ${chao}.flat
}

function fn_stat()
{
    case $1 in
    hot)
        fn_yist
        PREV5=`fn_get_date ${NUM:-8}`
        sqls="
        SELECT 
            d.code,
            COUNT(d.code) as live,
            SUM((d.close-d.yesc)/d.yesc>.093 && (d.close-d.yesc)/d.yesc<.15) as cnt,
            SUM(high=low) as yiz,
            c.name
            FROM day d , cap c 
            $WHERE d.code=c.code AND d.date>='${PREV5}' AND d.date<='${END}' 
            GROUP by code HAVING cnt>=${DOOR:=1} && ${HAV:-'cnt>yiz'} ${COND}
            ORDER by ${FIELD:-cnt} DESC LIMIT ${LIMIT:-36}
        "
        fn_imysql_sqls | fn_hew_tail
        fn_echo_succ "[NUM:${NUM:-8}]日热点 @${END} [FIELD:${FIELD:-cnt}] [cnt.DOOR:${DOOR}]"
        fn_chao ${chao}.hot
        ;;
    flat)
        fn_flat $2
        ;;
    born|b)
        PREV5=`fn_get_date ${NUM:-8}`
        HMS=`fn_get_time ${2/tp10/}`

        [ "${2}" = tp10 ] && { 
            t_tp10=', top10 p'; c_tp10='&&d.code=p.code'; if_tp10='top10 as tp10,' 
        }
        [ "${NUM:-8}" -ne 2 ] && iCOND="(d.close-d.yesc)/d.yesc>.093"                   # NUM=2，当天复牌股
        FEN=${HMS} DAY=dorat fn_xtempday
        sqls="
        SELECT 
            d.code,
            COUNT( d.code ) as works,
            SUM((d.close-d.yesc)/d.yesc>.093 ) as cnt,
            SUM(d.high=d.low && (d.close-d.yesc)/d.yesc>.093) as yiz,
            SUM((d.close-d.yesc)/d.yesc >.15) as new,                           -- 非新股
            ${if_tp10}
            ${nmcYi},
            c.name
            FROM day d , cap c, xtempday x ${t_tp10}
            WHERE d.code=c.code && d.code=x.code ${c_tp10} AND d.date>='${PREV5}' AND d.date<='${END}' 
            GROUP by code HAVING works<${NUM:-8}
                && cnt>=works-1                                                 -- 连板or当天开板
                && new<1 ${COND}
            ORDER by ${FIELD:-cnt} DESC LIMIT ${LIMIT:-36}
        "
        fn_imysql_sqls | fn_hew_tail
        fn_echo_succ "[NUM:${NUM:-8}]日复牌 @${END} [FIELD:-${FIELD:-cnt}]"
        fn_chao ${chao}.born
        ;;
    m|mid)
        fn_echo_fail "换手率排名500,1000"
        ASC=DESC LIMIT=500,1 END=${END} FIELD=tov SELECT lsd
        ASC=DESC LIMIT=999,1 END=${END} FIELD=tov SELECT lsd

        fn_echo_blue "成交额排名300,500"
        ASC=DESC LIMIT=300,1 END=${END} FIELD=amount SELECT lsd
        ASC=DESC LIMIT=500,1 END=${END} FIELD=amount SELECT lsd

        fn_echo_fail "流通市值排名500,1000"
        ASC=DESC LIMIT=500,1 END=${END} FIELD=nmc SELECT lsd
        ASC=DESC LIMIT=999,1 END=${END} FIELD=nmc SELECT lsd

        fn_echo_blue "自然涨停中位数，相近成交额500th"
        num=`OPT='-N' LIMIT=400 END=${END} FIELD=amount PPLUS=N SELECT lsd top 2>/dev/null | wc -l`
        let LIMIT=num/2
        ASC=DESC LIMIT="${LIMIT},2" END=${END} FIELD=amount SELECT lsd top
        fn_echo_succ "_____ Layout @${END} ______"
        ;;
    *)
        echo "
        SELECT stat <param>:
        hot                     # 涨停板收益统计
        flat                    # 一字板收益统计
        b|born tp10             # NUM=2，当天复牌股
        m|mid                   # 指标中值状态 middle of 1160
        t|realtimetov           # 统计各时段成交额
        "
        exit
        ;;
    esac
    return $?
}


function fn_prop_proc()
{
    PARTS=s fn_tovprop
    score="
        ROUND(sum(LEAST(d.volume/v.shou/@propp, 5))/COUNT(t.code), 2) as prop,
        ROUND(sum(tov/(1-top10))/COUNT(t.code), 2) as tov,
        ROUND(sum(rise)/count(t.code)*.6  + 
              sum(earn)/count(t.code)     +
              ((count(t.code)-1)/3) + (sum(rise>=5)/3) +
              (LEAST(sum(tov/(1-top10))/COUNT(t.code), 10)/2-3.5)+
              ( sum(LEAST(d.volume/v.shou/@propp, 5))/COUNT(t.code) -2)*3
             ,1) as score
    "
    PFROM="
    FROM top8 t, tovprop v, xtempday d, top10 p
    WHERE t.code=v.code && t.code=d.code && t.code=p.code
    "

    sqls_prop="
    SELECT propa,propp FROM carbon INTO @propa,@propp;
    SELECT d.code, ${RISE} as rise, @propa,@propp, volume, shou, volume/shou/@propp as prop
    FROM xtempday d, tovprop v $WHERE d.code=v.code
    ORDER by rise DESC LIMIT 10;
    "

    p_cond="prop>=1.7"
}

function fn_sample()
{
    fn_yist && xWHERE=${WHERE}

    echo BLK is ${BLK}
    HMS=`fn_get_time $1`
    # 非一字板 && ＞-1.5%的个股
    iCOND="(high!=low||d.close/yesc<1.093) && d.close/yesc<1.15 && d.close/yesc>=.985 ${cond5}" \
    FEN=${HMS} DAY=dorat fn_xtempday
    xt_ret $? "xtempday error" || return $?

    score="
        ROUND(sum(rise)/count(code)*.6  + 
              sum(earn)/count(code)     +
              ((count(code)-1)/3) + (sum(rise>=5)/3) ,1) as score
    "
    [ "${P}" = 1 ] && fn_prop_proc

    echo "
    $DROP topN;
    $CREATE topN (
        blk     INT,
        sym     CHAR(64),
        code    INT(6) ZEROFILL NOT NULL,
        close   DECIMAL(6,2) NOT NULL DEFAULT 0,
        yesc    DECIMAL(6,2) NOT NULL DEFAULT 0,
        rise    DECIMAL(6,2) NOT NULL DEFAULT 0,
        earn    DECIMAL(6,2) NOT NULL DEFAULT 0,
        INDEX(blk,code)
    );
    $DROP top8;
    $CREATE top8 LIKE topN;
    " | mysql kts

    SAMPLES=${SAMPLES:-8}

    sqls_head="
    INSERT INTO topN
    SELECT n.blk, sym, x.code,close,yesc,
        ROUND(100*(close-yesc)/yesc, 2) as rise,
        ROUND(100*(close-amount/volume)/yesc, 2) as earn
        FROM blk_name as n, blk_memb as m, xtempday as x
        WHERE n.blk=m.blk AND n.blk NOT in ${EXCLUDE_BLK} AND m.code=x.code;

    INSERT INTO top8
    SELECT * from topN a where ${SAMPLES}>(select count(*) from topN where blk=a.blk and rise>a.rise) order by a.blk,a.rise desc;

    SELECT propa,propp FROM carbon INTO @propa,@propp;
    "
    sqls="${sqls_head}
    SELECT hex(blk),sym, count(t.code) as SAMPLES,
        ROUND(sum(rise)/count(t.code), 2) as rise,
        ROUND(sum(earn)/count(t.code), 2) as earn,
        sum(rise>=3) as clk3,
        sum(rise>=5) as clk5,
        sum(rise>=${TEN:=9.93}) as click,
        ${score}
    ${PFROM:-FROM top8 t}
    GROUP by blk
    HAVING ${p_cond:-1} ${COND} ORDER by ${FIELD:=score} DESC LIMIT ${LIMIT:-20};
    "

    #echo "${sqls}"; exit
    mysql -t kts <<< "${sqls}"
    xt_ret $? "" || return $?

    fn_echo_succ "END:${END}.${HMS} SAMPLES:${SAMPLES} TEN:${TEN:=9.93} FIELD:${FIELD}"

    [ -z "${BLK}" ] && return

    # fn_check_blk_abbr
    # 每个method有专用WIT，此默认作用2
    WIT=1 LIMIT=10 PPLUS=N COND= FIELD= fn_lsds ${1}

    [ -n "${sqls_prop}" ] && mysql -t kts <<< "${sqls_prop}"
}

function fn_blk_delta()
{
    [ "${2}" = l ] && fn_list_iF5_times

    case $1 in
    us)
        # 基于前提约束：只做强势股，绝对值弱于大盘不做考虑
        iCOND="AND high!=low&&open/yesc<1.093 && close/yesc<1.15 && 100*(close/yesc-1)>=${iDOOR:-0}"
        sfiled='rise'
        sdirct='desc'
        sopr='>'
        ;;
    u)
        iCOND=
        post_sql="DELETE FROM x0 WHERE close-close2>=0;"
        sfiled='ride'
        sdirct='desc'
        sopr='>'
        ;;
    d)
        iCOND=
        post_sql="DELETE FROM x0 WHERE close-close2>=0;"
        sfiled='ride'
        sdirct='asc'
        sopr='<'
        ;;

    h|*)
        echo "
   SELECT blk delta C [end off] 抓住指数每一个拐点细节
            u                   领涨即抗跌排名
            d                   领跌排名
           us                   高涨幅领跌排名
            l                   从3个维度考量：数量、delta涨幅、最高涨幅
         BLK=                   追加展示BLK内的细节
            h                   Print this help
            "
        exit
        ;;
    esac

    let STEP=${3:-1}+1              # 默认隔1个时间单位
    HMS1=`fn_get_time $2`           # HMS不精确时亦可用
    HMS2=`iASC=DESC HMS=$HMS1 fn_get_time ${STEP}`

    echo "
    $DROP deltaN;
    $CREATE deltaN (
        blk     INT,
        sym     CHAR(64),
        code    INT(6) ZEROFILL NOT NULL,
        close   DECIMAL(6,2) NOT NULL DEFAULT 0,
        yesc    DECIMAL(6,2) NOT NULL DEFAULT 0,
        rise    DECIMAL(6,2) NOT NULL DEFAULT 0,
        ride    DECIMAL(6,3) NOT NULL DEFAULT 0,
        earn    DECIMAL(6,2) NOT NULL DEFAULT 0,
        INDEX(blk,code)
    );
    $DROP delta8;
    $CREATE delta8 LIKE deltaN;
    " | mysql kts

    SAMPLES=${SAMPLES:-8}
    TEMPORARY=TEMPORARY

    col1="code,yesc,close,volume,amount"
    col2="code,close"
    x1="( SELECT ${col1} FROM dorat WHERE date='${END}' and time='${HMS1}' $iCOND )"
    x2="( SELECT ${col2} FROM dorat WHERE date='${END}' and time='${HMS2}' $iCOND )"
    sqls_pro="
    DROP TABLE IF EXISTS x0;
    CREATE $TEMPORARY TABLE x0 (
        code    INT(6) ZEROFILL NOT NULL,
        yesc    DECIMAL(6,2) NOT NULL,
        close   DECIMAL(6,2) NOT NULL,
        close2  DECIMAL(6,2) NOT NULL,
        volume  DECIMAL(12,2) NOT NULL,
        amount  DECIMAL(12,2) NOT NULL,
        INDEX(code)
    );
    INSERT INTO x0
    SELECT x1.code,x1.yesc, x1.close,x2.close, x1.volume,x1.amount
        FROM $x1 as x1, $x2 as x2 WHERE x1.code=x2.code;
    ${post_sql}

    INSERT INTO deltaN
    SELECT n.blk, sym, x.code,x.close,yesc,
        ROUND(100*(x.close-yesc)/yesc, 2) as rise,
        ROUND(100*(x.close-x.close2)/yesc, 3) as ride,
        ROUND(100*(x.close-amount/volume)/yesc, 2) as earn
        FROM blk_name as n, blk_memb as m, x0 as x
        WHERE n.blk=m.blk AND n.blk NOT in ${EXCLUDE_BLK} AND m.code=x.code;

    INSERT INTO delta8
    SELECT * from deltaN a
        where ${SAMPLES}>(select count(*) from deltaN where blk=a.blk and ${sfiled} ${sopr} a.${sfiled}) order by a.blk,a.$sfiled ${sdirct};
    "
    sqls="
    SELECT hex(blk),sym, count(code) as SAMPLES,
        ROUND(sum(rise)/count(code), 2) as rise,
        ROUND(sum(ride)/count(code), 3) as ride,
        ROUND(sum(earn)/count(code), 2) as earn,
        sum(rise>=3) as clk3,
        sum(rise>=5) as clk5,
        sum(rise>${TEN:=9.93}) as click FROM delta8
    GROUP by blk
    HAVING 1 ${COND} ORDER by ${FIELD:=${sfiled}} ${sdirct} LIMIT ${LIMIT:-20}
    "
    #echo "${sqls_pro}${sqls}"; exit
    # mysql -t kts <<<"${sqls_pro}${sqls}"
    fn_imysql_sqls
    xt_ret $? "" || return $?

    fn_echo_succ "end:${HMS1} prev:${HMS2} FIELD:${FIELD}"

    [ -z "${BLK}" ] && return
    # 两次相同的mysql.SELECT请求结果会被缓存
    # sqlv="SELECT * FROM deltaN d WHERE blk=0x${BLK} ORDER by ${sfiled} ${sdirct} LIMIT ${LIMIT:-12}"
    fn_check_blk_abbr
    cols="sym,d.code,d.close,rise,ride,earn"
    sqls="SELECT ${cols}, ${nmcYi},c.name
            FROM delta8 d, cap c WHERE blk=0x${BLK} and d.code=c.code ORDER by ${sfiled} ${sdirct} LIMIT ${iLIMIT:-10}"
    sqls_pro= fn_imysql_sqls
    fn_chao ${chao}.delta
}

function fn_blk_wolf_blk()
{
    CHAO=1 PARTS=f FIELD= fn_blk U $1                          # output to ${chao}.blk
    LIMIT=20 FIELD= YIST=${chao}.blk SELECT wolf e ${2}
}

function fn_blk_wolf_scale()
{
    columns='id,date,time,code,net,pbuy,nbuy,psell,nsell,rise,trade,speed,shou,tov,amount,nmc,name'
    col_pre=x1.${columns//,/,x1.}
    col_pre=${col_pre//x1.speed/x2.shou}
    echo "
    UPDATE xdde SET speed=shou;
    CREATE TEMPORARY TABLE xdd2 LIKE dde;
    INSERT INTO xdd2(code,shou) SELECT code,shou FROM dde WHERE date='${PREV}';
    REPLACE INTO xdde(${columns})
    SELECT ${col_pre} FROM xdde as x1, xdd2 as x2 WHERE x1.code=x2.code
    " | mysql -N kts
    xt_ret $? "" || return $?
}

function fn_blk_wolf_team()
{
    sta=${1:-1}
    let sta--
    stime=`mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC LIMIT ${sta},1"`
    iCOND="time='${stime}'" xCol=date fn_xCol mat_dde xdde ${END}
    xt_ret $? "" || return $?
    yizis="SELECT code FROM day WHERE date='${END}' && high=low and high>yesc"  # 剔除一字板
    fn_blk_wolf_scale
    xt_ret $? "" || return $?
    #
    eWolf="ROUND(100*nmc*(pbuy+nbuy)/amount, 2)"
    sql_blk="${sql_blk:-"hex(n.blk) as blk"}"
    sqls="
    SELECT ${sql_blk}, count(m.code) as num, n.sym,
        round(sum(rise    )/count(m.code), 2) as rise,
        round(sum(100*(trade-amount/shou)/(trade/(1+.01*rise)))/count(m.code), 2) as earn,
        round(sum((shou/speed))/count(m.code), 2) as scale,
        round(sum(${eWolf})/count(m.code), 2) as wolf,
        sum(rise>${TEN:=9.93}) as click
    FROM blk_name as n, blk_memb as m, xdde as x
    $WHERE n.blk=m.blk and m.code=x.code
        && x.rise<10.1 && m.code NOT IN (${yizis:-888888})
        && m.blk not in ${EXCLUDE_BLK} ${iCOND}
        && ${eWolf}>${iDOOR:=.4} && rise>${rDOOR:=2} && ${sql_nmc:-"nmc<${nmc_wolf}"}
    GROUP by blk
    HAVING num>${iNUM:-1} && click>${click:=-1} ${COND}
    ORDER by num DESC LIMIT ${LIMIT:-16}
    "
    #echo "${sqls}" ; exit
    FIELD=${FIELD:-num}
    fn_echo_succ "${END} ${stime} [iDOOR:$iDOOR] [rDOOR:$rDOOR] [TEN:$TEN] [click:${click}] [FIELD:$FIELD]"

    case ${PARTS:-o} in
    s) return                                                                   ;;
    o) mysql -t kts <<< "SELECT * FROM (${sqls}) as tbl ORDER by ${FIELD} DESC" ;;
    esac

    return
}

function fn_blk_wolf_inter()
{
    PARTS=s sql_blk=n.blk fn_blk_wolf_team ${1:-1}
    eWolf="ROUND(100*x.nmc*(pbuy+nbuy)/amount, 2)"
    echo "${sqls}" | mysql -t kts
    echo "
    SELECT m.code, count(m.code) as num, ${eWolf} as eWolf, c.name
        FROM cap as c, blk_memb as m, xdde as x, (${sqls}) as T
        WHERE m.blk=T.blk && m.code=x.code && m.code=c.code && ${eWolf}>${DOOR:-.4} && x.nmc<${nmc:-150} && m.blk not in ${EXCLUDE_BLK}
        GROUP by code
        HAVING num>=3
        ORDER by ${FIELD:-eWolf} DESC LIMIT ${LIMIT:-36}
    " | mysql -t kts
    return $?
}

function fn_blk()
{
    EXCLUDE_BLK="(
    0xD813,  -- 875 | 深港通
    0xCE54,  -- 898 | 融资融券
    0xDAE8,  -- 574 | 沪港通概念
    0xDBD4,  -- 316 | 股东增持
    0xD953,  -- 243 | 参股金融
    0xD886,  -- 100 | 证金持股
    0xDB9B   -- 81  | 转融券标的
-- ,0xDA4D   -- 305 | 央企国资改革
-- ,0x40     -- 226 | 新股与次新股
    )"

    case $1 in
    g|grep)     LIMIT=500 fn_blk l | grep ${2:-'\<FF'} ;;
    d|delta)    fn_blk_delta ${@:2} ;;
    L)          BLK=PRI fn_check_blk_abbr ;;
    l|layout)
        ABBR=m fn_yist
        sqls="
        SELECT hex(n.blk) as blk,count(m.code) as num,n.sym FROM blk_name as n, blk_memb as m
        $WHERE n.blk=m.blk AND n.blk not in ${EXCLUDE_BLK} ${notinBLK}
        GROUP by blk ORDER by ${FIELD:-num} ${ASC:-DESC} LIMIT ${LIMIT:-20}"
        fn_imysql_sqls
        ;;
    sample)
        [ "${2}" = l ] && fn_list_iF5_times
        fn_sample ${2}
        ;;
    10)
        ABBR=m fn_yist
        [ "${2}" = l ] && fn_list_iF5_times
        iTime=`fn_get_time ${2}`
        TEMPDAY="(SELECT * FROM dorat WHERE date='${END}' && time='${iTime}')"
        fn_echo_succ "Classify @${END}:${iTime} [rDOOR:${rDOOR:=2}] [TEN:${TEN:=9.93}] [FIELD:${FIELD:-num}]"
        echo "
        SELECT hex(n.blk) as blk,
            sum(${RISE}>3) as clk3,
            sum(${RISE}>5) as clk5,
            sum(${RISE}>${TEN}) as click,
            count(m.code) as num,
            ROUND(sum(${RISE})/count(m.code), 2) as rise,
            n.sym FROM blk_name as n, blk_memb as m, ${TEMPDAY:-xtempday} as d
         $WHERE m.code=d.code && n.blk=m.blk AND n.blk not in ${EXCLUDE_BLK} ${notinBLK}
                AND ${RISE}>${rDOOR}
         GROUP by blk ORDER by ${FIELD:-num} ${ASC:-DESC} LIMIT ${LIMIT:-20};
        " | mysql -t kts
        ;;
    wolf)
        set -e
        usage="Usage:
        iDOOR=.40 COND='click>0&&earn>.3'
        iDOOR=.50 rDOOR=2 SELECT blk wolf {list|[E.a.BLK]iF5}
        "
        ABBR=m fn_yist
        cond_lion="nmc>${nmc_wolf}&&nmc<=${nmc_lion}"
        case $2 in
        l|list)     fn_list_wolf_times                              ;;
        a)          sql_nmc="1" fn_blk_wolf_team $3                 ;;
        E)          sql_nmc="${cond_lion}" fn_blk_wolf_team $3      ;;
        [0-9]*)     fn_blk_wolf_team $2                             ;;
        40|[A-Z]*)  COND= fn_blk_wolf_blk ${@:2}                    ;;
        *)          echo "${usage}"                                 ;;
        esac
        ;;
    acc)
        fn_peeloff_blk
        off=${2:-1}
        sta=`fn_get_date ${off}`
        fn_sqls() {
        sqls="
        SELECT d.code,sum(${RISE}) as rise, ${nmcYi}, c.name FROM day as d, cap as c ${frBLK}
            ${WHERE} d.code=c.code and d.date>='${sta}' && d.date<='${END}' ${inBLK}
            and low!=high
            GROUP by code
            HAVING ${HAV:-1} ${COND} and rise>${rDOOR:-'-100'}
            ORDER BY ${FIELD:-rise} ${ASC:-desc} LIMIT ${LIMIT:-36}
        "
        }
        fn_sqls
        #echo "${sqls}" ; exit
        mysql -t kts <<< "${sqls}"
        LIMIT=3000 fn_sqls
        fn_chao ${chao}.opt.acc
        ;;
    hot)
        #nmc_t=',cap c'; nmc_c='AND d.code=c.code AND nmc<100*10000';
        COND="AND SAMPLES>1" \
        cond5="AND tov>=${vDOOR:-3.5}" \
        xWHERE="${nmc_t} ,t_matov5 t WHERE d.code=t.code ${nmc_c} AND" \
        FIELD=${FIELD:-score} \
        BLK= fn_blk sample $2
        [ -n "${BLK}" ] && BLK=${BLK} PPLUS=V LIMIT=12 SELECT lsds $2
        ;;
    stat)
        NUM=${NUM:-3}
        dates=(`fn_get_date 1 ${NUM}`)
        mysql kts <<< "TRUNCATE blk_stat"
        for (( i=${NUM}-1; i>=0; i-- )); do
            date=${dates[$i]}
            FIELD= rDOOR=5 iCOND="&&x.amount>000" iNUM=2 PARTS=s END=${date} fn_blk_wolf_team 1   # iNUM 3只才成组
            sqls=${sqls//hex(/(}
            echo "
            INSERT INTO  blk_stat
            SELECT '$date', blk,num,sym,rise,earn,wolf,click FROM ($sqls) as t
            " | mysql kts
        done
        sqls=" SELECT hex(blk),count(blk)as top16s, sym,
                    sum(num)as nums, sum(click)as tens,sum(rise)*num as rises
                    FROM  blk_stat
                    GROUP by blk
                    ORDER by ${FIELD:=top16s} DESC LIMIT ${LIMIT:-40}"
        count=`mysql -N kts<<<"SELECT count(date) FROM (SELECT DISTINCT date FROM blk_stat) as t"`
        fn_echo_succ "blk stat in ${count} days [FIELD:$FIELD]"
        mysql -t kts <<<"${sqls}";
        exit ;;
    inter)
        fn_blk_wolf_inter $2
        ;;
    c|code)
        for code in ${@:2}; do
            fn_iscode ${code}
            xt_ret $? "" || return $?
            fn_name ${code}

            FIELD=${3:-blk}
            echo "
             SELECT m.code, hex(n.blk) as blk, n.sym FROM blk_name as n, blk_memb as m
             WHERE n.blk=m.blk and code=${code}
             ORDER by ${FIELD} DESC LIMIT ${LIMIT:-36};
            " | mysql -t kts
        done
        ;;
    f|find)
        fn_echo_blue "to find ${2}"
        LIMIT=300 fn_blk l | grep ${2}
        ;;
    # 差集
    dif|D)
        argv=(${@:2})
        sqls="SELECT code FROM blk_memb WHERE blk=0x${argv[0]}"
        for i in ${argv[@]:1}; do
            sqls="${sqls} and code NOT in (SELECT code FROM blk_memb WHERE blk=0x${i})"
        done
        #echo "${sqls}"; exit
        ABBR=cap fn_yist
        sqls="SELECT cap.code,${nmcYi},name FROM cap $WHERE cap.code in ($sqls)" fn_imysql_sqls
        fn_chao ${chao}.dif
        ;;
    # 差集版本2: BLK-YIST
    !)
        if [ -z "${YIST}" ]; then
            fn_echo_fail "Usage: YIST=xxx SELECT ! blk..."
            exit
        fi
        ABBR=c fn_yist
        ABBR=c fn_peeloff_blk
        sqls="
        SELECT c.code, name FROM cap as c ${frBLK}
        $WHERE c.code NOT IN (SELECT code FROM xblk)
        "
        mysql -t kts <<< "${sqls}"
        fn_chao ${chao}.opt.minus
        ;;
    # 交集
    intersection|A)
        argv=(${@:2})
        sqls="SELECT code FROM blk_memb WHERE blk=0x${argv[0]}"
        for i in ${argv[@]:1}; do
            sqls="${sqls} and code in (SELECT code FROM blk_memb WHERE blk=0x${i})"
        done
        #echo "${sqls}"; exit
        ABBR=cap fn_yist
        sqls="SELECT cap.code,${nmcYi},name FROM cap $WHERE cap.code in ($sqls)" fn_imysql_sqls
        fn_chao ${chao}.A
        ;;
    # 并集
    union|U)
        ABBR=m fn_yist
        ABBR=m BLK=${@:2} fn_peeloff_blk
        sqls="
        SELECT m.code,count(m.code) as num, ${nmcYi}, c.name
            FROM blk_memb as m, cap as c ${frBLK}
            ${WHERE} m.code=c.code ${inBLK} ${sql_exclude}
            GROUP by code HAVING 1 ${COND}
            ORDER by ${FIELD:-num} ASC LIMIT ${LIMIT:-500}
        "
        #echo "${sqls}">/dev/stderr; exit

        case ${PARTS:-o} in
        s) return               ;;
        f) CHAO=1               ;;
        o) fn_imysql_sqls       ;;
        esac
        fn_chao ${chao}.${chao2:-blk}
        ;;
    *)
        echo "
        SELECT blk <param>    # 注：使用HAVING向<SELECT lsd>传递条件
        l                     # layout
        d|delta u|d|us iF5    # 指数涨幅贡献：做差&显示layout&追加BLK的个股细节
        sample  iF5           # 价角度：只统计前10涨幅 P=1放量追踪
        hot     iF5           # sample+tov5(vDOOR)
        10      iF5           # 价角度：涨停板概念分类 {DOOR:-10}，查讯iF5: SELECT lsd l
        wolf  [E|a|BLK] iF5   # 能角度：
        stat                  # 3日热点统计
        acc     off           # off日内代码累计涨幅
        c       code          # 显示code关联的所有板块
        !       blk [...]     # 求YIST-BLK...的差集
        D       big small     # 求两个blk的差集 big-small
        A       blk blk2      # 求两个blk的交集
        U       blk [...]     # 求几个blk的并集(.c时可作为输出)
                              # blk中code关联的blk数目排名，越小，概念越纯正
        "
        ;;
    esac

    return $?
}

function fn_dde_wolf()
{
    STA=`fn_get_date ${NUM:-10}`
    fn_bist
    fn_yist
    columns="date,d.code,trade,rise"
    sqls="
    SELECT ${columns},ROUND((pbuy+nbuy)/tov, 2) as eWolf,
        round(amount/10000, 1) as eYi, nmc,name FROM dde as d
    $WHERE 1 ${COND} and date>='${STA}' && date<='${END}' && rise>=9.93 && nmc<=120
    HAVING eWolf>.5
    ORDER by ${FIELD:-code } ASC
    "
    mysql -t kts <<<"${sqls}"
    CHAO=1 fn_chao ${chao}.${chao2:-dde}

    return $?
}

function fn_dde()
{
    USAGE="
    SELECT dde <param>
    c code
    wolf    [SELECT blk stat g]的配套查询
    "
    case $1 in
    [036][0-9]*)
        fn_iscode $1
        xt_ret $? "" || return $?
        field='date,code,net,pbuy,nbuy,psell,nsell,rise,trade,shou,tov,amount,nmc,name'
        sqls="SELECT ${field} FROM dde WHERE code=$1 and date<='${END}' ORDER by date DESC LIMIT ${LIMIT:-12}"
        fn_imysql_sqls | fn_hew_tail
        ;;
    wolf)
        fn_dde_wolf
        ;;
    *)
        echo "${USAGE}"
        ;;
    esac

    return $?
}

function fn_max()
{
    STA=`fn_get_date ${1:-5} 1` #echo ${STA}
    let half=${1}/2
    sqls="
    SELECT date,code,close,max(close),count(code) as num  FROM
    ( SELECT * FROM day $WHERE date>='${STA}' && date<='${END}' ORDER by date DESC ) as d
    GROUP by code HAVING max(date)='${END}' && close=max(close) && num>${half};
    "

    if [ "${1}" -gt 5 ]; then
        mysql -t kts <<<"${sqls}"
    fi

    fn_chao ${chao}.${chao2:-max20}
    chao2=

    return $?
}

function fn_g20()
{
    CHAO=1 chao2=max5 fn_max 5
    YIST=${chao}.max5 chao2=max${1} fn_max ${1:-20}
    return $?
}

function fn_ATR()
{
    # usage
    [ -z "${1}" ] || [ "${1}" = u ] && \
    echo "
    SELECT ATR {u|a|code}
    e.g. LIMIT=800 COND='ATV>5' CHAO=1 SELECT ATR a
    " && exit

    if fn_iscode $1; then
        STA=`fn_get_date ${NUM:-10} 1`
        fn_name $1
        echo "
        SELECT *, ROUND(100*GREATEST(high-low, high-yesc, yesc-low)/yesc, 2) as ATR
            FROM day WHERE code=$1 and date>='${STA}' and date<='${END}' ORDER by date DESC;
        " | mysql -t kts; exit
    fi

    NUM=${NUM:-40}
    STA=`fn_get_date ${NUM} 1` #echo ${STA}
    let half=${NUM}/${PARTS:-4}
    [ "${1}" = a ] || CONDbig="and max(date)='${END}'"    # a 所有， r 当天阳线

    fn_yist
    sqls="
    SELECT t.date, num, t.code, ATR,
        ROUND( 100*atv/(c.nmc/c.close), 2) as ATV, c.name
         FROM (
        SELECT date,code,
            ROUND( sum( 100*GREATEST(high-low, high-yesc, yesc-low)/yesc )/count(code), 2 ) as ATR,
            ROUND( sum( volume )/count(code), 2) as atv,
            count(code) as num
            FROM
        ( SELECT d.* FROM day as d $WHERE date>='${STA}' && date<='${END}' && high!=low && close>yesc
          ORDER by date DESC ) as d2
        GROUP by code HAVING num>${half} ${CONDbig}
    ) as t, cap as c WHERE t.code=c.code
    HAVING 1 ${COND}
    ORDER by ATR DESC LIMIT ${LIMIT:-40}
    "

    #echo "${sqls}"; exit
    mysql -t kts <<<"${sqls}"

    fn_chao ${chao}.${chao2:-ATR}

    return $?
}

function fn_wee()
{
    NUM=${NUM:-3}
    end1=${END}
    sta1=`fn_get_date ${NUM} 1`
    end2=`END=${sta1} fn_get_date 2 1`
    sta2=`END=${end2} fn_get_date ${NUM} 1`
    end3=`END=${sta2} fn_get_date 2 1`
    sta3=`END=${end3} fn_get_date ${NUM} 1`

    #echo $end1 $sta1 $end2 $sta2 $end3 $sta3; exit

    fn_tbl() {
    echo "
    ( SELECT date,code, ROUND( sum(volume)/count(code), 2 ) as mavol
        FROM
        ( SELECT d.* FROM day as d $WHERE date>='${1}' && date<='${2}'
          ORDER by date DESC
        ) as d2 GROUP by code
    )"
    }

    fn_yist
    t1="`fn_tbl ${sta1} ${end1}`"
    t2="`fn_tbl ${sta2} ${end2}`"
    t3="`fn_tbl ${sta3} ${end3}`"

    sqls="
    SELECT t1.code,
        ROUND(t2.mavol/t3.mavol,2) as w1,
        ROUND(t1.mavol/t2.mavol,2) as w2,
        ROUND(100*t1.mavol*c.close/c.nmc,2) as tov FROM
        ${t1} as t1,
        ${t2} as t2,
        ${t3} as t3,
        cap   as c
        WHERE t1.code=c.code && t1.code=t2.code && t1.code=t3.code && t2.mavol>t3.mavol
        HAVING 1 ${COND}
        ORDER by ${FIELD:-tov} DESC
        LIMIT ${LIMIT:-200}
    "

    #echo "${sqls}"; exit
    mysql -t kts <<<"${sqls}"
    fn_chao ${chao}.${chao2:-eek}${NUM}
    return $?
}

function fn_notice()
{
  helpmsg="
  NUM=  搜索范围，默认7
  c     clean空文件
  g     grep '$×'
  消息  高开低走有惊喜: 2015-12-11.亿帆鑫富
  获+   是重要的关键字
  "
    cmdlist=(
    "非公开发行限售股           -----注意黑天鹅------"
    "增持                       看增持数量"
    "收购                       若关联定向增发，增发价可作为支撑"
    "签署战略                   VR"
    "重大合同"
    "[^重].合同"
    "利润分配                   高送转预案"
    "高送转"
    "股东权益变动               举牌"
    "回购.*股份                 国内回购只能注销，是真自救"
    "挂牌转让"
    "实际控制人变更             重组预期"
    )
    cd /opt/notice/
    case $1 in
    [036][0-9][0-9][0-9]*)
        grep --color "${1}" * ;;
    +([0-9]))
        [ $1 -ge ${#cmdlist[@]} ] && \
        fn_execute --list && fn_echo_fail "  -- fn_execute $1 too big --\n" && return
        cmd=${cmdlist[$1]/ */}
        grep --color "${cmd}" `ls -t | head -${NUM:-7}`
        ;;
    code)
        [ -f "${2}" ]
        xt_ret $? "file [${2}] not exist" || return $?
        grep '^[036][0-9][0-9][0-9]' $2  | awk '{print $1}' | sort -u > ${chao}.nocode
        fn_echo_succ "extract codes from ${2} to ${chao}.nocode OK"
        ;;
    c|clean)
        wc -l * | grep -w 0 | awk '{print $2}' | xargs rm -f
        ;;
    g|grep)
        grep "$*" *
        ;;
    *|l|--list)
        fn_execute
        ;;
    esac

    return $?
}

function fn_ddd()
{
    case $1 in
    d3)
        PREV3=`fn_get_date 3`
        echo "
        SELECT t1.code FROM
        (SELECT * FROM day WHERE date='${END}')   t1,
        (SELECT * FROM day WHERE date='${PREV}')  t2,
        (SELECT * FROM day WHERE date='${PREV3}') t3
        WHERE t1.code=t2.code && t1.code=t3.code and t1.volume<t2.volume && t2.volume<t3.volume && t1.close<t3.close;
        " | mysql -N kts > /tmp/kts/chao.d3
        ;;
    bang)
        fn_echo_succ "上午封板@${END}"
        PARTS=f chao2='lsd' CHAO=1 COND="rise>9.93" iASC=DESC HMS=12:00:00 vDOOR=3 SELECT lsd 1
        xt_ret $? "" || return $?

        fn_echo_succ "下午开板@${END}"
                chao2=bang CHAO=1 COND="rise<9.93" YIST=${chao}.lsd SELECT lsd

        if [ "${iEND:-1}" -gt 1 ] && [ `wc -l <${chao}.bang` -gt 0 ]; then
            NEXT=`fn_get_next`
            fn_echo_succ "NEXT.表现"
            END=${NEXT} YIST=${chao}.bang SELECT lsd
        fi
        ;;
    110)
        TYPE=${2:-e}
        COND="(rise>=9.93&&eWolf>.49)" \
        PARTS=f CHAO=1 LIMIT=200 END=${PREV} SELECT wolf ${TYPE}
        COND="(rise<opri||(opri<0&&rise<opri+2)||cise<2)&&prop<${prop:-1.1}" \
        YIST=${chao}.wolf LIMIT=100 SELECT wolf ${TYPE}
        fn_echo_succ "[prop:${prop}] 昨日涨停 -- ma20&特别关注标的：eYi＞5亿"

        COND="(rise<9.94&&avri>4.5&&eWolf>.43&&eYi>5)" \
        PARTS=f CHAO=1 LIMIT=200 END=${PREV} SELECT wolf ${TYPE}
        xt_ret $? "PARTS=f CHAO=1 LIMIT=200 END=${PREV} SELECT wolf ${TYPE}" || return $?
        COND="(rise<opri||(opri<0&&rise<opri+2)||cise<2)&&prop<${prop:-1.1}" \
        YIST=${chao}.wolf LIMIT=100 SELECT wolf ${TYPE}

        fn_echo_succ "[prop:${prop}] 昨日大额 -- ma20&+12%&特别关注：剔除大宗交易"
        ;;
    000)
        CHAO=1 LIMIT=200 COND="(rise>=9.93&&eWolf>.49&&eYi>1)||(avri>4.5&&eWolf>.43&&eYi>5)" SELECT wolf e
        export YIST=${chao}.wolf
        local i
        for (( i=0; i<${STEP:-2}; i+=1 )); do
            END=`END=${END} fn_get_next`
            echo ${END} is end
            COND="prop<1" CHAO=1 LIMIT=200 chao2=000 END=${END} SELECT wolf e
            YIST=${chao}.000
        done
        fn_echo_succ "[prop:${prop}] 1.MAX量日avrg>5 2.最大cise超过5 3.量价能3齐缩 4.价不能上涨"
        ;;
    100)
        TYPE=${2:-e}
        PREV2=`fn_get_date 3`
        COND="(rise>=9.93&&eWolf>.49)||(avrg>5&&eWolf>.43&&eYi>5)" \
        PARTS=f CHAO=1 LIMIT=200 chao2=curr END=${PREV2} SELECT wolf ${TYPE}
        # prop<.6
        COND="(rise<opri||(opri<0&&rise<opri+2))&&eWolf>=.25&&prop<${prop:-.81}" \
        PARTS=f CHAO=1 LIMIT=200 chao2=next YIST=${chao}.curr END=${PREV} SELECT wolf ${TYPE} || exit
                CHAO=1 LIMIT=200 chao2=100  YIST=${chao}.next COND="scale+prop<1.7" SELECT wolf ${TYPE}
        fn_echo_succ "[prop:${prop}] 两日内价格在PREV2涨停下交易"
        ;;
    rhx)
        CHAO=1 LIMIT=200 COND="(rise>=9.93&&eWolf>.49&&eYi>1)||(avri>5&&eWolf>.43&&eYi>5)" SELECT wolf e
        export YIST=${chao}.wolf
        COND="prop>.99&&prop<=1.2"
        local i
        for (( i=0; i<${STEP:-2}; i+=1 )); do
            END=`END=${END} fn_get_next`
            echo ${END} is end
            COND="${COND}" CHAO=1 LIMIT=200 chao2=rhx END=${END} SELECT wolf e
            COND="prop<1"
            YIST=${chao}.rhx
        done
        fn_echo_succ "[prop:${prop}] 1.价格首过ma20 2.可适度放量 3.cise超5 4.等待net>0"
        ;;
    *)
        echo "
        XBB=1 SELECT ddd <para> # XBB=1使能xbb列
        d3                      # 连续3天缩量
        bang                    # 上午封板显实力，下午开板显套利空间
        000                     # iEND=3 连续缩量[STEP=2]天
        110                     # 2阳1阴--打板小白收割机.rise前30分坚决下跌无诱多.high不创新高
        100                     # 1阳2阴--＞5亿
        rhx                     # 操作龙头，允次日微放量+DAY3缩量 when [STEP=2]
        "
        ;;
    esac
}

function fn_seat_rank()
{
    sqls="
    SELECT code, name, count(code) as num, sum(month) as mon, sum(amount) as eWan
        FROM seat_rank GROUP by code HAVING num>${NUM:-0} ORDER by eWan DESC
    "
    fn_imysql_sqls
}

function fn_seat_detail()
{
    sql_door=1
    sql_seat="
    SELECT code FROM (SELECT code, name, count(code) as num, sum(month) as mon, sum(amount) as eWan
        FROM seat_rank GROUP by code HAVING num>${sql_door} ORDER by eWan DESC ) as t
    "

    d60=`fn_get_date 40`

    # try comment
    DISTINCT=DISTINCT

    sqls="
    SELECT $DISTINCT code FROM seat_detail WHERE seat in (${sql_seat}) and date>='${d60}' && date<='${END}'
    "

    CHAO=1 fn_chao ${chao}.${chao2:-seat}

    YIST=${chao}.seat SELECT blk l

    return $?
}


function fn_xtov()
{
    ROCKET='ROUND(IF(dy12>=dy35, dy12+.30*(dy35-1), dy35+.5*(dy12-1))-1, 2)'    # 修正2rd后的max(dy12,dy35)
    sqls="
    SELECT m.date, m.code, tov as tov5, dy12, 
        ${ROCKET} as i_dy, 
        ROUND(vax3/vax60, 2) as vax, ${nmcYi}, name
        FROM mat_ma1020 m, matov5 v, cap c 
        WHERE m.code=v.code AND m.code=c.code AND m.date='${END}' AND v.date='${END}'
        HAVING vax>=${DOOR:-.88} ${COND}
        LIMIT ${LIMIT:-24}
    "
    fn_imysql_sqls | fn_hew_tail
    
    return $?
}

function fn_ma120()
{
    PREV10=`fn_get_date 13`
    PREV65=`fn_get_date 40`     # 13 weeks || 8 weeks
    PREV90=`fn_get_date 105`    # 21 weeks

    if [ "${1}" = 20 ]; then
        iTime=`fn_get_time ${2}`
        FEN=${iTime} DAY=dorat fn_xtempday
        xt_ret $? "" || return $?
        sqls="
        SELECT d.date, d.code, d.close, ${RISE} as rise, max(ma20) as max20, ${nmcTp} as nmc, c.name
           FROM mat_ma120 as m, cap as c, xtempday d, top10 t
           WHERE m.code=t.code AND m.code=c.code AND m.code=d.code AND (d.high!=d.low||d.close/yesc<1.093) AND
                 m.date>='${PREV65}' AND m.date<'${END}' AND ${nmcTp}<=90
           GROUP by code
           HAVING close*1.0382>=max20 ${COND}
           ORDER by ${FIELD:-rise} DESC LIMIT ${LIMIT:-1000}
        "
        # fn_imysql_sqls | fn_hew_tail
        CHAO=1 fn_chao ${chao}.20
        fn_echo_succ "gen max20 @${END}.${iTime} succ..."
    else
        sqls="
        SELECT d.date, d.code, COUNT(d.code) as num, SUM(d.close>ma120*1.005) as excel, ${nmcYi}, c.name
           FROM mat_ma120 as d, cap as c
           WHERE d.code = c.code AND d.date>='${PREV90}' AND d.date<='${PREV10}' 
           GROUP by code
           HAVING num>30 AND excel<2 ${COND}
           ORDER by code DESC LIMIT ${LIMIT:-2000}
        "
        #fn_imysql_sqls | fn_hew_tail; exit
        CHAO=1 fn_chao ${chao}.120
        fn_echo_succ "gen ma120 @${PREV90}~${PREV10} succ..."
    fi
}

function fn_xii()
{
    fn_ma120 2
    YIST='/tmp/kts/chao.120' PPLUS=G fn_lsdw $@
    
    return $?
}

function fn_seq()
{
    w3m -dump "http://home.flashdata2.jrj.com.cn/limitStatistic/zt/${END//-/}.js" > ${cache}.seq
    cat ${cache}.seq | \
        sed -e '1s#^.*:\[\[##g' -e '$s#]]}.*##g' -e 's#],\[#\n#g' -e 's/"//g' |
        awk -F',' -v v_date=$END '{ printf "%s\t%s\n", $1,$3 }' > ${flash}.seq
    #   awk -F',' -v v_date=$END '{
    #       printf "%s  %8s\t%-12s\t%s    %6.2f\t%5.2f\t%5.2f\t%5.2f\n", v_date,$1,$2,$3,$4,$5,$6/100000000,$7;
    #   }'
    fn_xtempday
    echo "
    CREATE TEMPORARY TABLE seq (
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        time        time,
        INDEX(code,time)
    );
    LOAD DATA LOCAL INFILE '${flash}.seq' INTO TABLE seq;

    SELECT '${END}' as date, d.code,s.time, ${TURNOV} as tov,
        ROUND(${nmc0}*(1-top10)/100,2) as nmc, ${nmcYi0}, c.name
        FROM seq s, xtempday d, cap c, top10 t
        WHERE s.code=d.code && s.code=c.code && s.code=t.code
        ORDER by time DESC
    " | mysql -t kts
}

function fn_volvo()
{

    case $1 in
    p)  P=1 fn_volvo ${@:2} ;;
    l)  fn_list_iF5_times   ;;
    v)  mysql -t kts <<< "SELECT * FROM volvo WHERE code=${2}" ;;
    e)  sqls="SELECT DISTINCT time FROM mat_vcdif WHERE date='${END}'"
        mysql -N kts <<<"${sqls}" > ${chao}.volvo.e
        SELECT lsd l | grep --color -f ${chao}.volvo.e
        fn_echo_succ "F2-list @${END}"
        ;;
  dir)  PARTS=f LIMIT=100 PPLUS=E SELECT lsd $2
        grep -v -f ${chao}.xin ${chao}.lsd > ${chao}.yiz

        [ -s ${chao}.yiz ] || { fn_echo_fail "chao.yiz is EMPTY [大盘振荡&新股大开板]"; exit ;}
        HAV="yiz>0" DOOR=0 FIELD=live YIST=/tmp/kts/chao.yiz fn_stat hot
        ;;
#bang)  eThrd=`OPT=-N LIMIT=35,1 FIELD=eYi OP=1+ fn_volvo 2>/dev/null| awk '{print $14}'`
   b*)  F2=`fn_get_time ${2}`
        fn_isF2 $F2 || { fn_echo_warn "${F2} no-F2"; return 1 ;} 
        SCREENER volvo c
        mysql -N kts <<< "SELECT code FROM volvo WHERE volvo<gate" > ${chao}.gate.volvo
        rThrd=`HAV= LIMIT=36 YIST=${chao}.gate.volvo OPT=-N FIELD=eYi PPLUS=G COND="rise>0" SELECT lsd $2 |
            awk 'BEGIN{total=0}{total+=$10}END{print total/48}'`
        #                        YIST=${chao}.gate.volvo PPLUS=G FIELD=eYi COND="rise>3" SELECT lsd $2; exit
        eThrd=`HAV= OPT=-N LIMIT=35,1 YIST=${chao}.gate.volvo PPLUS=G FIELD=eYi COND="rise>${rThrd}&&eYi<20" SELECT lsd $2 2>/dev/null |
            awk '{print $12}'`
        fn_echo_blue "rThrd:${rThrd}% eThrd:${eThrd}Yi"

        [ -z "${eThrd}" ] && fn_echo_fail "Null eThrd" && exit
        echo "${eThrd}" > ${chao}.eThrd

        PROP0=`fn_carbon get prop0`

        if [ -z "${CHK_RANK}" ]; then
            kCOND="(eYi>${eThrd} || (eYi>.6*${eThrd} && prop5BOO>4*$PROP0))" \
            COND="             AND (hiri>${lowDOOR:-3.8}&&rise>=3.5) " \
            YIST=${chao}.gate.volvo PPLUS=G FIELD=${FIELD:-rise} fn_lsds $2 > ${cache}.bang
            cat ${cache}.bang
            [ `wc -l<${cache}.bang` = 0 ] && fn_echo_fail "no big money@${END}"
        else
            kCOND="(eYi>${eThrd} || (eYi>.6*${eThrd} && prop5BOO>4*$PROP0))" \
            COND="&& rise<=7 AND (hiri>${lowDOOR:-3.8}&&rise>=3.5) " \
            HAV= YIST=${chao}.gate.volvo PPLUS=G FIELD=${FIELD:-rise} fn_lsds $2 > ${cache}.bang 2>/dev/pts/0
        fi
        return 0
        ;;
    c)
        fn_iscode $2
        xt_ret $? "code[$2]" || return $?
        sqls_pro="SELECT yesc FROM day WHERE date='${END}' AND code=${2} INTO @yesc;"
        sqls="
        SELECT m.*, vol1,vol2,volvo,gate, ROUND(vdiff/gate,2) as gPct, 
            ROUND(100*cdiff/@yesc,2) as rif4, 
            ROUND(100*(m.close-@yesc)/@yesc, 2) as rise
        FROM volvo v, mat_vcdif m WHERE v.code=m.code AND m.date='${END}' AND m.code=${2} ORDER by time ASC 
        "
        fn_imysql_sqls
        ;;
    [0-9]*|'')
        HMS=`fn_get_time ${1}`
        FEN=${HMS} DAY=dorat fn_xtempday      # faster than sub-select
        cols='m.code,m.time,vol1,vol2,volvo,gate'

        fn_bist
        ABBR=v fn_yist

        case $P in
        1) fn_isF4 ${HMS} && COND="${COND} AND time='${HMS}'" || { fn_echo_fail "notF4"; exit ;}    ;;
        e) OP=${OP:-1+}; FIELD=${FIELD:-eYi}; __eCOND="AND 100*(m.close-d.yesc)/d.yesc<6.88"        ;;
        esac

        sqls="
        SELECT ${cols}, 
            ROUND(volvo/gate, 2) as vPct,
            ROUND(100*cdiff/yesc, 2) as rif4,
            ${RISE} as rise,
            ${HIRI} as hiri,
            ROUND(${eFun}(adiff)/10000,2) as eF4,
            ROUND(SUM(adiff)/10000,2) as eAll,
            ROUND(d.amount/10000, 1) as eYi,
            ROUND(sum(adiff)/d.amount,2) as ePct,
            COUNT(m.code) as num, 
            ROUND(${nmc0}*(1-top10)/100,2) as nmc, c.name
            FROM volvo v, xtempday d, cap c, top10 p,
                 (SELECT * FROM mat_vcdif WHERE date='${END}' && time<='${HMS}' ORDER by time ${iASC:-DESC}) m
            $WHERE v.code=m.code AND v.code=d.code AND v.code=c.code AND v.code=p.code AND (${OP}(vdiff>=gate))
                AND high!=low AND (cdiff/yesc>=.006 || (m.close-yesc)/yesc>=.06)              -- SCREENER volvo make [cdiff>=0]
                ${eCOND}
            GROUP by v.code
            HAVING 1 ${COND}
            ORDER by ${FIELD:-rise} DESC LIMIT ${LIMIT:-24}
        "
        #echo "${sqls}"; exit
        fn_imysql_sqls | fn_hew_tail
        fn_echo_succ "${END}.${HMS} FIELD:${FIELD:-rise} eThrd:${eThrd}"
        fn_chao ${chao}.volvo
        ;;
    *|usage)
        echo "
        SELECT volvo
        iF5             # full
        f4              # single F4
        e               # exist iF5 list
        c   code        # code
        p               # 当下F4进行突破
        u               # usage
        "
        ;;
    esac
    exit
}

function fn_seat_zhao()
{
    PREV5=`fn_get_date ${NUM:-8}`

    sqls="
    SELECT 
    seat,date,code,
    ROUND(buy/10000) as buy,
    ROUND(sell/10000) as sell,
    name,cause
    FROM seat_zhao WHERE date>='${PREV5}' && date<='${END}'
    ORDER by date DESC, seat DESC LIMIT ${LIMIT:-24}
    "
    fn_imysql_sqls | fn_hew_tail
}

function fn_main()
{
    cmdlist=(
    "dugu9jian          [sortfield]           # chng只是(close-open)/open"
    "6maishenjian       [sortfield]           # chng只是(close-open)/open"
    "comma              [tbl_name:-day]       # 逗分列名"
    "list_date          num                   # num默认10"
    #wma                [sortfield:tov5]      # 均价+现成513.静态rat"
    #rat                [sortfield:-ratio]    # wma+day-->动态rat，实时速度快"
    #ma240              [sortfield:-ratio]    # "
    #ma240_usage        {1~9}                 # 分析ma 5 13 34 55"
    # ----------------  ABOVE IS FIXED SEQUENCE --------------------
    "dorat                                    # 分时数据iF5"
    "stat                                     # 大盘统计"
    "xRD                FIELD                 # #{OP:->}"
    "dirtio             HMS1 HMS2             # diff(dorat), HMS3由{iHMS|HMS}指定"
    #cap                code                  # 查询nmc&cap"
    #name               code                  # 名"
    #pma                code                  # NUM=5日平均"
    #macd               [clean]               # macd-alarm-sys"
    #fmacd                                    # 单个代码的macd"
    #fbi                                      # tbl_fbi"
    #td_layout          code                  # 日内最高价时点分布.10:00am"
    #accdiff                                  # tbl_adiff"
    #acf                                      # tbl_acfdiff"
    #tao5                                     # "
    #rdiff                                    # tbl_rdiff"
    #tri                                      # 3连阳"
    #ban                condi [time]          # 条件. 0945后使用"
    #wee                                      # NUM日为1个单位，3个周期环比[成交量放大倍数]"
    #ATR                all|redOnly|code      # AverageTrueRangeOf阳线非一字板"
    #ace                sta num               # 10日内所有+10% amount nmc 统计 [SELECT wolf top]"
    #g20                                      # 创20日新高"
    "ls                 {code|symbol}         # 日线数据 \$LIMIT"
    "lsf                code                  # 分时数据"
    "lsd                [{top|floor}][FIELD]  # --- END YIST LIMIT 涨幅排名"
    "lsdh                                     # lsd-hammer-无space细节"
    "lsds                                     # lsd-spacer-有space细节"
    "lsdt                                     # lsd-nmc.top10"
    "lsdw                                     # lsd-wolves"
    "xii                                      # ma120-专用"
    "updown                                   # 近期{NUM=5}涨跌家数统计"
    "hilo               FIELD                 # 跌幅统计"
    "lohi               FIELD                 # 涨幅统计"
    "lhb                excption              # 龙虎榜"
    "dde                                      # dde(CURR)>dde(PREV)"
    "wolf                                     # DDE"
    "xtov                                     # 放量情况"
    "blk                                      # 板块信息+涨幅统计"
    "ma120              [20]                  # 超跌-list，参数20时，close＞60内所有ma20的主升模式"
    "prop               iF5                   # 大tov.prop"
    "tovprop            iF5                   # 全tov.prop"
    "scale                                    # HMS= 可指定时间"
    "volvo                                    # 联合查询[iASC指定time.GROUP排序，默认DESC]"
    "notice                                   # 公告"
    "seq                                      # 涨停顺序"
    "ddd                                      # 连续缩量后放量"
    "seat_rank                                # 总排名，上榜次数num>#NUM"
    "seat_detail                              # 临幸板块seat-blk"
    "seat_zhao                                # 赵一万"
    )

    fn_set_END
    fn_execute "$@"
}

fn_main "$@"

# http://www.cnblogs.com/zhenjing/archive/2011/07/15/process_mutex_race.html
# 获取最大ID的记录

