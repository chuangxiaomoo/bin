#! /bin/bash
. `dirname ${0}`/'dbank' || { echo "dbank err" && exit; }
. /etc/common.rc

function fn_ls()
{
    [ $# -eq "0" ] && fn_execute -l && exit

    if fn_isdigit $1; then
        code=$1
    else
        local shmout=$SHMPATH/shmout
        local index=1
        echo "google  $1 ..."
        google $1 | tee $shmout
        [ 0 -ne  "${PIPESTATUS[0]}" ] && echo google fail && exit 1

        lines=`cat $shmout | grep '^[603]' | wc -l`
        [ 0 -eq "$lines" ] && echo "Error: no symbol $1 found" && exit
        if [ 1 -eq "$lines" ]; then
            code=`awk '/^[603]/{print $1}' $shmout`
            echo $code
        else
            while :; do
                cat -n $shmout
                read -p "    Please input index[1]:" index
                [ "${index:=1}" -le $lines ] && let index-- && break
            done
            codes=(`awk '{print $1}' $shmout`)
            code=${codes[$index]}
        fi
    fi

    fields='d.code,d.date,d.yesc,d.open,d.high,d.low,d.close,d.volume,d.amount'
    echo "
    SELECT nmc/close FROM cap WHERE code=${code} LIMIT 1 INTO @shares0;
    SELECT * FROM (
        SELECT $fields, $PEAK as peak, $TROUGH as trough, $RISE as rise, $TURNOV0 as turnover
        FROM day as d
        WHERE d.code = ${code} and d.date <= '${END}'
        ${COND} ORDER by date DESC limit ${LIMIT:-13}
    ) as tbl ORDER by date ASC;
	" | mysql -t kts
}

function fn_lsd()
{
    # where d.code = c.code 非常重要，不重叠的field不需要加‘tbl_name.’
    columns="code,yesc,open,close"
    columns=${columns:-'*'}
    columns=d.${columns//,/,d.}
    TEMPDAY='day'

    fn_yist
    fn_echo_warn "----- LIST:${#LIST[@]} COND@${END}: $COND -----"

    case $1 in
    t|top)
        LIMIT=${LIMIT:-200}
        HAVING="rise>9.93"
        field=${2:-nmc}
        chao=${chao}.top
        ;;
    f|floor)
        LIMIT=${LIMIT:-200}
        HAVING="rise<-9.93"
        field=${2:-nmc}
        ;;
    l|list)
        TAM=${END} SELECT lohi l; exit 0;
        ;;
    [0-9]*)
        if [ "${1}" = 0 ]; then
            LIMIT=${LIMIT:-200} HAVING='rise>0' SELECT lsd
            exit 0;
        fi
        LIMIT=${LIMIT:-400}
        field=${2:-rise}
        DT=`DT="${END} 15:05:00" SELECT dorat | sed -n "${1}p"`
        fn_echo_warn ${DT} # exit
        DT=(${DT})
        TEMPDAY="(SELECT * FROM dorat WHERE date='${DT[0]}' && time='${DT[1]}')"
        HAVING="rise>0"
        ;;
    u|usage)
        echo "
        SELECT lsd <param>:
        usage   show usage
        list    list 5min table
        {0-9}*  index from 5min table
        top     10%
        floor   -10%
        ''      top default
        "
        exit
        ;;
    *)
        chao=${chao}.lsd
        field=${1:-rise}
        ;;
    esac

    function fn_sql()
    {
        sqls="
        SELECT ${CID}$columns, volume,amount, 
                $OPRI as opri, 
                ${sql_avrg}
                $RISE as rise, 
                $TURNOV as tov, ${nmcYi}, c.name
                FROM ${TEMPDAY} as d, cap as c ${WHERE} d.code = c.code and d.date = '${END}' 
                HAVING ${HAVING:-1} ${COND} ORDER BY ${field} ${ASC:-desc} limit ${LIMIT:-36}
        " 
        # echo "${sqls}"; exit
    }
    fn_sql $@ 
    mysql ${OPT:--t} kts <<<"${sqls}"
    fn_chao
}

function fn_ace()
{
    dates=(`fn_get_date ${1:-1} ${2:-10}`)

    function fn_sql()
    {
        sqls="SELECT ${2} FROM day as d,cap as c where d.code=c.code && d.date = '$1' and ${RISE}>9.93 ${@:3}"
        # echo "${sqls}"; exit 1
        mysql -N kts <<<"${sqls}"
    }

    local i=
    printf "%-12s%6s\t%6s\t%6s\t%6s\t%6s\n" date rows nmc20 nmc75 amt20 amt75
    for i in ${dates[@]}; do
        rows=`fn_sql $i "count(d.code)"`
        pct20=`bc <<< "${rows}*20/100"`
        pct75=`bc <<< "${rows}*75/100"`
        nmc20=`fn_sql $i nmc ORDER    by nmc    ASC LIMIT ${pct20},1`
        nmc75=`fn_sql $i nmc ORDER    by nmc    ASC LIMIT ${pct75},1`
        amt20=`fn_sql $i amount ORDER by amount ASC LIMIT ${pct20},1`
        amt75=`fn_sql $i amount ORDER by amount ASC LIMIT ${pct75},1`
         
        echo ${i} ${rows} ${nmc20} ${nmc75} ${amt20} ${amt75} |
        awk '{printf "%s  %6d\t%6.2f\t%6.2f\t%6.2f\t%6.2f\n", $1, $2, $3/10000,$4/10000,$5/10000,$6/10000 }'
    done

    return $?
}

function fn_get_comma_cloumns()
{
    # code,date,yesc,open,high,low,close,volume,amount
    # echo "SELECT * FROM ${1:-day} limit 1" | mysql kts  | head -1  | tr '\t' ','
    mysql kts -N<<<"DESCRIBE ${1:-day};" | awk '{printf "%s,", $1} END{printf "\n"}' | sed 's/,$//g'
}


function fn_dt_hyphen_2_normal()
{
    dt0=${1:0:10} 
    dt1=${1:11:8}
    echo "${dt0//_/-} ${dt1//_/:}"
    return $?
}

function fn_dt_normal_2_hyphen()
{
    echo "${1//-/_}_${2//:/_}"
    return $?
}

# fn_dt_hyphen_2_normal 2015_08_11_11_02_21
# fn_dt_normal_2_hyphen 2015-08-11 11:02:21

function fn_rat()
{
    # 0. Make sure U've done [up 4]?
    # 1. 以PREV为标，自动处理生成 tbl_mavol520s，只需上午更新一次 tbl_mavol520s
    # 2. 使用多表tbl_mavol520s tbl_day`联合查询`得到数据
    field=${1:-v1v5}

    DT=(${DT:-`mysql -N kts<<<"SELECT date,time FROM stamp_day ORDER by id DESC LIMIT 1"`})
    SCALE=`DT=${DT[@]} fn_get_ratio_close2open`
    # echo ${SCALE}; exit
    tov="round(100*(d.volume)/(c.nmc/c.close),2)"
    tov5="round(100*(ma.vol5)/(c.nmc/c.close),2)"
    tov20="round(100*(ma.vol20)/(c.nmc/c.close),2)"
    v1v5="round(5*d.volume*${SCALE}/(ma.vol5),2)"       
    # v5vT="round(4*ma.vol5/(ma.vol20),2)"
    # ${v5vT} as v5vT, 

    TBL=${TBL:-cap} END=${PREV} ./SCREENER wma

    fn_yist
    tbl_day="(SELECT * FROM dorat WHERE date='${DT[0]}' && time='${DT[1]}' ${inLIST})"

    function fn_build_sqls() {
    sqls="
    SELECT d.code,DATE_FORMAT(d.date,'%m-%d')as date,d.yesc,d.open,d.low,d.close,
        round(100*((d.open+low)/2-d.yesc)/d.yesc,2) as av_open, 
        round(100*(d.close-(d.open+low)/2)/((d.open+low)/2),2) as av_rise,
        round(100*(d.close-d.yesc)/d.yesc,2) as rise, 
        ${tov} as tov, 
        ${tov5} as tov5,
        ${tov20}as tov20,
        ${v1v5} as v1v5, 
        d.amount,c.nmc,c.name FROM tbl_mavol520s as ma, 
        ${tbl_day} as d, cap as c
        WHERE ma.code=d.code and ma.code=c.code 
        HAVING 1 ${COND} ORDER by ${field} ${ASC:-DESC} limit ${LIMIT:-36}" 
    }
    fn_build_sqls

    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls"

    fn_chao $chao.rat
}

function fn_tri()
{
    field=${1:-rising}
    STEP=${STEP:-7}
    # D3=(${DT:-`mysql -N kts<<<"SELECT date FROM day WHERE code=900001 and date<='${END}' ORDER by date DESC LIMIT 0,1"`})
    D2=${END}
    D1=${DT:-`mysql -N kts<<<"SELECT date FROM day WHERE code=900001 and date<'${END}' ORDER by date DESC LIMIT 0,1"`}
    D0=${DT:-`mysql -N kts<<<"SELECT date FROM day WHERE code=900001 and date<'${END}' ORDER by date DESC LIMIT ${STEP},1"`}
    
    t2="(SELECT * FROM day WHERE date='${D2}')"
    t1="(SELECT * FROM day WHERE date='${D1}')"
    t0="(SELECT * FROM day WHERE date='${D0}')"

    function fn_build_sqls() {
    product="TRUNCATE(100*(tbl.close-(tbl.amount/tbl.volume))/tbl.close,2)"
    sqls="
    SELECT * FROM (SELECT '${END}' as date, d.code, d.close, 
        $RISE as rise,
        round(100*(t1.close-t0.yesc)/t0.yesc, 2) as rising, ${STEP}+1 as D, 
        c.nmc, c.name FROM 
        ${t2} as d, 
        ${t1} as t1, 
        ${t0} as t0, cap as c
        WHERE d.code=t1.code && d.code=t0.code and d.code=c.code   -- 取样本数40 = 2000*20%，7天可翻倍
              ORDER by rising DESC limit 40 ) as t
        ${COND} ORDER by ${field:-rising} ${ASC:-DESC} limit ${LIMIT:-40}
    " 
    }
    fn_build_sqls
    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls"

    fn_chao
}

function fn_dif3()
{
    DT=`SELECT dorat|tail -1`
    DP=(`cat ${date_dif3} 2> /dev/null`)
    DT3=(${DT})

    [ "${DT3[0]}${DT3[1]}.${STEP:-1}" = "${DP[0]}${DP[1]}" ] && return 0

    DT="${DT}" ./up ma2015
    xt_ret $? "ma2015" || return $?

    dts="SELECT DISTINCT date,time FROM dorat"
    odr="ORDER by date DESC, time DESC"
    DT2=(${DT2:-`mysql -N kts<<<"${dts} WHERE date<='${DT3[0]}' && time<='${DT3[1]}' ${odr} LIMIT ${STEP:-1},1"`})
    DT1=(${DT1:-`mysql -N kts<<<"${dts} WHERE date<='${DT2[0]}' && time<='${DT2[1]}' ${odr} LIMIT ${STEP:-1},1"`})
    DT0=(${DT0:-`mysql -N kts<<<"${dts} WHERE date<='${DT3[0]}' && time<='09:47:00'  ${odr} LIMIT 1"`})

    echo "${DT3[@]}.${STEP:-1}" > ${date_dif3}
    TEMPORARY=TEMPORARY

    echo "
    DROP   TABLE IF EXISTS dif3;
    CREATE TABLE IF NOT EXISTS dif3 (
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        yesc        DECIMAL(6,2) NOT NULL DEFAULT 0,
        open        DECIMAL(6,2) NOT NULL DEFAULT 0,
        high        DECIMAL(6,2) NOT NULL DEFAULT 0,
        low         DECIMAL(6,2) NOT NULL DEFAULT 0,
        close       DECIMAL(6,2) NOT NULL DEFAULT 0,
        avrg        DECIMAL(6,2) NOT NULL DEFAULT 0,
        ma20        DECIMAL(6,2) NOT NULL DEFAULT 0,
        close2      DECIMAL(6,2) NOT NULL DEFAULT 0,
        close1      DECIMAL(6,2) NOT NULL DEFAULT 0,
        volume      DECIMAL(12,2) NOT NULL DEFAULT 0,
        amount      DECIMAL(12,2) NOT NULL DEFAULT 0,
        -- dif
        av_op       DECIMAL(6,2) NOT NULL DEFAULT 0,
        rise        DECIMAL(6,2) NOT NULL DEFAULT 0,
        dirtio      DECIMAL(6,2) NOT NULL DEFAULT 0,            -- 增量量比 dif-vol-ratio
        pie         DECIMAL(8,1) NOT NULL DEFAULT 0,            -- 增量额度，以万为单位
        INDEX(code)
    );
    DROP   $TEMPORARY TABLE IF EXISTS t2,t1,t0;
    CREATE $TEMPORARY TABLE IF NOT EXISTS t2 (
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        close       DECIMAL(6,2) NOT NULL,
        volume      DECIMAL(12,2) NOT NULL,
        amount      DECIMAL(12,2) NOT NULL,
        INDEX(code)
    );
    CREATE $TEMPORARY TABLE t1 LIKE t2;
    CREATE $TEMPORARY TABLE t0 LIKE t2;
    INSERT INTO dif3(code,yesc,open,high,low,close,volume,amount) SELECT code,yesc,open,high,low,
                               close,volume,amount FROM dorat WHERE date='${DT3[0]}' and time='${DT3[1]}' and code<698765;
    INSERT INTO t2 SELECT code,close,volume,amount FROM dorat WHERE date='${DT2[0]}' and time='${DT2[1]}';
    INSERT INTO t1 SELECT code,close,volume,amount FROM dorat WHERE date='${DT1[0]}' and time='${DT1[1]}';
    INSERT INTO t0 SELECT code,close,volume,amount FROM dorat WHERE date='${DT0[0]}' and time='${DT0[1]}';

    UPDATE dif3    SET avrg=(amount/volume), rise=100*(close-yesc)/yesc;
    UPDATE dif3,t0 SET av_op=100*((t0.amount/t0.volume)-dif3.yesc)/dif3.yesc WHERE dif3.code=t0.code;
    UPDATE dif3 INNER JOIN ma2015 on dif3.code=ma2015.code SET dif3.ma20=ma2015.ma2015;
    DELETE FROM dif3 WHERE ma20=0;

    UPDATE dif3 INNER JOIN t2 on dif3.code=t2.code 
                INNER JOIN t1 on t2.code=t1.code
                      SET close2=t2.close,
                          close1=t1.close,
                          dirtio=(dif3.volume-t2.volume)/(t2.volume-t1.volume),
                          pie=(dif3.amount-t2.amount);                              -- 以万为单位

    " | mysql kts
    xt_ret $? "fail: mysql" || return $?

    fn_echo_succ "    succ: up dif3!"
}

function fn_dirtio()
{
    # sec_dt=$(date +%s -d "${DT3[*]}")
    # sec_dp=$(date +%s -d "${DT2[*]}")
    # sec_open=$(expr $sec_dt - $sec_dp) 
    # [ "${sec_open}" -gt 5400 ] && let sec_open-=5400
    # SCALE=$(bc -l <<<"scale=2; 14400/${sec_open}")
    # echo ${SCALE}; exit
    case $1 in
    u|usage)
        echo "
        SELECT dirtio <param>
        usage: print usage
        list : print list of Date Time
        i25  : insert 2.5min data
        d25  : delete 2.5min data
        c1   : cond1: rise>0&& av_op>2&&av_op<5 && close2<close1 && close2<close && pie>1000 && av_ri<2 
                      0轴上    高开2~5%            低走             再上行          1000万      不涨太快
                      1. 一直运行在ma20(F1)上方
                      2. 先破ma20(F1)，在10:00前后突破之
        c2   : cond2: 
        c3   : cond3: 
        c4   : cond4: 
        1~48 : DT=list[1~48]
        "
        exit 0
        ;;
    l|list)
        SELECT dorat | cat -n; exit 0
        ;;
    [0-9]*)
        let min=3*${STEP:-1}
        [ ${1} -ge ${min} ] && [ "${1}" -le 48 ] || { 
            fn_echo_fail "fail: $1 -ge ${min} && $1 -le 48"; exit 1; 
        }
        DT=`SELECT dorat | sed -n "${1}p"` 
        # echo ${DT};exit
        ;;
    *)
        field=$1
        ;;
    esac
    field=${field:-$2}

    fn_dif3 ${@} # up DT, with param 'up', update dif3
    fn_yist

    SCALE=`fn_get_ratio_close2open`
    xt_ret $? "" || return $?

    v1x1="round(48*(d.volume-t2.volume)/d.volume*${SCALE},2)"       
    tov5="round(100*(ma.vol5)/(c.nmc/c.close),2)"
    tov1="round(100*(d.volume)/(c.nmc/c.close),2)"
    tovt="round((ma.vol20)/(c.nmc/c.close),1)"
    columns='ma20,avrg,close,close2,close1,av_op,rise'
    columns=d.${columns//,/,d.}

    function fn_build_sqls() {
    sqls="
    SELECT d.code, ${columns},
        ${tovt} as tovt,
        ${tov5} as tov5,
        ${tov1} as tov1,                                        -- 有tov，不必volume
        round(d.amount/10000,2) as pie_Yi,
        round(5*d.volume*$SCALE/(ma.vol5),2) as v1x5,           -- 普通量比
        dirtio,pie,
        round(c.nmc/10000, 1) as nmc_Yi, c.name 
        FROM dif3 as d, tbl_mavol520s as ma, cap as c           -- USE INDEX(code)
        WHERE d.code=ma.code && d.code=c.code                   -- av_ri = rise-av_op
        HAVING 1 ${COND} ${inLIST} 
        ORDER by ${field:-dirtio} ${ASC:-DESC} limit ${LIMIT:-32}" 
    }
    fn_build_sqls

    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls" | sed -e 's/    |$/|/g' -e 's/----+$/+/g'
    xt_ret $? "" || return $?

    fn_echo_warn "dif3@${DT3[@]}.${STEP:-1}"
    fn_chao ${chao}.dir
}

function fn_wma()
{
    # 1. Make sure U've done [SCREENER 2]?
    # 2. 使用单表tbl_mavol520s作差得到数据
    SCALE=`fn_get_ratio_close2open`
    columns=code,close,ma5,ma10,ma20
    columns=t.${columns//,/,t.}

    fn_yist
    fn_echo_warn "----- LIST:${#LIST[@]} COND@${END}: $COND -----"

    sqls="
    SELECT ${columns}, 
    ${SCALE}*vol       as mavol,
    round(vol5 / 5,2)  as mavol5, 
    round(vol20/ 20,2) as mavol20, 
    round(vol60/ 60,2) as mavol60, 
    round(4*${SCALE}*vol/(vol5-vol),2)  as v1v4,
    c.nmc, c.name
    FROM tbl_mavol520s as t, cap as c WHERE t.code=c.code 
    HAVING 1 ${COND} ${inLIST}
    ORDER by ${1:-v1v4} ${ASC:-DESC} LIMIT ${LIMIT:-24}
    " 
    echo "${sqls}" | tee /dev/stderr | mysql $mo -t kts

    fn_chao
}

function fn_updown()
{
    NUM=${NUM:-5}
    START=`fn_get_date ${NUM}`

    echo "
    From ${START} to ${END}...
    "

    cd $workdir
    > $mps_god
    head -n -5 $mps_org >> $mps_god

    echo "
    SET @START='$START';
    SET @END='$END';
    SET @NUM=${NUM};
    call sp_stat_change();
    SELECT * FROM tbl_stat_change ORDER by ${1:-date} ${ASC:-ASC};
    " | tee /dev/stderr >> $mps_god

    mysql $mo -t kts <<< "source $mps_god"

    return
}

function fn_6maishenjian()
{   # date1,date2,amount,
    columns="off,open,close,turnov"
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    DATE2=${DATE2:-${END}}
    [ -s "${exclude1}" ] && EXCLUDE="and code not in (`cat ${exclude1}`)"

    echo ----- COND: $COND -----
    function fn_get_tbl_6jian_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${DATE2}';
        "
        tbl_super_dive="
        SELECT t.code, DATE_FORMAT(date1,'%m-%d') as start, 
                       DATE_FORMAT(date2,'%m-%d') as end, ${columns}, c.nmc, chng, 
                       round(100*(t.low  - avrg)/avrg,2) as lchng, 
                       round(100*(t.close- avrg)/avrg,2) as wchng, 
                       round(100*(d.close- avrg)/avrg,2) as avrg_up, 
                       round(100*(d.close-(t.close+t.low)/2)/avrg,2) as trough_up, 
                       round((avrg-d.close)/(d.close-(t.close+t.low)/2),2) as odds, 
                       c.name 
            FROM ${tablex:-tbl_6mai} as t, cap as c, tempday as d
            WHERE t.code = c.code and t.code = d.code HAVING 1 ${COND} ${EXCLUDE}
            ORDER by ${1:-wchng} ${ASC:-asc} limit ${LIMIT:-36}     # COND='nmc<250000 and lchng<-9.7 and off<21'
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_6jian_dive $1
    mysql $mo -t kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao
}

function fn_dugu9jian()
{   # date1,date2,amount,open
    columns="off,turnov,avrg,close"
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    DATE2=`mysql -N kts <<< "SELECT date2 from ${tablex:-tbl_9jian} LIMIT 1"`
    [ -s "${exclude0}" ] && EXCLUDE="and code not in (`cat ${exclude0}`)"

    echo ----- COND: $COND -----
    function fn_get_tbl_9jian_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${DATE2}';
        "
        tbl_super_dive="
        SELECT t.code,  DATE_FORMAT(date1,'%m-%d') as start, 
                        DATE_FORMAT(date2,'%m-%d') as end, ${columns}, 
                        round(avrg*(1-${ORACLE:-10}/100),2) as oracle, 
                        c.nmc, chng, 
                        $RISE as rise, 
                        $PEAK as peak, 
                        $TROUGH as trough,
                        round(100*(t.low-avrg)/avrg,2) as lchng, 
                        round(100*(t.close-avrg)/avrg,2) as wchng, 
                        c.name 
           FROM ${tablex:-tbl_9jian} as t, cap as c, tempday as d
           WHERE t.code = c.code and t.code = d.code HAVING 1 ${COND} ${EXCLUDE}
           ORDER by ${1:-lchng} ${ASC:-asc} limit ${LIMIT:-36}      # COND='nmc<250000 and lchng<-9.7 and off<21' 
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_9jian_dive $1
    mysql ${mo:-'-t'} kts <<< "${tempday}${tbl_super_dive}"
    xt_ret ${PIPESTATUS[0]} "${FUNCNAME}" || return $?

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao
}

function fn_tao5()
{
   #columns=date_p,date_c,off_p,off_c,tnov_p,tnov_c,avrg_p,avrg_c,ratio
    columns=date_p,off_p,date_c,off_c,tnov_c,avrg_p,avrg_c,ratio,wchng
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    echo ----- COND: $COND -----
    function fn_get_tbl_tao5_dive()
    {
        tbl_super_dive="
        SELECT t.code, ${columns}, c.nmc,c.name 
           FROM ${tablex:-tbl_tao5} as t, cap as c 
           WHERE t.code = c.code HAVING 1 ${COND} limit ${LIMIT:-144}
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_tao5_dive $1
    mysql $mo -t kts <<< "${tbl_super_dive}" |\
        sed -e '1,3s/----+$/\+/g' -e '$s/----+$/\+/g' -e '2s/    |$/|/g'
    xt_ret ${PIPESTATUS[0]} "${FUNCNAME}" || return $?
}

function fn_name()
{
    fn_iscode ${code:=${1}}
    xt_ret $? "Usage: name code" || exit $?

    sqls="SELECT code, name,
            CONCAT((round(nmc/10000, 1)),'Yi') as nmcYi
             FROM cap WHERE code=${code}
    " 
    fn_echo_succ `mysql -N kts <<< "${sqls}"`

    xt_ret $? "" || return $?
}

function fn_rdiff()
{
   #columns=date_p,date_c,off_p,off_c,tnov_p,tnov_c,avrg_p,avrg_c,ratio,dbrat
    columns=date_p,date_c,off_p,off_c,tnov_c,close,avrg_p,avrg_c,ratio,cdiff,rdiff,wchng
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    echo ----- COND: $COND -----
    function fn_get_tbl_rdiff_dive()
    {
        tbl_super_dive="
        SELECT t.id,t.code,
        ${columns}, (wchng+2*rdiff+3*cdiff) as fire
           -- , c.nmc, c.name
           FROM ${tablex:-tbl_rdiff} as t, cap as c 
           WHERE t.code = c.code HAVING 1 ${COND} limit ${LIMIT:-144}
        "
        # echo "${tbl_super_dive}"
        fn_name `mysql -N kts <<<"SELECT code FROM ${tablex:-tbl_rdiff} LIMIT 1"`
    }

    fn_get_tbl_rdiff_dive $1
    mysql $mo -t kts <<< "${tbl_super_dive}" 
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_acc() { tablex=tbl_adiff fn_rdiff; }

function fn_pma()
{
    fn_iscode $1
    xt_ret $? "" || return $?

    END=${END:-`fn_maxdate`}
    NUM=${NUM:=5}

    # enable d2，则tov扩大10倍
    echo "
    SELECT close FROM day WHERE code=$1 and date='$END' INTO @iclose;
    SELECT d.code, '${END}' as date, sum(d.amount)/sum(d.volume) as ma${NUM}, @iclose,
        round(100 * (@iclose-sum(d.amount)/sum(d.volume))/@iclose, 2) as pcnt,
        round(100*sum(d.volume)/cap.shares, 2) as tov${NUM}
        FROM 
        (SELECT * FROM day WHERE code=$1 and date<='$END' ORDER by date DESC LIMIT ${NUM}) as d,
        cap WHERE d.code = cap.code ;
    " | mysql -t kts
    # SELECT sum((high-yesc)/yesc) FROM day WHERE code = 2 and date > '2014-11-03'; 
    return $?
}

function fn_fbi()
{
    # code,datetime_p,datetime_c,dbrat
    columns='off_p,off_c,tnov_c,close,avrg_p,avrg_c,ratio,cdiff,rdiff,wchng'

    fn_name `mysql -N kts <<<"SELECT code FROM ${tablex:-tbl_fdiff} LIMIT 1"`
    echo "
        SELECT id,
        -- datetime_p, 
        TRUNCATE(datetime_p%(1000000000000)/1000000,4) as dt_p,
        -- datetime_c, 
        TRUNCATE(datetime_c%(1000000000000)/1000000,4) as dt_c, ${columns}, 
        round(close+(avrg_c-close)*.618 - close*ratio*.00236, 2) *              -- close as space
           IF((avrg_c-close)*.618 - close*ratio*.00236<0, -1, 1) as oracle,     -- ratio as time
        (wchng+2*rdiff+3*cdiff) as fire
        FROM ${tablex:-tbl_fdiff} LIMIT ${LIMIT:-200}
    " | mysql -t kts
}


function fn_acf() { tablex=tbl_acfdiff fn_fbi; }

function fn_vol()
{
    fn_yist
    get_vol() 
    {
    echo "
    SELECT date, round(sum(volume)/10000, 2) as Volume, 
        round(sum(amount)/10000, 2) as Amount, round(sum(amount)/sum(volume), 2) as Trade
        FROM day WHERE date<='${END}' ${COND} ${inLIST}
        GROUP by date 
        ORDER by date DESC
        LIMIT ${LIMIT:-13};
    " | mysql -t kts
    }

    case $1 in
    0)
        COND='and code<100000'
        ;;
    3)
        COND='and code>=300000 and code<400000'
        ;;
    6)
        COND='and code>=600000 and code<700000'
        ;;
    03)
        COND='and code<400000'
        ;;
    *)
        COND='and code<700000'
        ;;
    esac

    get_vol
    return $?
}

function fn_dorat()
{
    case $1 in
    u|usage)
        echo "
        SELECT dorat <param>
        u   usage
        ld  date
        *   date time
        "
        ;;
    ld)
        odr="ORDER by date ASC"
        mysql -N kts<<< "SELECT DISTINCT date FROM dorat"
        ;;
    *)
        # echo DT is ${DT} > /dev/stderr
        [ -n "${DT}" ] && DT=(${DT}) && 
        COND0="WHERE DATE_FORMAT(CONCAT(date, ' ', time), '%Y-%m-%d %T')<='${DT[@]}'"
        odr="ORDER by date DESC, time DESC"
        # date<='${DT[0]}' and time<='${DT[1]}'"
        mysql -N kts<<< "SELECT date,time FROM ( SELECT DISTINCT date, time FROM dorat ) as t ${COND0} ${odr} LIMIT ${LIMIT:-50}"
        #fn_execute -l | grep dorat && exit
        ;;
    esac

    return $?
}


function fn_td_layout()
{
    fn_iscode ${code:=${1}}
    xt_ret $? "" || return $?
    dates=`mysql -N kts <<< "SELECT DISTINCT round(datetime/1000000,0) from fenbi WHERE code=${code}"`

    mysql kts <<< "TRUNCATE tmpfb";

    local i=
    for i in ${dates}; do
        # SELECT date FROM day WHERE code=${code} and date=
        echo "
        INSERT INTO tmpfb(code,datetime,trade,volume,amount)
        SELECT code,datetime%1000000,trade,volume,amount FROM fenbi 
            WHERE code=${code} and round(datetime/1000000, 0)=${i} 
            ORDER by trade ${ASC:-DESC} LIMIT 1; 
        " | mysql kts -t
        xt_ret $? "" || return $?
    done 

    mysql -t kts <<< "SELECT * FROM tmpfb ORDER by datetime DESC";

    return $?
}

function fn_dif120()
{
    if [ -z "${YIST}" ]; then
        fn_iscode $1 
        xt_ret $? "" || { echo "Usage: 120 code... {END}" && exit; }
        YIST=${file_ma120}
        xargs -n1 <<<"${*}" | sed 's/^0*//g' | xargs printf "%06d\n" > ${YIST}
    fi

    fn_yist 
    fn_echo_warn "----- LIST:${#LIST[@]} COND@${END}: $COND -----"

    tbl_day="(SELECT * FROM day WHERE date='${END}' ${inLIST})"

    sqls="
    SELECT d.code,d.date,d.close,ma120,100*(d.close-ma120)/ma120 as rise, c.name 
        ${sqls} FROM ${tbl_day} as d, 
        tbl_ma240 as t, 
        cap as c WHERE t.code=d.code and t.code=c.code 
        HAVING 1 ${inLIST} ORDER by rise ASC
    "
    mysql -t kts<<<"${sqls}"
    xt_ret $? "${FUNCNAME}" || return $?

    return 0
}

function fn_ma240_usage()
{
    echo "
    1 x_mid x_one 双线出击
    2 牛市step2 ma240收敛 & cross & 放量上行
    3 联合查询1 x_sho && NUM_RATIO=2 SCREENER 0
    4 联合查询2 强者恒强 平台突破 开山股份
    "
}

function fn_ma240()
{
    # 0. Make sure U've done [SCREENER ma240]?
    columns=code,date,close,ma5                     # ,ma5,ma10,ma20,ma60 # ,ma120,ma240
    columns=ma.${columns//,/,ma.}


    function fn_build_sqls() 
    {
    sqls="SELECT date FROM day WHERE code=900001 and date<='${END}' ORDER by date DESC LIMIT 4,1"
    ago5=`mysql -N kts<<<"${sqls}" 2>/dev/null`
    field=${1:-x_sho}
    sqls="
    SELECT ${columns},
        round(100*(ma.close-ma5  )/ma5  ,1)as pma5,
        round(100*(ma.close-ma20 )/ma20 ,1)as pma20,
        round(100*(ma.close-ma40 )/ma40 ,1)as pma40,
        round(100*(ma.close-ma60 )/ma60 ,1)as pma60,
        round(100*(ma.close-ma120)/ma120,1)as pma120,
        ${x_sho} as x_sho,          -- 5 10 20
        ${x_mid} as x_mid,          -- 20 60 120
        ${x_long} as x_long,        -- 60 120 240
        ${x_sho}+
        ${x_mid}+
        ${x_long} as x_6line,       -- 一阳穿3线
        c.nmc,c.name FROM tbl_ma240 as ma, cap as c
        ${WHERE} ma.code=c.code and ma5!=0 and ma.date>'${ago5}' 
        HAVING 1 and code<600000 && nmc<1500000 && pma5>-2 ${COND}
        ORDER by ${field} ${ASC:-ASC} limit ${LIMIT:-24}" 
    }

    # .0001 使得新股 x_sho x_long 都为 2.000
    # mid 5day 5week 5month
    x_sho="round(100*(abs((ma5-ma10)/(ma10))+abs((ma20-ma10)/(ma10))  ), 1)"
    x_mid="round(100*(abs((ma10-ma20)/(ma20))+abs((ma40-ma20)/(ma20)) ), 1)"
    x_long="round(100*(abs((ma40-ma60)/(ma60))+abs((ma120-ma60)/(ma60))), 1)"

    ABBR=ma fn_yist
    fn_build_sqls $1
    fn_echo_warn "----- LIST:${#LIST[@]} COND@${END}: $COND -----"
    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls"

    fn_echo_warn "Suggest: COND=''"

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return
    fn_chao ${file_ma240}
}


function fn_hilo()
{
    columns='code,date1,date2,off,turnov,tovpd,rat1,rat2,high,low,close,chng'
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    [ -s "${exclude2}" ] && EXCLUDE="and code not in (`cat ${exclude2}`)"

    function fn_yi_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${CURR}';
        "
        # delete停牌个股
        tbl_super_dive="
        -- rat1:最低日lo量比 rat2:lo+(lo+1)日量比
        SELECT ${columns}, 
        round(100*(d.close-t.high)/t.high, 2) as dive, 
        round(100*(d.close-t.close)/t.close, 2) as rebound, c.nmc, c.name   -- t.close=(open+close)/2
        FROM tbl_hilo as t, tempday as d, cap as c
        WHERE t.code = d.code and t.code=c.code
        HAVING 1 ${COND} ${EXCLUDE}
        ORDER by ${1:-chng} ${ASC:-ASC} LIMIT ${LIMIT:-36}
        "
        echo "${tbl_super_dive}"
    }

    fn_yi_dive $1
    mysql $mo -t kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao
}

function fn_inout()
{
    inout_codes="
    $DROP        d_temp;
    CREATE TABLE d_temp LIKE day;
    INSERT INTO  d_temp ${d_temp};
    $DROP        d_curr;
    CREATE TABLE d_curr LIKE day;
    INSERT INTO  d_curr ${d_curr};

    $DROP        prev_codes;
    CREATE TABLE prev_codes LIKE codes;
    INSERT INTO  prev_codes(code) 
        SELECT code FROM (
            SELECT t.code, round(100*(d.close-t.low)/t.low, 2) as incr
            FROM ${hilo_prev} as t, d_curr as d
            WHERE t.code=d.code ORDER by incr DESC LIMIT ${LIMIT:-40}    -- PREV排名前40
        ) as t;

    $DROP        curr_codes;
    CREATE TABLE curr_codes LIKE codes;
    INSERT INTO  curr_codes(code) 
        SELECT code FROM (
            SELECT t.code, round(100*(d.close-t.low)/t.low, 2) as incr
            FROM ${hilo_curr} as t, d_temp as d
            WHERE t.code=d.code ORDER by incr DESC LIMIT ${LIMIT:-40}    -- CURR排名前40
        ) as t;

    $DROP        sit_codes;
    CREATE TABLE sit_codes LIKE codes;
    INSERT INTO  sit_codes(code) SELECT p.code FROM prev_codes as p, curr_codes as c  WHERE p.code=c.code;

    $DROP        out_codes;
    CREATE TABLE out_codes LIKE codes;
    INSERT INTO  out_codes(code) SELECT code FROM prev_codes WHERE code NOT IN(SELECT code FROM curr_codes);

    $DROP         in_codes;
    CREATE TABLE  in_codes LIKE codes;
    INSERT INTO   in_codes(code) SELECT code FROM curr_codes WHERE code NOT IN(SELECT code FROM prev_codes);
    "

    function fn_in_or_out()
    {
      echo "
      SELECT * FROM (
        SELECT ${columns}, 
        round(100*(d.close-t.low)/t.low, 2)  as incr,
        round(100*(max(t.high,d.close)-d.close)/d.close, 2) as decn,
        ${RISE} as rise,
        round((d.volume/t.mavol5), 2) as tov, t.scale,
        round((d.amount/10000), 1) as eYi,
        round((c.shares*d.close/10000), 1) as nmcYi, c.name
        FROM ${hilo_curr} as t, d_temp as d, cap as c
        WHERE t.code=d.code and t.code=c.code
        HAVING 1 ${EXCLUDE}
        ORDER by incr ${ASC:-DESC} ) as newton
        WHERE code IN (SELECT code FROM ${1}_codes)                 -- 新进 = 今天前40-(2天的交集)
      HAVING ${HAVING:-1} ORDER by ${field:-incr} ${ASC:-DESC}      -- 淘汰 = 昨天前40-(2天的交集)
      "
    }
    function fn_yi_descend()
    {
      tempday="${inout_codes}"
      tbl_super_dive=`fn_in_or_out $1`
      fn_echo_blue "${tbl_super_dive}"
    }
    
    return $?
}

function fn_lohi()
{
    columns='lohi'
    columns="t.code,DATE_FORMAT(t.date1,'%m-%d')as date1,DATE_FORMAT(t.date2,'%m-%d')as date2,t.${columns//,/,t.}"

    iNUM=${NUM:-8}                          # PREV=`mysql -N kts <<< "SELECT max(end) from mat_lohi"`
    TAM=${TAM:-${END}}                      # 开市后才能指定MAT
    TAM=${TAM//END/${END}}                  # TAM代表mat_lohi中最高日期，亦TEMPDAY的日期
    TAM=${TAM//PREV/${PREV}}                # 
    iTEMP=${TAM}
    iCURR=`END=${TAM} fn_get_prev`
    iPREV=`END=${iCURR} fn_get_prev`        # prev+temp = 灵活推演

    # echo END: ${END} TAM:${TAM} temp:${iTEMP} curr: ${iCURR} prev:${iPREV}; exit

    hilo_temp="( SELECT * FROM mat_lohi WHERE end='${iTEMP}' and num=${iNUM} )"
    hilo_curr="( SELECT * FROM mat_lohi WHERE end='${iCURR}' and num=${iNUM} )"
    hilo_prev="( SELECT * FROM mat_lohi WHERE end='${iPREV}' and num=${iNUM} )"
       d_temp="SELECT * from day where date='${iTEMP}'"     # 最新day数据，可以是开市数据
       d_curr="SELECT * from day where date='${iCURR}'"     # 次新day数据，必是必市后数据

    field=$1
    case $1 in
    in|out|sit)
        field=$2; fn_inout
        ;;
    l|list)
        LIMIT=50 DT="${iTEMP} 15:05:00" SELECT dorat | cat -n; exit 0
        ;;
    s|shrinkage)
        off=${2:-5}
        sta=`fn_get_date ${off}`
        # echo ${sta}; exit
        count=`mysql -N kts<<<"SELECT count(*) FROM mat_lohi WHERE end='${END}'"`
        if [ "${count}" -eq 0 ]; then
            echo "Warning: mat_lohi is not lateast! to update with [SCREENER lohi 0~n]"; exit
        fi

        echo "
        $DROP tempday; CREATE TABLE tempday(
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        rise        DECIMAL(6,1) NOT NULL DEFAULT 0,
        INDEX(code)
        );
        INSERT INTO tempday
        SELECT d1.code, round(100*(d2.close-d1.close)/d1.close, 1) as rise FROM
        (SELECT code,close FROM day WHERE date='${sta}') as d1,
        (SELECT code,close FROM day WHERE date='${END}') as d2 WHERE d1.code=d2.code
        " | mysql kts

        puppy="
            end,m.code, count(scale) as off,sum(scale) as shirnk, rise,
            round(100*sum(volume)/c.shares,1) as tov, round(c.nmc/10000, 1) as nmc, c.name"
        sqls="
            SELECT ${puppy} FROM mat_lohi as m, cap as c, tempday as d
            WHERE m.code=c.code && m.code=d.code && end>='${sta}' and end<='${END}' 
            GROUP by code HAVING off>=${off} && shirnk<=${off} && tov<${off}*15 ${COND}
            ORDER by shirnk ASC LIMIT ${LIMIT:-36}
        " 
        # echo "$sqls"; exit
        mysql -t kts <<< "${sqls}"
        fn_chao ${chao}.shrinkage
        exit 0
        ;;
    [0-9]*|f|'')
        if [ -z "${1}" ] || [ "${1}" = f ]; then
            field=$2
            TEMPDAY="tempday"
            iTEMP=`END=${iTEMP} fn_get_next`    # 仅开市时间使用，取最新。闭市时间，请使用 SELECT lohi 1
            iTEMP=${iTEMP:-${TAM}}
            tempday="
            $DROP tempday; CREATE TABLE tempday LIKE day;
            INSERT INTO tempday SELECT * from day where date='${iTEMP}';
            "
        else
            field=$2
            DT=`DT="${iTEMP} 15:05:00" SELECT dorat | sed -n "${1}p"`
            # echo ${DT}; exit
            DT=(${DT})
            TEMPDAY="(SELECT * FROM dorat WHERE date='${DT[0]}' && time='${DT[1]}')"
            echo "${TEMPDAY}" > ${sql_tempday}
        fi

        ABBR=t fn_yist
        function fn_yi_descend()
        {
          tbl_super_dive="
          SELECT * FROM (
            SELECT ${CID}${columns}, 
            round(100*(d.close-t.low)/t.low, 2)  as incr,
            round(100*(GREATEST(t.high,d.close)-d.close)/GREATEST(t.high,d.close), 2) as decn,
            round(t.amount/t.volume, 2) as yavri, d.close,
            round(100*(d.high-d.yesc)/d.yesc, 2) as hiri,
            round(100*(d.amount/d.volume-d.yesc)/d.yesc, 1) as avri,
            ${RISE} as rise,
            round((d.volume/t.volume), 2) as prop,
            round((d.volume/t.mavol5), 2) as prop5, t.scale,
            round((d.amount/10000), 1) as eYi, 
            round((t.amount/10000), 1) as zYi,
            round((c.shares*d.close/10000), 1) as nmcYi, c.name
            FROM ${hilo_curr} as t, 
            ${TEMPDAY} as d, cap as c
            ${WHERE} t.code = d.code and t.code=c.code HAVING 1 ${COND} ${EXCLUDE}
            ORDER by incr ${ASC:-DESC} ) as t
          HAVING ${HAVING:-1} ORDER by ${field:-prop} ${ASC:-ASC} LIMIT ${LIMIT:-36}
          "
          echo "${tempday}${tbl_super_dive}"
        }
        ;;
    u|*)
        echo "
        SELECT lohi <param>
            in : exist dates
            out: dates list with num
            0-9: tempday from dorat
            '' : 仅开市时间使用，取最新。闭市时间，请使用 SELECT lohi 1
            f  : ORDER by field
            *  : usage
        常用COND
            --------------------------大盘不稳皆是浮动-------------------------
            incr: 总涨幅，大于22%抛压增大
            rise: 当前价格，决定赔率，大于7%控制仓位
            avri: 抬高估值意愿，大于5%可操作性降低(大盘振荡形成抛压，次日难卖高价)
            tov : 收集筹码能力，.5比较合适，过高(大于.7)可能会是：对敲出货、拉高出货。大盘高位放量，次日会低开
                  时早缩量板，提高确定性，成本往前推1日，寄希望于次日再涨停
                  跟风板，成本低，次日多直接出货
            eYi : 展现资金实力，2Yi以下为宜
            nmc : 盘小方便游资控盘，2Yi/5%换手，在50亿左右为宜
        "
        fn_echo_succ "
            选择强势的概念及板块很重要
            scale小于1可以确保资金安全.查看10涨幅不可太高(吃亏在.黄海机械)"
        fn_echo_fail "
            弱势行情追高尽量下午追(13:45后) -- 创业板B 中小板B (后知后觉比较好追)
            09:35~50之间，应该有2~3波..白黄缠绕..，直接拉升者，拒绝新鲜血液，多是耍流氓"
        echo "
        COND='incr<22'
        LIMIT=600 HAVING='rise<7&&avri>2 && rise>avri-.6 && tov>.2&&tov<.7 && nmcYi<80&&(scale<1.5||zYi<2)' TAM=END SELECT lohi 1
            tov : 资金必须放量才可安全出逃，prev / prev2缩量，是very very vrey重要的指标
                  早盘，大盘低开时，选择昨天缩量涨停，开盘rise<3
                  尾盘，大盘下跌时，选择当天缩量小涨股
        LIMIT=400 ASC=asc COND='tov<.8 && eYi>.8 && nmcYi<80' HAVING='rise>-1 && rise<2 ' TAM=END SELECT lohi 2 "
        fn_echo_warn "
            超跌反弹在痛点变甜点(2015-09-16从超跌板块中找)：
            强势股(黄海机械)，在反弹日表现往往不佳<提前支取黄线>
            地板弹起(光韵达)，反弹前日表现好，可10%收益，护盘积极，但反弹日表现往往不佳
            弱势股<航天长峰>，以跌停处理，身上背负套牢吸血之类，难以表现
            均衡股<天喻信息>，不能跌停失去流动性，十字星，尾部发力与黄线重合最佳(有主力护航)
        "
        exit
        ;;
    esac

    [ -s "${exclude2}" ] && EXCLUDE="and code not in (`cat ${exclude2}`)"

    fn_yi_descend $1 > /dev/stderr
    mysql ${OPT:--t} kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?
    fn_echo_warn "TAM=$TAM time=${DT[1]} index=$1"

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao ${chao}.lohi
}

function fn_ban()
{
    iDATE=`END=${TAM:-${END}} fn_get_prev`
    tempday="(SELECT * FROM day WHERE date='${iDATE}')"
    sql="SELECT round(d.close*shares/10000,1) as col FROM cap as c, ${tempday} as d WHERE c.code=d.code ORDER by col ASC LIMIT 770,1"
    smlYi=`mysql -N kts <<<"${sql}"`
    sql="SELECT round(d.close*shares/10000,1) as col FROM cap as c, ${tempday} as d WHERE c.code=d.code ORDER by col ASC LIMIT 1540,1"
    midYi=`mysql -N kts <<<"${sql}"`
    sql="SELECT round(d.volume/shares, 4)     as col FROM cap as c, ${tempday} as d WHERE c.code=d.code ORDER by col ASC LIMIT 1160,1"
    tov=`mysql -N kts <<<"${sql}"`

    fn_echo_succ ${tov} ${smlYi} ${midYi}

    factor=${ZIZE:-0.25}    # tov(30min) ~= 25%，3个10分钟分别是：<12:8:5> * 优秀因子1.5 0940 0945 0950=>  0.18 0.25 0.30

    fn_run()
    {
    # 有时小票连续3板也是好票 <300314	戴维医疗>，特别是10点前封板票
    incr="incr<${incr:-22}"
    COND="${incr}" LIMIT=1400 HAVING="avri>2&&rise>avri-.6 && tov>${factor}&&tov<.8 && ${xCOND}" TAM=END SELECT lohi ${1:-1}
    }

    fn_echo_blue "small"
    incr=30 xCOND="eYi>nmcYi*${factor}*${tov} && nmcYi<=${smlYi}"
    fn_run $1
    xt_ret $? "" || return $?

    fn_echo_succ "middle"
    xCOND="eYi>nmcYi*${factor}*${tov} && nmcYi>${smlYi}&&nmcYi<${midYi}"
    fn_run $1 2>/dev/null
    xt_ret $? "" || return $?

    fn_echo_warn "large"
    xCOND="eYi>nmcYi*${factor}*${tov} && nmcYi>=${midYi}"
    fn_run $1 2>/dev/null
    xt_ret $? "" || return $?

    # 底部、中部，拒绝顶部
    fn_echo_warn "scale<1.2"
    xCOND="eYi>nmcYi*${factor}*${tov}"
    COND='incr>=22 && scale<1.2' LIMIT=1400 HAVING="avri>2&&rise>avri-.6 && tov>${factor} and ${xCOND}" TAM=END SELECT lohi ${1:-1} 2>/dev/null
    xt_ret $? "" || return $?
}

function fn_sban()
{
    case $1 in
    a|avri)
        fn_get_ratio_close2open idxopen
        # echo ${idxopen} ${tov_pcnt}; exit
        for (( i=${START:=${idxopen}}; i>${STOP:-0}; i-=1 )); do
            [ "${i}" -ne "${START}" ] && YIST=${chao}.temp 
            iCOND="hiri>5 && rise>avri-.6 && avri>0 && avri<9.93 && tov<${tov_pcnt} && nmcYi<80"
            LIMIT=3000 YIST=${YIST} COND=${iCOND} CHAO=1 SELECT lohi ${i}
            cp ${chao}.lohi ${chao}.temp
        done
        ;;
    40)
        ZIZE=0.18 fn_ban; exit
        ;;
    47)
        ZIZE=0.25 fn_ban; exit
        ;;
    END|PREV)
        TAM=${TAM:-$1} SELECT lohi ${2:-1} ${3}; exit
        ;;
    .99)
        TAM=${TAM:-END} COND='tov<=1 && rise>9.93' SELECT lohi ${2:-1} ${3}; exit
        ;;
    g1)
        TAM=${TAM:-END} COND='tov>1 && rise>9.93' SELECT lohi ${2:-1} ${3}; exit
        ;;
    c|code)
        TAM=${TAM:-END} COND="code=$2" SELECT lohi ${3:-1}; exit
        ;;
    u|*)
        echo "
        SELECT sban <param>
            a   : close>avri-1
            40  : 0940 tov .18
            47  : 0947 tov .25
            .99 : tov<=1 && rise>9.93
            g1  : tov>1 && rise>9.93
            TAM : SET TAM={END|PREV}
            c   : c code [i]
            *   : usage
        "
        ;;
    esac
}

function fn_xrd()
{
    mysql kts <<<"SELECT * from xRD WHERE date${OP:->}'${END}' order by ${1:-date} ASC"
    return $?
}

function fn_cap()
{
    if [ -n "${1}" ]; then
        COND="code=${1}"
    elif [ -f "${YIST}" ]; then
        fn_yist
    else
        fn_execute -l && exit
    fi

    mysql -t kts <<<"SELECT * FROM cap WHERE ${COND:-1} ${inLIST} ORDER by nmc DESC;"
    return $?
}

function fn_lhb()
{
    if [ -n "${CAUSE}" ]; then
        CAUSE=`
                sed -e "s/\<c3\>/cause='3up20'/"    \
                    -e "s/\<c7\>/cause='up7'/"      \
                    -e "s/\<c8\>/chng>=9.832/"      \
                    -e "s/\<cs\>/cause='s3up12'/"   \
                    -e "s/\<ct\>/cause='tov20'/"    \
                    -e "s/b>/bloo>/"                \
                    -e "s/p>/${LOGIC}bsp>/"         \
                    -e 's/ /||/g' <<< "${CAUSE}"`
        # echo ${CAUSE}; exit
        CAUSE="and (${CAUSE})"
    fi

    sql_maxdate="SELECT max(date) FROM lhb"
    max_dt=`mysql -N kts <<< "${sql_maxdate}"`
    case $1 in
    r|cause)
        mysql -t kts <<<"SELECT DISTINCT cause FROM lhb"
        ;;
    d|dates)
        fn_list_date $2
        ;;
    x|del)
        date=`fn_get_date ${2:-1}`
        mysql kts <<< "DELETE FROM lhb WHERE date='${date}'"
        xt_ret $? "del fail" || return $?
        fn_echo_succ "del from lhb@${date}"
        ;;
    +10)
        sta=`fn_get_date ${2:-1}`
        off=`mysql -N kts <<< "SELECT count(*) from day WHERE code=900001 and date>='${sta}' && date<='${END}'"`
        tbl="SELECT * FROM day WHERE date>='${sta}' && date<='${END}' and (close-yesc)/yesc>.0993"
        sql="SELECT code,count(code) as num FROM (${tbl}) as t GROUP by code ORDER by num DESC LIMIT ${LIMIT:-30}"
        sql="SELECT * FROM ($sql) as t HAVING 1 ${COND}"
        mysql -t kts <<<"${sql}"
        fn_echo_succ "${sta} wday:`date --date=${sta} +'%w'` off:${off}"
        sqls=${sql} fn_chao ${chao}
        ;;
    g)
        sta=`fn_get_date ${2:-1}`
        off=`mysql -N kts <<< "SELECT count(*) from day WHERE code=900001 and date>='${sta}' && date<='${END}'"`
        wsql="WHERE date>='${sta}' && date<='${END}' && (chng>=3.82)"
        sql="SELECT code,count(code) as num FROM lhb ${wsql} GROUP by code ORDER by num DESC LIMIT ${LIMIT:-30}"
        sql="SELECT * FROM ($sql) as t HAVING 1 ${COND}"
        mysql -t kts <<<"${sql}"
        fn_echo_succ "${sta} wday:`date --date=${sta} +'%w'` off:${off}"
        sqls=${sql} fn_chao ${chao}
        ;;
    c|n|s|S)
        if [ $1 = S ]; then
            fdate='date,'
            field=$2
        elif [ $1 = c ]; then
            fn_iscode $2
            xt_ret $? "code:${2}" || return $?
            fn_xtempday $2
            xt_ret $? "xtempday error" || return $?
            COND="${COND} and code=${2}"
            fdate='date,'
            field=${3:-date}
            sql_relate="&& l.date=d.date"
            sql_xtempday=", xtempday as d"
            LIMIT=${LIMIT:-8}
        else # s
            field=$3
            date=`fn_get_date ${2:-1}`
            fn_echo_warn "lhb of ${date}"

            fn_xtempday ${date}
            xt_ret $? "xtempday error" || return $?

            sql_relate="&& l.code=d.code && l.date='$date'"
            sql_xtempday=", xtempday as d"

            # 自动处理apple
            RET=`mysql -N kts <<< "SELECT IF('${date}'<'${CURR}', 1, 0)"`
            if [ "${RET}" -eq 1 ]; then
                field=${field:-apple}
                xdate=`END=${date} fn_get_next`

                TBL=x fn_xtempday ${xdate}
                xt_ret $? "xtempday error" || return $?
                sql_relate="&& l.code=x.code ${sql_relate}"
                sql_xtempday="${sql_xtempday}, x"
                sql_next="
                ${APPLE} as apple,
                ROUND(100*(x.open-x.yesc)/x.yesc, 1) as Xopri,
                "
            fi
        fi

        fn_echo_warn "CAUSE: ${CAUSE}"

        columns="${fdate}code,cause"
        columns=l.${columns//,/,l.}
        sqls="
            SELECT ${columns}, round(chng,1) as chng,
            ${sql_next}
            ${sql_tov}
            round(l.amount/10000, 2) as eLHB,
            round(l.buy/10000, 2) as buy,
            round(l.sell/10000, 2) as sell,
            bloo,sloo,
            (bloo-sloo) as net,
            round(bloo/sloo, 2) as bsp,
            ${sql_avrg}
            round(l.buy/bloo/100, 2) as eYi, ${nmcYi0} as nmcYi,
            c.name FROM lhb as l,cap as c ${sql_xtempday}
            WHERE l.code=c.code ${sql_relate} 
            HAVING 1 ${CAUSE} ${COND} ORDER by ${field:-bsp} DESC LIMIT ${LIMIT:-48}
        "
        #echo "${sqls}"; exit
        mysql -t kts <<<"${sqls}"
        fn_chao
        ;;
    a|o)
        LOGIC=${1/a/'\&\&'}
        LOGIC=${LOGIC/o/'||'}
        LOGIC=${LOGIC} CAUSE="(c8&&(b>13.8p>1.62))||(chng<-4.9&&bsp>2)" COND="${aCOND}" SELECT lhb s ${2:-1} ${3:-avrg}
        #echo $CAUSE
        ;;
    *)
        fn_echo_succ "\tlhb max_date@${max_dt}"
        echo "
        SELECT lhb <param>
        +10 n   n日内涨停次数
        c code  指定代码
        r       上榜原因list
        d       日期list
        g n     n日内因+3.82%上榜次数统计
        s [i]   SELECT日期，i不指定时为1，代表今天
        x [i]   指定dele日期，i不指定时为1，代表今天
        a|AND   CAUSE='(8&&(b>15p>2))' COND=\$aCOND
        o|OR    CAUSE='(8||(b>15p>2))' COND=\$aCOND

        CAUSE='3 7 8 s t'
        c3   3up20
        c7   up7
        c8   +5%         ----- 3+7=8
        cs   s3up12
        ct   tov20
        b>p> bloo.bsp    tov!>20 && avrg>7 && opri>3 (tov太大即3日内到头 && 和大猪在一起 && 起飞的欲望)
        "
        ;;
    esac

    return $?
}

function fn_fmacd()
{
    mysql -t kts <<< "SELECT * FROM fmacd";
}

function fn_macd()
{
    fn_yist
    case $1 in
    c|clean)
        echo "DROP TABLE IF EXISTS mm55" | mysql kts; 
        fn_echo_succ "succ: clean macd!"; exit 0
        ;;
    [0-9]*)
        COND="and code=$1"
        field=$2
        ;;
    *)
        field=$1
        ;;
    esac

    fields='close,fa20,ma5,ma10,ma20,ma40,ma80'
    limo='(FM=15)*IF(close>=fa20, 1, -1)*((fa20>=ma5)+(fa20>=ma10)+(fa20>=ma20)+(fa20>=ma40)+(fa20>=ma80))'
    echo "
    SELECT code,FM,datetime%1000000 as time,
        ${fields},
        round(100*( abs(ma5-ma10)/ma10 + abs(ma20-ma10)/ma10 ), 2) as abs,
            cvgenc,
            ${limo} as limo, d1,m1,dif,macd FROM mm55
            HAVING 1 ${COND} ${inLIST}
            ORDER by ${field:-code},FM ${ASC:-ASC};
	" | mysql -t kts
    
    return $?
}

function fn_stat()
{
    fn_realtimetov0() {
        LIMIT=2 SELECT vol $1
        case $1 in
        0) CONd='and code<100000' ;;
        3) CONd='and code>=300000 and code<400000' ;;
        6) CONd='and code>=600000 and code<700000' ;;
        03)CONd='and code<400000' ;;
        a) CONd='and code<700000' ;;
        *) echo "SELECT stat {t|tt} 0|3|6|03|a" ;;
        esac
        echo "
            SELECT sum(amount) FROM ${TEMPDAY:-day} WHERE date='${END}' ${CONd} INTO @curr;
            SELECT ROUND(@curr/sum(amount), 3) as ratio FROM day WHERE date='${PREV}' ${CONd};
        " | mysql -N kts
    }
    case $1 in
    m|mid)
        # echo ${PREV}; exit
        fn_echo_warn "1160th换手率"
        LIMIT=1160,1 END=${PREV} SELECT lsd tov
        fn_echo_blue "1160th成交额"
        LIMIT=1160,1 END=${PREV} SELECT lsd amount
        fn_echo_succ "897(2345*.382),1789(2345*.618*1.235)流通市值"
        ASC=asc LIMIT=897,1  END=${PREV} SELECT lsd nmc
        ASC=asc LIMIT=1789,1 END=${PREV} SELECT lsd nmc
        ;;
    t|realtimetov|tt|tempdaytov)
        if [ "${1}" = tt ]; then
            TEMPDAY="`cat ${sql_tempday}` as d"
            END=`awk -F"'" '{print $2}' <<< "${TEMPDAY}"`
            time=`awk -F"'" '{print $4}' <<< "${TEMPDAY}"`
            PREV=`END=${END} fn_get_prev`
        fi
        list=${@:2}
        local i=
        for i in ${list:-0 3 6 a}; do
            fn_echo_warn "realtimetov of __${i//a/all}__ @${END} ${time}"
            fn_realtimetov0 ${i} || exit
        done
        ;;
    +10)
        ;;
    *)
        echo "
        SELECT stat <param>:
        m   middle of 1160
        t   realtimetov
        tt  tempdaytov
        "
        exit
        ;;
    esac
    return $?
}

function fn_blk()
{
    case $1 in
    l|layout)
        field=${2:-code}
        echo "
        SELECT hex(n.blk) as blk,count(m.code) as num,n.sym FROM blk_name as n, blk_memb as m
         WHERE n.blk=m.blk
         GROUP by blk ORDER by num DESC LIMIT ${LIMIT:-36};
        " | mysql -t kts
        ;;
    a|ace)
        off=${2:-1}
        xCOND="TRUNCATE(100*(close-yesc)/yesc, 2)>${DOOR:-9.93}"
        dates=(`fn_get_date 1 ${off}`)

        for (( i=${off}-1; i>=0; i-- )); do
            date=${dates[$i]}
            fn_xtempday ${date}
            fn_echo_succ "DOOR date: ${date}"
            echo "
            SELECT hex(n.blk) as xblk, count(m.code) as num, n.sym FROM blk_name as n, blk_memb as m, xtempday as d
            WHERE n.blk=m.blk and m.code=d.code 
             GROUP by xblk HAVING xblk not in('CE54', 'DAE8', 'DBD4', 'D886')
             ORDER by num DESC LIMIT ${LIMIT:-48};
            " | mysql -t kts
        done
        ;;
    b|blk)
        fn_xblk notNULL
        off=${2:-1}
        field=${3:-rise}
        sta=`fn_get_date ${off}`
        fn_sqls() {
        sqls="
        SELECT d.code,sum(${RISE}) as rise, ${nmcYi}, c.name FROM day as d, cap as c 
            ${WHERE} d.code = c.code and d.date>='${sta}' && d.date<='${END}'
            GROUP by code 
            HAVING ${HAVING:-1} ${COND} and rise>${DOOR:-'-100'}
            ORDER BY ${field} ${ASC:-desc} limit ${LIMIT:-36}
        " 
        }
        fn_sqls
        #echo "${sqls}" ; exit
        mysql -t kts <<< "${sqls}"
        LIMIT=3000 fn_sqls
        fn_chao
        ;;
    c|code)
        for code in ${@:2}; do
            fn_iscode ${code}
            xt_ret $? "" || return $?
            fn_name ${code}

            field=${3:-blk}
            echo "
             SELECT m.code, hex(n.blk) as blk, n.sym FROM blk_name as n, blk_memb as m
             WHERE n.blk=m.blk and code=${code}
             ORDER by ${field} DESC LIMIT ${LIMIT:-36};
            " | mysql -t kts
        done
        ;;
    f|find)
        fn_echo_blue "to find ${2}"
        LIMIT=300 fn_blk l | grep ${2}
        ;;
    u|uniq)
        BLK=${2}
        field=${4:-rise}

        ABBR=m fn_xblk
        EXCLUDE="&&(
        blk!=0xCE54 &&  -- 898 | 融资融券    
        blk!=0xDAE8 &&  -- 574 | 沪港通概念  
        blk!=0xDBD4 &&  -- 316 | 股东增持    
        blk!=0xDA4D &&  -- 305 | 央企国资改革
        blk!=0xD953 &&  -- 243 | 参股金融    
        blk!=0x40       -- 226 | 新股与次新股
        )"
        echo "
        SELECT m.code,count(m.code) as num, ${nmcYi}, c.name as num FROM blk_memb as m, cap as c
        ${WHERE} m.code=c.code ${EXCLUDE} 
        GROUP by code HAVING 1 ${COND}
        ORDER by num ASC LIMIT 100
        " | mysql -t kts
        ;;
    *)
        echo "
        SELECT blk <param>
        l               # layout
        a off           # 指定off日内的热门，看点在<可查看历史日spot>
        b [off]         # 列出指定BLKs关联code的涨幅
        c code          # 显示code关联的所有板块
        u blk           # blk中code关联的blk数目排名，越小，概念越纯正
        "
        ;;
    esac

    return $?
}

function fn_yysj()
{
    if [ "${1}" = 'd' ]; then
        sql_date="and date='$2'"
    else
        echo "
        SELECT DISTINCT date FROM yysj ORDER by date ASC;
        " | mysql -t kts
        fn_echo_warn "Usage: SELECT yysj d <date>"
        exit
    fi
    sqls="
    SELECT * FROM yysj 
    HAVING ${HAVING:-1} ${COND} ${sql_date} ORDER BY ${field:-code} ${ASC:-asc}
    "    
    mysql ${OPT:--t} kts <<<"${sqls}"
    fn_chao ${chao}.yysj
    return $?
}

function fn_main()
{
    # mysql CURRENT_DATE();
    CURR=`fn_maxdate`
    END=${END:-${CURR}}
    PREV=`fn_get_prev`
    END=${END//END/${CURR}}
    END=${END//PREV/${PREV}}

    cmdlist=(
    "dugu9jian          [sortfield]           # nine sword"
    "6maishenjian       [sortfield]           # #{DATE2} to specify diff-day"
    "get_comma_cloumns  [tbl_name:-day]       # 逗分列名"
    "list_date          num                   # num默认10"
    "wma                [sortfield:tov5]      # 均价+现成513.静态rat"
    "rat                [sortfield:-ratio]    # wma+day-->动态rat，实时速度快"
    "dorat                                    # 时间为表名list"
    "dirtio                                   # diff(dorat)"
    "ma240              [sortfield:-ratio]    # "
    "ma240_usage        {1~9}                 # 分析ma 5 13 34 55"
    "dif120             code...               # cost:(close-ma120) & sort by #{ASC:id}"
    "stat                                     # 大盘统计"
    # ----------------  ABOVE IS FIXED SEQUENCE --------------------
    "xrd                field                 # #{OP:->}"
    "ace                sta num               # 10日内所有+10% amount nmc 统计"
    "td_layout          code                  # 日内最高价时点分布.10:00am"
    "cap                code                  # 查询nmc&cap"
    "name               code                  # 名"
    "pma                code                  # NUM=5日平均"
    "fbi                                      # tbl_fbi"
    "acc                                      # tbl_adiff"
    "acf                                      # tbl_acfdiff"
    "tao5                                     # "
    "rdiff                                    # tbl_rdiff"
    "vol                {0|3|6|03}            # ^^3市成交^^"
    "ls                 {code|symbol}         # 日线数据 \$LIMIT"
    "lsd                [{top|floor}][field]  # --- END YIST LIMIT 涨幅排名"
    "updown                                   # 近期{NUM=5}涨跌家数统计"
    "hilo               field                 # field to sort by"
    "lohi               field                 # field to sort by"
    "ban                condi [time]          # 条件. 0945后使用"
    "sban               condi [time]          # super ban"
    "lhb                excption              # 龙虎榜"
    "macd               [clean]               # macd-alarm-sys"
    "fmacd                                    # 单个代码的macd"
    "tri                                      # 3连阳"
    "blk                                      # 板块信息"
    "yysj                                     # 预约时间"
    )

    # `ASC=任意值`时使用'DESC'，弃用
    # ASC=${ASC:+'DESC'}  # ASC=${ASC:-'ASC'}
    # ASC=${ASC:-'ASC'}
    fn_execute "$@"
}

fn_main "$@"

# http://www.cnblogs.com/zhenjing/archive/2011/07/15/process_mutex_race.html
# 获取最大ID的记录

