#! /bin/bash
. `dirname ${0}`/'dbank' || { echo "dbank err" && exit; }
. /etc/common.rc

function fn_ls()
{
    [ $# -eq "0" ] && fn_execute -l && exit

    if fn_isdigit $1; then
        code=$1
    else
        local shmout=$SHMPATH/shmout
        local index=1
        echo "google  $1 ..."
        google $1 | tee $shmout
        [ 0 -ne  "${PIPESTATUS[0]}" ] && echo google fail && exit 1

        lines=`cat $shmout | grep '^[603]' | wc -l`
        [ 0 -eq "$lines" ] && echo "Error: no symbol $1 found" && exit
        if [ 1 -eq "$lines" ]; then
            code=`awk '/^[603]/{print $1}' $shmout`
            echo $code
        else
            while :; do
                cat -n $shmout
                read -p "    Please input index[1]:" index
                [ "${index:=1}" -le $lines ] && let index-- && break
            done
            codes=(`awk '{print $1}' $shmout`)
            code=${codes[$index]}
        fi
    fi

    fields='d.code,d.date,d.yesc,d.open,d.high,d.low,d.close,d.volume,d.amount'
    echo "
    SELECT nmc/close FROM cap WHERE code=${code} LIMIT 1 INTO @shares0;
    SELECT * FROM (
        SELECT $fields, $PEAK as peak, $TROUGH as trough, 
        ${sql_avrg}
        $RISE as rise, $TURNOV0 as turnover
        FROM day as d
        WHERE d.code = ${code} and d.date <= '${END}'
        ORDER by date DESC
    ) as tbl HAVING 1 ${COND} ORDER by ${FIELD:-date} DESC LIMIT ${LIMIT:-48};
	" | mysql -t kts
}

function fn_lsd()
{
    # where d.code = c.code 非常重要，不重叠的FIELD不需要加‘tbl_name.’
    local columns="code,yesc,open,close"
          columns=${columns:-'*'}
          columns=d.${columns//,/,d.}
    local TEMPDAY='day'

    fn_yist
    case $1 in
    loop)
        local i
        for (( i=1; i<=${NUM:-10}; i+=1 )); do
            OPT=-N COND="rise>${DOOR:-9.93}" SELECT lsd ${i} | wc -l 2>&1
        done 2>&1 | grep -v HAVING
        exit
        ;;
    t|top)
        LIMIT=${LIMIT:-200}
        HAVING="rise>${DOOR:-9.93}"
        FIELD=${FIELD:-nmc}
        chao=${chao}.top
        ;;
    f|floor)
        LIMIT=${LIMIT:-200}
        HAVING="rise<-9.93"
        FIELD=${FIELD:-nmc}
        ;;
    l|list)
        SELECT lohi l; exit 0;
        ;;
    [0-9]*)
        if [ "${1}" = 0 ]; then
            fn_echo_warn "NR is 0"
            LIMIT=${LIMIT:-200} HAVING='rise>0' SELECT lsd; exit 0;
        fi
        LIMIT=${LIMIT:-400}
        FIELD=${FIELD:-rise}
        iTime=`fn_get_time ${1}`
        TEMPDAY="(SELECT * FROM dorat WHERE date='${END}' && time='${iTime}')"
        HAVING="${HAVING:-rise>0}"
        fn_echo_warn ${iTime}
        ;;
    u|h|usage)
        echo "
        SELECT lsd <param>:
        usage   show usage
        list    list 5min table
        {0-9}*  index from 5min table
        top     10%
        floor   -10%
        ''      top default
        "
        exit
        ;;
    *)
        FIELD=${FIELD:-rise}
        ;;
    esac

    function fn_sql()
    {
        [ "${FIELD}" = 'dive' ] && 
        sql_dive="round( (100*(d.amount/d.volume-d.close)/d.close), 1) as dive,"
        sqls="
        SELECT ${CID}$columns, volume,amount, 
                $OPRI as opri, 
                $HIRI as hiri, 
                ${sql_avrg}
                $RISE as rise, 
                ${sql_dive}
                $TURNOV as tov, ${nmcYi}, c.name
                FROM ${TEMPDAY} as d, cap as c ${WHERE} d.code = c.code and d.date = '${END}' 
                HAVING ${HAVING:-1} ${COND} ORDER BY ${FIELD} ${ASC:-desc} limit ${LIMIT:-36}
        "
        #echo "${sqls}"; exit
    }

    fn_echo_warn "----- LIST:${#LIST[@]} HAVING:${HAVING//SEL*=/} COND@${END}: $COND -----"
    fn_sql $@
    case ${PARTS:-4} in
    1) return                               ;; # 不输出chao，不输出mysql结果
    2) CHAO=1 fn_chao ${chao}.${chao2:-lsd} ;; # 只输出chao
    3) mysql ${OPT:--t} kts <<<"${sqls}"
       CHAO=1 fn_chao ${chao}.${chao2:-lsd} ;; # 既输出chao，又输出mysql
    *) mysql ${OPT:--t} kts <<<"${sqls}"
       fn_chao ${chao}.${chao2:-lsd}        ;; # 响应CHAO
    esac

}

function fn_ace()
{
    dates=(`fn_get_date ${1:-1} ${2:-10}`)

    function fn_sql()
    {
        sqls="SELECT ${2} FROM day as d,cap as c where d.code=c.code && d.date = '$1' and ${RISE}>9.93 ${@:3}"
        # echo "${sqls}"; exit 1
        mysql -N kts <<<"${sqls}"
    }

    local i=
    printf "%-12s%6s\t%6s\t%6s\t%6s\t%6s\n" date rows nmc20 nmc75 amt20 amt75
    for i in ${dates[@]}; do
        rows=`fn_sql $i "count(d.code)"`
        pct20=`bc <<< "${rows}*20/100"`
        pct75=`bc <<< "${rows}*75/100"`
        nmc20=`fn_sql $i nmc ORDER    by nmc    ASC LIMIT ${pct20},1`
        nmc75=`fn_sql $i nmc ORDER    by nmc    ASC LIMIT ${pct75},1`
        amt20=`fn_sql $i amount ORDER by amount ASC LIMIT ${pct20},1`
        amt75=`fn_sql $i amount ORDER by amount ASC LIMIT ${pct75},1`
         
        echo ${i} ${rows} ${nmc20} ${nmc75} ${amt20} ${amt75} |
        awk '{printf "%s  %6d\t%6.2f\t%6.2f\t%6.2f\t%6.2f\n", $1, $2, $3/10000,$4/10000,$5/10000,$6/10000 }'
    done

    return $?
}

function fn_comma()
{
    # code,date,yesc,open,high,low,close,volume,amount
    # echo "SELECT * FROM ${1:-day} limit 1" | mysql kts  | head -1  | tr '\t' ','
    mysql kts -N<<<"DESCRIBE ${1:-day};" | awk '{printf "%s,", $1} END{printf "\n"}' | sed 's/,$//g'
}


function fn_dt_hyphen_2_normal()
{
    dt0=${1:0:10} 
    dt1=${1:11:8}
    echo "${dt0//_/-} ${dt1//_/:}"
    return $?
}

function fn_dt_normal_2_hyphen()
{
    echo "${1//-/_}_${2//:/_}"
    return $?
}

# fn_dt_hyphen_2_normal 2015_08_11_11_02_21
# fn_dt_normal_2_hyphen 2015-08-11 11:02:21

function fn_rat()
{
    # 0. Make sure U've done [up 4]?
    # 1. 以PREV为标，自动处理生成 tbl_mavol520s，只需上午更新一次 tbl_mavol520s
    # 2. 使用多表tbl_mavol520s tbl_day`联合查询`得到数据
    HMS=${HMS:-`fn_get_time 1`}
    FIELD=${1:-v1v5}
    SCALE=`fn_get_ratio_close2open`
    # echo ${SCALE}; exit
    tov="round(100*(d.volume)/(c.nmc/c.close),2)"
    tov5="round(100*(ma.vol5)/(c.nmc/c.close),2)"
    tov20="round(100*(ma.vol20)/(c.nmc/c.close),2)"
    v1v5="round(5*d.volume*${SCALE}/(ma.vol5),2)"       
    # v5vT="round(4*ma.vol5/(ma.vol20),2)"
    # ${v5vT} as v5vT, 

    TBL=${TBL:-cap} END=${PREV} ./SCREENER wma

    fn_yist
    tbl_day="(SELECT * FROM dorat WHERE date='${END}' && time='${HMS}' ${inLIST})"

    function fn_build_sqls() {
    sqls="
    SELECT d.code,DATE_FORMAT(d.date,'%m-%d')as date,d.yesc,d.open,d.low,d.close,
        round(100*((d.open+low)/2-d.yesc)/d.yesc,2) as av_open, 
        round(100*(d.close-(d.open+low)/2)/((d.open+low)/2),2) as av_rise,
        round(100*(d.close-d.yesc)/d.yesc,2) as rise, 
        ${tov} as tov, 
        ${tov5} as tov5,
        ${tov20}as tov20,
        ${v1v5} as v1v5, 
        d.amount,c.nmc,c.name FROM tbl_mavol520s as ma, 
        ${tbl_day} as d, cap as c
        WHERE ma.code=d.code and ma.code=c.code 
        HAVING 1 ${COND} ORDER by ${FIELD} ${ASC:-DESC} limit ${LIMIT:-36}" 
    }
    fn_build_sqls

    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls"

    fn_chao $chao.rat
}

function fn_tri()
{
    FIELD=${1:-rising}
    STEP=${STEP:-7}

    D2=${END}
    D1=`fn_get_date 1` 
    D0=`fn_get_date ${STEP}` 
    t2="(SELECT * FROM day WHERE date='${D2}')"
    t1="(SELECT * FROM day WHERE date='${D1}')"
    t0="(SELECT * FROM day WHERE date='${D0}')"

    function fn_build_sqls() {
    product="TRUNCATE(100*(tbl.close-(tbl.amount/tbl.volume))/tbl.close,2)"
    sqls="
    SELECT * FROM (SELECT '${END}' as date, d.code, d.close, 
        $RISE as rise,
        round(100*(t1.close-t0.yesc)/t0.yesc, 2) as rising, ${STEP}+1 as D, 
        c.nmc, c.name FROM 
        ${t2} as d, 
        ${t1} as t1, 
        ${t0} as t0, cap as c
        WHERE d.code=t1.code && d.code=t0.code and d.code=c.code   -- 取样本数40 = 2000*20%，7天可翻倍
              ORDER by rising DESC limit 40 ) as t
        ${COND} ORDER by ${FIELD:-rising} ${ASC:-DESC} limit ${LIMIT:-40}
    " 
    }
    fn_build_sqls
    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls"

    fn_chao
}

function fn_dif3()
{
    HMS3=`fn_get_time 1`

    DT="${END} ${HMS3}" ./up ma2015
    xt_ret $? "ma2015" || return $?

    dts="SELECT DISTINCT date,time FROM dorat"
    odr="ORDER by date DESC, time DESC"
    HMS2=`HMS=${HMS3} fn_get_time 1`
    HMS1=`HMS=${HMS2} fn_get_time 1`
    HMS0=`HMS=${HMS0:-09:47:00} fn_get_time 1`

    TEMPORARY=TEMPORARY

    echo "
    DROP   TABLE IF EXISTS dif3;
    CREATE TABLE IF NOT EXISTS dif3 (
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        yesc        DECIMAL(6,2) NOT NULL DEFAULT 0,
        open        DECIMAL(6,2) NOT NULL DEFAULT 0,
        high        DECIMAL(6,2) NOT NULL DEFAULT 0,
        low         DECIMAL(6,2) NOT NULL DEFAULT 0,
        close       DECIMAL(6,2) NOT NULL DEFAULT 0,
        avrg        DECIMAL(6,2) NOT NULL DEFAULT 0,
        ma20        DECIMAL(6,2) NOT NULL DEFAULT 0,
        close2      DECIMAL(6,2) NOT NULL DEFAULT 0,
        close1      DECIMAL(6,2) NOT NULL DEFAULT 0,
        volume      DECIMAL(12,2) NOT NULL DEFAULT 0,
        amount      DECIMAL(12,2) NOT NULL DEFAULT 0,
        -- dif
        av_op       DECIMAL(6,2) NOT NULL DEFAULT 0,
        rise        DECIMAL(6,2) NOT NULL DEFAULT 0,
        dirtio      DECIMAL(6,2) NOT NULL DEFAULT 0,            -- 增量量比 dif-vol-ratio
        pie         DECIMAL(8,1) NOT NULL DEFAULT 0,            -- 增量额度，以万为单位
        INDEX(code)
    );
    DROP   $TEMPORARY TABLE IF EXISTS t2,t1,t0;
    CREATE $TEMPORARY TABLE IF NOT EXISTS t2 (
        code        INT(6) ZEROFILL NOT NULL DEFAULT 0,
        close       DECIMAL(6,2) NOT NULL,
        volume      DECIMAL(12,2) NOT NULL,
        amount      DECIMAL(12,2) NOT NULL,
        INDEX(code)
    );
    CREATE $TEMPORARY TABLE t1 LIKE t2;
    CREATE $TEMPORARY TABLE t0 LIKE t2;
    INSERT INTO dif3(code,yesc,open,high,low,close,volume,amount) SELECT code,yesc,open,high,low,
                               close,volume,amount FROM dorat WHERE date='${END}' and time='${HMS3}' and code<698765;
    INSERT INTO t2 SELECT code,close,volume,amount FROM dorat WHERE date='${END}' and time='${HMS2}';
    INSERT INTO t1 SELECT code,close,volume,amount FROM dorat WHERE date='${END}' and time='${HMS1}';
    INSERT INTO t0 SELECT code,close,volume,amount FROM dorat WHERE date='${END}' and time='${HMS0}';

    UPDATE dif3    SET avrg=(amount/volume), rise=100*(close-yesc)/yesc;
    UPDATE dif3,t0 SET av_op=100*((t0.amount/t0.volume)-dif3.yesc)/dif3.yesc WHERE dif3.code=t0.code;
    UPDATE dif3 INNER JOIN ma2015 on dif3.code=ma2015.code SET dif3.ma20=ma2015.ma2015;
    DELETE FROM dif3 WHERE ma20=0;

    UPDATE dif3 INNER JOIN t2 on dif3.code=t2.code 
                INNER JOIN t1 on t2.code=t1.code
                      SET close2=t2.close,
                          close1=t1.close,
                          dirtio=(dif3.volume-t2.volume)/(t2.volume-t1.volume),
                          pie=(dif3.amount-t2.amount);                              -- 以万为单位

    " | mysql kts
    xt_ret $? "fail: mysql" || return $?

    fn_echo_succ "    succ: up dif3!"
}

function fn_dirtio()
{
    case $1 in
    u|usage)
        echo "
        SELECT dirtio <param>
        usage: print usage
        list : print list of Date Time
        i25  : insert 2.5min data
        d25  : delete 2.5min data
        c1   : cond1: rise>0&& av_op>2&&av_op<5 && close2<close1 && close2<close && pie>1000 && av_ri<2 
                      0轴上    高开2~5%            低走             再上行          1000万      不涨太快
                      1. 一直运行在ma20(F1)上方
                      2. 先破ma20(F1)，在10:00前后突破之
        c2   : cond2: 
        c3   : cond3: 
        c4   : cond4: 
        1~80 : DateHMS list
        "
        exit 0
        ;;
    l|list)
        SELECT dorat | cat -n; exit 0
        ;;
    [0-9]*)
        let min=3*${STEP:-1}
        [ ${1} -ge ${min} ] && [ "${1}" -le 48 ] || { 
            fn_echo_fail "fail: $1 -ge ${min} && $1 -le 48"; exit 1; 
        }
        ;;
    *)
        FIELD=$1
        ;;
    esac
    FIELD=${FIELD:-$2}

    fn_dif3 ${@} # 'up ma2015', update dif3
    fn_yist

    SCALE=`fn_get_ratio_close2open`
    xt_ret $? "" || return $?

    v1x1="round(48*(d.volume-t2.volume)/d.volume*${SCALE},2)"       
    tov5="round(100*(ma.vol5)/(c.nmc/c.close),2)"
    tov1="round(100*(d.volume)/(c.nmc/c.close),2)"
    tovt="round((ma.vol20)/(c.nmc/c.close),1)"
    columns='ma20,avrg,close,close2,close1,av_op,rise'
    columns=d.${columns//,/,d.}

    function fn_build_sqls() {
    sqls="
    SELECT d.code, ${columns},
        ${tovt} as tovt,
        ${tov5} as tov5,
        ${tov1} as tov1,                                        -- 有tov，不必volume
        round(d.amount/10000,2) as pie_Yi,
        round(5*d.volume*$SCALE/(ma.vol5),2) as v1x5,           -- 普通量比
        dirtio,pie,
        round(c.nmc/10000, 1) as nmc_Yi, c.name 
        FROM dif3 as d, tbl_mavol520s as ma, cap as c           -- USE INDEX(code)
        WHERE d.code=ma.code && d.code=c.code                   -- av_ri = rise-av_op
        HAVING 1 ${COND} ${inLIST} 
        ORDER by ${FIELD:-dirtio} ${ASC:-DESC} limit ${LIMIT:-32}" 
    }
    fn_build_sqls

    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls" | sed -e 's/    |$/|/g' -e 's/----+$/+/g'
    xt_ret $? "" || return $?

    fn_chao ${chao}.dir
}

function fn_wma()
{
    # 1. Make sure U've done [SCREENER 2]?
    # 2. 使用单表tbl_mavol520s作差得到数据
    SCALE=`fn_get_ratio_close2open`
    columns=code,close,ma5,ma10,ma20
    columns=t.${columns//,/,t.}

    fn_yist
    fn_echo_warn "----- LIST:${#LIST[@]} COND@${END}: $COND -----"

    sqls="
    SELECT ${columns}, 
    ${SCALE}*vol       as mavol,
    round(vol5 / 5,2)  as mavol5, 
    round(vol20/ 20,2) as mavol20, 
    round(vol60/ 60,2) as mavol60, 
    round(4*${SCALE}*vol/(vol5-vol),2)  as v1v4,
    c.nmc, c.name
    FROM tbl_mavol520s as t, cap as c WHERE t.code=c.code 
    HAVING 1 ${COND} ${inLIST}
    ORDER by ${1:-v1v4} ${ASC:-DESC} LIMIT ${LIMIT:-24}
    " 
    echo "${sqls}" | tee /dev/stderr | mysql $mo -t kts

    fn_chao
}

function fn_updown()
{
    let iNUM=${NUM:=5}+1
    START=`fn_get_date ${iNUM}`

    echo "
    From ${START} to ${END}...
    "

    cd $workdir
    > $mps_god
    head -n -5 $mps_org >> $mps_god

    cols1=id,date,cnt,yiz10,inc10,hit10,
    cols2=inc,dec0,eq0,inc8p,inc5p,inc2p,inc0p,dec0d,dec2d,dec5d,dec8d

    echo "
    SET @START='$START';
    SET @END='$END';
    SET @NUM=${NUM};
    call sp_stat_change();
    SELECT ${cols1} ROUND(100*inc10/hit10,2) as succ, ${cols2}
        FROM tbl_stat_change ORDER by ${1:-date} ${ASC:-ASC};
    " | tee /dev/stderr >> $mps_god

    mysql $mo -t kts <<< "source $mps_god"

    return
}

function fn_6maishenjian()
{   # date1,date2,amount,
    columns="off,open,close,turnov"
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    DATE2=${DATE2:-${END}}

    echo ----- COND: $COND -----
    function fn_get_tbl_6jian_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${DATE2}';
        "
        tbl_super_dive="
        SELECT t.code, DATE_FORMAT(date1,'%m-%d') as start, 
                       DATE_FORMAT(date2,'%m-%d') as end, ${columns}, chng, 
                       round(100*(t.low  - avrg)/avrg,2) as lchng, 
                       round(100*(t.close- avrg)/avrg,2) as wchng, 
                       round(100*(d.close- avrg)/avrg,2) as avrg_up, 
                       round(100*(d.close-(t.close+t.low)/2)/avrg,2) as trough_up, 
                       round((avrg-d.close)/(d.close-(t.close+t.low)/2),2) as odds, 
                       ${nmcYi}, c.name 
            FROM ${tablex:-tbl_6mai} as t, cap as c, tempday as d
            WHERE t.code = c.code and t.code = d.code HAVING 1 ${COND}
            ORDER by ${1:-wchng} ${ASC:-asc} limit ${LIMIT:-36}     # COND='nmc<250000 and lchng<-9.7 and off<21'
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_6jian_dive $1
    mysql $mo -t kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao
}

function fn_dugu9jian()
{   # date1,date2,amount,open
    columns="off,turnov,avrg,close"
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    DATE2=`mysql -N kts <<< "SELECT date2 from ${tablex:-tbl_9jian} LIMIT 1"`

    echo ----- COND: $COND -----
    function fn_get_tbl_9jian_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${DATE2}';
        "
        tbl_super_dive="
        SELECT t.code,  DATE_FORMAT(date1,'%m-%d') as start, 
                        DATE_FORMAT(date2,'%m-%d') as end, ${columns}, 
                        round(avrg*(1-${ORACLE:-10}/100),2) as oracle, 
                        chng,
                        $RISE as rise, 
                        $PEAK as peak, 
                        $TROUGH as trough,
                        round(100*(t.low-avrg)/avrg,2) as lchng, 
                        round(100*(t.close-avrg)/avrg,2) as wchng, 
                       ${nmcYi}, c.name 
           FROM ${tablex:-tbl_9jian} as t, cap as c, tempday as d
           WHERE t.code = c.code and t.code = d.code HAVING 1 ${COND}
           ORDER by ${1:-lchng} ${ASC:-asc} limit ${LIMIT:-36}      # COND='nmc<250000 and lchng<-9.7 and off<21' 
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_9jian_dive $1
    mysql ${mo:-'-t'} kts <<< "${tempday}${tbl_super_dive}"
    xt_ret ${PIPESTATUS[0]} "${FUNCNAME}" || return $?

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao
}

function fn_tao5()
{
   #columns=date_p,date_c,off_p,off_c,tnov_p,tnov_c,avrg_p,avrg_c,ratio
    columns=date_p,off_p,date_c,off_c,tnov_c,avrg_p,avrg_c,ratio,wchng
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    echo ----- COND: $COND -----
    function fn_get_tbl_tao5_dive()
    {
        tbl_super_dive="
        SELECT t.code, ${columns}, c.nmc,c.name 
           FROM ${tablex:-tbl_tao5} as t, cap as c 
           WHERE t.code = c.code HAVING 1 ${COND} limit ${LIMIT:-144}
        "
        echo "${tbl_super_dive}"
    }

    fn_get_tbl_tao5_dive $1
    mysql $mo -t kts <<< "${tbl_super_dive}" |\
        sed -e '1,3s/----+$/\+/g' -e '$s/----+$/\+/g' -e '2s/    |$/|/g'
    xt_ret ${PIPESTATUS[0]} "${FUNCNAME}" || return $?
}

function fn_name()
{
    fn_iscode ${code:=${1}}
    xt_ret $? "Usage: name code" || exit $?

    sqls="SELECT code, name,
            CONCAT((round(nmc/10000, 1)),'Yi') as nmcYi
             FROM cap WHERE code=${code}
    " 
    fn_echo_succ `mysql -N kts <<< "${sqls}"`

    xt_ret $? "" || return $?
}

function fn_rdiff()
{
   #columns=date_p,date_c,off_p,off_c,tnov_p,tnov_c,avrg_p,avrg_c,ratio,dbrat
    columns=date_p,date_c,off_p,off_c,tnov_c,close,avrg_p,avrg_c,ratio,cdiff,rdiff,wchng
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}

    echo ----- COND: $COND -----
    function fn_get_tbl_rdiff_dive()
    {
        tbl_super_dive="
        SELECT t.id,t.code,
        ${columns}, (wchng+2*rdiff+3*cdiff) as fire
           -- , c.nmc, c.name
           FROM ${tablex:-tbl_rdiff} as t, cap as c 
           WHERE t.code = c.code HAVING 1 ${COND} limit ${LIMIT:-144}
        "
        # echo "${tbl_super_dive}"
        fn_name `mysql -N kts <<<"SELECT code FROM ${tablex:-tbl_rdiff} LIMIT 1"`
    }

    fn_get_tbl_rdiff_dive $1
    mysql $mo -t kts <<< "${tbl_super_dive}" 
    xt_ret $? "${FUNCNAME}" || return $?
}

function fn_acc() { tablex=tbl_adiff fn_rdiff; }

function fn_pma()
{
    fn_iscode $1
    xt_ret $? "" || return $?

    END=${END:-`fn_maxdate`}
    NUM=${NUM:=5}

    # enable d2，则tov扩大10倍
    echo "
    SELECT close FROM day WHERE code=$1 and date='$END' INTO @iclose;
    SELECT d.code, '${END}' as date, sum(d.amount)/sum(d.volume) as ma${NUM}, @iclose,
        round(100 * (@iclose-sum(d.amount)/sum(d.volume))/@iclose, 2) as pcnt,
        round(100*sum(d.volume)/cap.shares, 2) as tov${NUM}
        FROM 
        (SELECT * FROM day WHERE code=$1 and date<='$END' ORDER by date DESC LIMIT ${NUM}) as d,
        cap WHERE d.code = cap.code ;
    " | mysql -t kts
    # SELECT sum((high-yesc)/yesc) FROM day WHERE code = 2 and date > '2014-11-03'; 
    return $?
}

function fn_fbi()
{
    # code,datetime_p,datetime_c,dbrat
    columns='off_p,off_c,tnov_c,close,avrg_p,avrg_c,ratio,cdiff,rdiff,wchng'

    fn_name `mysql -N kts <<<"SELECT code FROM ${tablex:-tbl_fdiff} LIMIT 1"`
    echo "
        SELECT id,
        -- datetime_p, 
        TRUNCATE(datetime_p%(1000000000000)/1000000,4) as dt_p,
        -- datetime_c, 
        TRUNCATE(datetime_c%(1000000000000)/1000000,4) as dt_c, ${columns}, 
        round(close+(avrg_c-close)*.618 - close*ratio*.00236, 2) *              -- close as space
           IF((avrg_c-close)*.618 - close*ratio*.00236<0, -1, 1) as oracle,     -- ratio as time
        (wchng+2*rdiff+3*cdiff) as fire
        FROM ${tablex:-tbl_fdiff} LIMIT ${LIMIT:-200}
    " | mysql -t kts
}


function fn_acf() { tablex=tbl_acfdiff fn_fbi; }

function fn_vol()
{
    fn_yist
    get_vol() 
    {
    echo "
    SELECT date, round(sum(volume)/10000, 2) as Volume, 
        round(sum(amount)/10000, 2) as Amount, round(sum(amount)/sum(volume), 2) as Trade
        FROM day WHERE date<='${END}' ${COND} ${inLIST}
        GROUP by date 
        ORDER by date DESC
        LIMIT ${LIMIT:-13};
    " | mysql -t kts
    }

    case $1 in
    0)
        COND='and code<100000'
        ;;
    3)
        COND='and code>=300000 and code<400000'
        ;;
    6)
        COND='and code>=600000 and code<700000'
        ;;
    03)
        COND='and code<400000'
        ;;
    *)
        COND='and code<700000'
        ;;
    esac

    get_vol
    return $?
}

function fn_dorat()
{
    case $1 in
    h|u|usage)
        echo "
        SELECT dorat <param>
        u   usage
        ld  date
        *   date time
        "
        ;;
    ld)
        odr="ORDER by date ASC"
        mysql -N kts<<< "SELECT DISTINCT date FROM dorat"
        ;;
    *)
        # 只提供当天的times
        if [ -n "${DT}" ]; then
            DT=(${DT})
            END=${DT[0]}
            HMS=${DT[1]}
        fi
        odrLimit="ORDER by time DESC LIMIT ${LIMIT:-81}"
        mysql -N kts<<< "SELECT DISTINCT date,time FROM dorat WHERE date='${END}' && time<='${HMS:-15:05:00}' ${odrLimit}"
        ;;
    esac

    return $?
}


function fn_td_layout()
{
    fn_iscode ${code:=${1}}
    xt_ret $? "" || return $?
    dates=`mysql -N kts <<< "SELECT DISTINCT round(datetime/1000000,0) from fenbi WHERE code=${code}"`

    mysql kts <<< "TRUNCATE tmpfb";

    local i=
    for i in ${dates}; do
        # SELECT date FROM day WHERE code=${code} and date=
        echo "
        INSERT INTO tmpfb(code,datetime,trade,volume,amount)
        SELECT code,datetime%1000000,trade,volume,amount FROM fenbi 
            WHERE code=${code} and round(datetime/1000000, 0)=${i} 
            ORDER by trade ${ASC:-DESC} LIMIT 1; 
        " | mysql kts -t
        xt_ret $? "" || return $?
    done 

    mysql -t kts <<< "SELECT * FROM tmpfb ORDER by datetime DESC";

    return $?
}

function fn_dif120()
{
    if [ -z "${YIST}" ]; then
        fn_iscode $1 
        xt_ret $? "" || { echo "Usage: 120 code... {END}" && exit; }
        YIST=${file_ma120}
        xargs -n1 <<<"${*}" | sed 's/^0*//g' | xargs printf "%06d\n" > ${YIST}
    fi

    fn_yist 
    fn_echo_warn "----- LIST:${#LIST[@]} COND@${END}: $COND -----"

    tbl_day="(SELECT * FROM day WHERE date='${END}' ${inLIST})"

    sqls="
    SELECT d.code,d.date,d.close,ma120,100*(d.close-ma120)/ma120 as rise, c.name 
        ${sqls} FROM ${tbl_day} as d, 
        tbl_ma240 as t, 
        cap as c WHERE t.code=d.code and t.code=c.code 
        HAVING 1 ${inLIST} ORDER by rise ASC
    "
    mysql -t kts<<<"${sqls}"
    xt_ret $? "${FUNCNAME}" || return $?

    return 0
}

function fn_ma240_usage()
{
    echo "
    1 x_mid x_one 双线出击
    2 牛市step2 ma240收敛 & cross & 放量上行
    3 联合查询1 x_sho && NUM_RATIO=2 SCREENER 0
    4 联合查询2 强者恒强 平台突破 开山股份
    "
}

function fn_ma240()
{
    # 0. Make sure U've done [SCREENER ma240]?
    columns=code,date,close,ma5                     # ,ma5,ma10,ma20,ma60 # ,ma120,ma240
    columns=ma.${columns//,/,ma.}


    function fn_build_sqls() 
    {
    sqls="SELECT date FROM day WHERE code=900001 and date<='${END}' ORDER by date DESC LIMIT 4,1"
    ago5=`mysql -N kts<<<"${sqls}" 2>/dev/null`
    FIELD=${1:-x_sho}
    sqls="
    SELECT ${columns},
        round(100*(ma.close-ma5  )/ma5  ,1)as pma5,
        round(100*(ma.close-ma20 )/ma20 ,1)as pma20,
        round(100*(ma.close-ma40 )/ma40 ,1)as pma40,
        round(100*(ma.close-ma60 )/ma60 ,1)as pma60,
        round(100*(ma.close-ma120)/ma120,1)as pma120,
        ${x_sho} as x_sho,          -- 5 10 20
        ${x_mid} as x_mid,          -- 20 60 120
        ${x_long} as x_long,        -- 60 120 240
        ${x_sho}+
        ${x_mid}+
        ${x_long} as x_6line,       -- 一阳穿3线
        c.nmc,c.name FROM tbl_ma240 as ma, cap as c
        ${WHERE} ma.code=c.code and ma5!=0 and ma.date>'${ago5}' 
        HAVING 1 and code<600000 && nmc<1500000 && pma5>-2 ${COND}
        ORDER by ${FIELD} ${ASC:-ASC} limit ${LIMIT:-24}" 
    }

    # .0001 使得新股 x_sho x_long 都为 2.000
    # mid 5day 5week 5month
    x_sho="round(100*(abs((ma5-ma10)/(ma10))+abs((ma20-ma10)/(ma10))  ), 1)"
    x_mid="round(100*(abs((ma10-ma20)/(ma20))+abs((ma40-ma20)/(ma20)) ), 1)"
    x_long="round(100*(abs((ma40-ma60)/(ma60))+abs((ma120-ma60)/(ma60))), 1)"

    ABBR=ma fn_yist
    fn_build_sqls $1
    fn_echo_warn "----- LIST:${#LIST[@]} COND@${END}: $COND -----"
    echo "$sqls">/dev/stderr 
    mysql -t kts<<<"$sqls"

    fn_echo_warn "Suggest: COND=''"

    [ "${CHAO:=0}" -eq 0 ] && echo "----- CHAO:${CHAO} -----" && return
    fn_chao ${file_ma240}
}


function fn_hilo()
{
    columns='code,date1,date2,off,turnov,tovpd,rat1,rat2,high,low,close,chng'
    columns=${columns:-'*'}
    columns=t.${columns//,/,t.}


    function fn_yi_dive()
    {
        tempday="
        CREATE TEMPORARY TABLE tempday LIKE day;
        INSERT INTO tempday SELECT * from day where date='${CURR}';
        "
        # delete停牌个股
        tbl_super_dive="
        -- rat1:最低日lo量比 rat2:lo+(lo+1)日量比
        SELECT ${columns}, 
        -- dive:当前跳水幅度 rebound:反弹幅度离(low+close)/2
        round(100*(d.close-t.high)/t.high, 2) as dive, 
        round(100*(d.close-t.close)/t.close, 2) as rebound, c.nmc, c.name   -- t.close=(low+close)/2
        FROM tbl_hilo as t, tempday as d, cap as c
        WHERE t.code = d.code and t.code=c.code
        HAVING 1 ${COND}
        ORDER by ${1:-chng} ${ASC:-ASC} LIMIT ${LIMIT:-36}
        "
        echo "${tbl_super_dive}"
    }

    fn_yi_dive $1
    mysql $mo -t kts <<< "${tempday}${tbl_super_dive}"
    xt_ret $? "${FUNCNAME}" || return $?

    PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao
}

function fn_inout()
{
    inout_codes="
    $DROP        d_temp;
    CREATE TABLE d_temp LIKE day;
    INSERT INTO  d_temp ${d_temp};
    $DROP        d_curr;
    CREATE TABLE d_curr LIKE day;
    INSERT INTO  d_curr ${d_curr};

    $DROP        prev_codes;
    CREATE TABLE prev_codes LIKE codes;
    INSERT INTO  prev_codes(code) 
        SELECT code FROM (
            SELECT t.code, round(100*(d.close-t.low)/t.low, 2) as incr
            FROM ${hilo_prev} as t, d_curr as d
            WHERE t.code=d.code ORDER by incr DESC LIMIT ${LIMIT:-40}    -- PREV排名前40
        ) as t;

    $DROP        curr_codes;
    CREATE TABLE curr_codes LIKE codes;
    INSERT INTO  curr_codes(code) 
        SELECT code FROM (
            SELECT t.code, round(100*(d.close-t.low)/t.low, 2) as incr
            FROM ${hilo_curr} as t, d_temp as d
            WHERE t.code=d.code ORDER by incr DESC LIMIT ${LIMIT:-40}    -- CURR排名前40
        ) as t;

    $DROP        sit_codes;
    CREATE TABLE sit_codes LIKE codes;
    INSERT INTO  sit_codes(code) SELECT p.code FROM prev_codes as p, curr_codes as c  WHERE p.code=c.code;

    $DROP        out_codes;
    CREATE TABLE out_codes LIKE codes;
    INSERT INTO  out_codes(code) SELECT code FROM prev_codes WHERE code NOT IN(SELECT code FROM curr_codes);

    $DROP         in_codes;
    CREATE TABLE  in_codes LIKE codes;
    INSERT INTO   in_codes(code) SELECT code FROM curr_codes WHERE code NOT IN(SELECT code FROM prev_codes);
    "

    function fn_in_or_out()
    {
      echo "
      SELECT * FROM (
        SELECT ${columns}, 
        round(100*(d.close-t.low)/t.low, 2)  as incr,
        round(100*(max(t.high,d.close)-d.close)/d.close, 2) as decn,
        ${RISE} as rise,
        round((d.volume/t.mavol5), 2) as tov, t.scale,
        round((d.amount/10000), 1) as eYi,
        ${nmcYi0}, c.name
        FROM ${hilo_curr} as t, d_temp as d, cap as c
        WHERE t.code=d.code and t.code=c.code
        HAVING 1
        ORDER by incr ${ASC:-DESC} ) as newton
        WHERE code IN (SELECT code FROM ${1}_codes)                 -- 新进 = 今天前40-(2天的交集)
      HAVING ${HAVING:-1} ORDER by ${FIELD:-incr} ${ASC:-DESC}      -- 淘汰 = 昨天前40-(2天的交集)
      "
    }
    function fn_yi_descend()
    {
      tempday="${inout_codes}"
      tbl_super_dive=`fn_in_or_out $1`
      fn_echo_blue "${tbl_super_dive}"
    }
    
    return $?
}

function fn_lohi_wind()
{
    echo "
    SELECT * FROM (
    SELECT A.date, A.incr, A.rise, A.hico, A.red, (A.incr-B.incr)as dif
               FROM wind A INNER JOIN 
                    wind B on(A.id=B.id-1) GROUP BY A.id
    ) as t ORDER by ${FIELD:-date} DESC
    " | mysql -t kts
}

function fn_lohi_wolf()
{
    LIMIT=${LIMIT:-60}

    echo "
    $DROP wind;
    $CREATE wind (
        id          INT PRIMARY key AUTO_INCREMENT NOT NULL,
        date        date NOT NULL,
        incr        DECIMAL(6,2) NOT NULL DEFAULT 0,
        rise        DECIMAL(6,2) NOT NULL DEFAULT 0,
        hico        DECIMAL(6,2) NOT NULL DEFAULT 0,
        red         INT 
    ) " | mysql kts
    xt_ret $? "" || return $?

    dates=(`fn_get_date 1 ${BLK:-20}`)
    local i
    for (( i=0,j=2; i<${#dates[@]}; i++,j++ )); do
        let imod=i%5
        [ "${imod}" = 0 ] && echo ${dates[$i]} ${i}...
        export END=${dates[$i]}

        # uncomment below 2 lines to 统计最高高度
        CHAO=1 chao2=mi5 PARTS=2 END= iEND=$j SELECT lohi i
        export YIST=${chao}.mi5

        LIMIT=${LIMIT} FIELD=incr PARTS=1 fn_lohi i
        echo "
        ${tempday}
        INSERT INTO wind(date,incr,rise,hico,red)
        SELECT '${END}', sum(incr)/${LIMIT}, sum(rise)/${LIMIT}, sum(rise-hiri)/${LIMIT} as hico, sum(rise>${iDOOR:-0}) 
        FROM ( ${tbl_super_dive} ) as iwolf
        " | mysql -N  kts
        # echo "${tbl_super_dive}"; exit
        xt_ret $? "" || return $?
    done

    return $?
}

function fn_lohi_mi5()
{
    LIMIT=${LIMIT:-60}
    let jEND=${iEND:-1}+1
    CHAO=1 chao2=mi5 PARTS=2 iEND=$jEND SELECT lohi i
    export YIST=${chao}.mi5

    echo "
    $DROP f5rise;
    $CREATE f5rise (
        id          INT PRIMARY key AUTO_INCREMENT NOT NULL,
        time        time NOT NULL,
        f5rise      DECIMAL(6,2) NOT NULL DEFAULT 0,
        hico        DECIMAL(6,2) NOT NULL DEFAULT 0,
        red         INT 
    ) " | mysql kts
    xt_ret $? "" || return $?

    HMSs=(`fn_get_time 1 ${BLK:-80}`)
    nr=${#HMSs[@]}

    if [ "${nr}" -gt 60 ]; then
        iSTEP=${iSTEP:-3}
    elif [ "${nr}" -gt 40 ]; then
        iSTEP=${iSTEP:-2}
    elif [ "${nr}" -gt 20 ]; then
        iSTEP=${iSTEP:-1}
    fi
    local i
    for (( i=0; i<${nr}; i+=${iSTEP:-1} )); do
        let imod=i%5
        [ "${imod}" = 0 ] && echo ${HMSs[$i]} ${i}...
        export HMS=${HMSs[$i]}
        LIMIT=${LIMIT} FIELD=incr PARTS=1 fn_lohi i 0
        echo "
        ${tempday}
        INSERT INTO f5rise(time,f5rise,hico,red)
        SELECT '${HMS}', sum(rise)/${LIMIT} as wolf, sum(rise-hiri)/${LIMIT} as hico, sum(rise>${iDOOR:-0}) FROM (
        ${tbl_super_dive}
        ) as iwolf
        " | mysql -N  kts
        #echo "${tbl_super_dive}"; break;
        xt_ret $? "" || return $?
    done
    fn_echo_succ "${END}"
    echo "
    SELECT * FROM f5rise
    " | mysql -t kts

    return $?
}

function fn_lohi()
{
    iNUM=${NUM:-8}                          # PREV=`mysql -N kts <<< "SELECT max(end) from mat_lohi"`
    iCURR=`fn_get_prev`
    iPREV=`END=${iCURR} fn_get_prev`        # prev+temp = 灵活推演

    # echo END: ${END} curr: ${iCURR} prev:${iPREV}; exit

    hilo_temp="( SELECT * FROM mat_lohi WHERE end='${END}' and num=${iNUM} )"
    hilo_curr="( SELECT * FROM mat_lohi WHERE end='${iCURR}' and num=${iNUM} )"
    hilo_prev="( SELECT * FROM mat_lohi WHERE end='${iPREV}' and num=${iNUM} )"
       d_temp="SELECT * from day where date='${END}'"       # 最新day数据，可以是开市数据
       d_curr="SELECT * from day where date='${iCURR}'"     # 次新day数据，必是必市后数据

    case $1 in
    in|out|sit)
        fn_inout
        ;;
    l|list)
        SELECT dorat | cat -n; exit 0
        ;;
    d|date)
        SCREENER lohi l; exit 0
        ;;
    i|bvri)
        iF5=$2
        if [ "${1}" = bvri ]; then
            # 大放量.抄底反包股如<天银机电2015-12-29> 
              CONDb="((avri-bvri>${DOORb:-1.1})||(prop>.938&&rise>${YRISE:-1.23}))"
            # 熔断缩量版本
            # CONDb="((avri-bvri>${DOORb:-2.0})||(prop>0.8&&rise>0))"
            END=${PREV} COND="${CONDb}" LIMIT=2000 PARTS=2 chao2=bvri SCALE= SELECT lohi i
            YIST=${chao}.bvri
        fi

        if [ -z "${iF5}" ]; then
            TEMPDAY="tempday"
            tempday="
            $DROP tempday; CREATE TABLE tempday LIKE day;
            INSERT INTO tempday SELECT * from day where date='${END}';"
        else
            # TEMPDAY="(SELECT * FROM dorat WHERE date='${END}' && time='${HMS}')"
            # tempday=
            # 使用 tempday比SELECT子语句快10倍
            HMS=${HMS:-`fn_get_time ${iF5}`}
            TEMPDAY="tempday"
            tempday="
            $DROP tempday; CREATE TABLE tempday LIKE day;
            INSERT INTO tempday SELECT code,date,yesc,open,high,low,close,volume,amount 
            FROM dorat WHERE date='${END}' && time='${HMS}';
            "
        fi

        # echo HMS ${HMS}; exit

        if [ "${SCALE:-0}" = 'A' ]; then
            HMS=${HMS:-`fn_get_time 1`}
            SCALE=`SCALE=A fn_scale ${HMS}`
            fn_echo_succ SCALE ${SCALE}
        fi

        if [ "${CIXIN:-0}" = 1 ]; then
            sql_tov="${TURNOV} as tov"
            tbl_cixin=
            sql_eqcode=
            YIST='.blk.cixin'
        else
            sql_tov="ROUND((100*d.volume*c.close/c.nmc)/(1-top10_ajst_aR), 2) as vtov"
            tbl_cixin='top10,'
            sql_eqcode="&& t.code=${tbl_cixin//,/}.code"
            fn_notin_blk FFA1
        fi

        ABBR=t fn_yist

        function fn_yi_descend()
        {
          columns="d.code,DATE_FORMAT(t.date1,'%m-%d')as date1,t.off,t.lohi" #t.low,

          tbl_super_dive="
          SELECT * FROM (
            SELECT ${CID}${columns},
            round(100*(d.close-t.low)/t.low, 2)  as incr,
         -- round(100*(GREATEST(t.high,d.close)-d.close)/GREATEST(t.high,d.close), 2) as decn,
            round(100*(t.amount/t.volume-d.yesc)/d.yesc, 1) as bvri, 
            d.close,
            $OPRI as opri,
            round(100*(d.high-d.yesc)/d.yesc, 2) as hiri,
            round(100*(d.amount/d.volume-d.yesc)/d.yesc, 1) as avri,
            ${RISE} as rise,
            ${sql_tov},
            round((${SCALE:-1}*d.volume/t.mavol5), 2) as prop5,
            round((${SCALE:-1}*d.volume/t.volume), 2) as prop, t.scale,
            round((d.amount/10000), 1) as eYi, 
         -- round((t.amount/10000), 1) as zYi,
            ${nmcYi0}, c.name
            FROM ${hilo_curr} as t, ${tbl_cixin}
            ${TEMPDAY} as d, cap as c
            ${WHERE} t.code = d.code and t.code=c.code ${sql_eqcode} -- && (d.high!=d.low&&d.high>d.yesc)
            HAVING 1 ${COND}
            ${notinBLK}
            ORDER by incr ${ASC:-DESC} ) as t
          HAVING ${HAVING:-1} ORDER by ${FIELD:=incr} ${ASC:-DESC} LIMIT ${LIMIT:-60}
          "
          [ ${DEBUG:-0} -eq 1 ] && echo "${tempday}${tbl_super_dive}" && exit
        }
        ;;
    wolf)
        fn_lohi_wolf; 
        fn_lohi_wind; exit ;;
    wind)
        fn_lohi_wind; exit ;;
    mi5)
        fn_lohi_mi5; exit ;;
    u|*)
        nouse="
            in        : exist dates
            out       : dates list with num"
        echo "
        SELECT lohi <param>
            l|list    : list of iF5
            d|date    : list of date
            bvri  iF5 : bvri 增长
            i     iF5 : from dorat，iF5为空时取最新
            wolf      : 统计#{BLK:-8}日内#{LIMIT:-60}支最活跃股的最高涨幅wind
            wind      : show.wind
            mi5       : 统计#{BLK:-8}个5分钟走势
            *         : usage
        指标说明：
            --------------------------大盘不稳皆是浮动-------------------------
            incr: 总涨幅，大于22%抛压增大
            hiri: high出现与大盘最高点应该同步，dif(avrg)不应该把量能掏空了
       avri/bvri: 今日/昨日 均价    均衡股<天喻信息>，十字星，尾部发力与黄线重合最佳(有主力护航)
           YRISE: 昨日的涨幅门限<1.23>，大跌时降低，大涨时调高
      prop/scale: 今日/昨天 量比    强势股的概念及板块很重要，scale<2可以确保资金安全.
        "
    fn_echo_succ "\
    1. 逐级放量，avri逐步抬高
    COND='vtov>.5 && (avri>bvri||(rise>3&&avri+1>bvri)) && scale>1.23&&prop>1.23 && scale<4&&prop<3' SELECT lohi bvri
    2. 1级放量小，avri逐步抬高
    COND='vtov>.5 && (avri>bvri||(rise>3&&avri+1>bvri)) && scale>1.06&&prop>1.00 && scale<4&&prop<3' SELECT lohi bvri
    3. 大放量后微缩量
    COND='vtov>.5 && (avri>bvri&&prop<=1.1)             && scale>2.00&&prop5>1.3 && scale<5&&prop<4' SELECT lohi bvri
    4. 底分型(最低日:缩量微涨)
    iEND=2 CHAO=1 LIMIT=2000 chao2=prev  COND='vtov>.5  && avri<bvri && rise>-1 && prop>.8&&prop<1.1' SELECT lohi i
    YIST=${chao}.prev COND='prop>1.4 && rise>0' SELECT lohi i       # 超跌至前低+连续两日DDE为正(中毅达.飞乐音响.当日冲涨停板)
    5. WEEK级别
    COND='w1>1.1&&w2>1' NUM=3 SELECT wee; COND='w1>1.1&&w2>1' NUM=4 SELECT wee
    " 2>&1 # | sed 's/^  *//'
        exit
        ;;
    esac

    fn_yi_descend

    case ${PARTS:-4} in
    1) return                                                                           ;; # 不输出chao，不输出mysql结果
    2) CHAO=1 PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao ${chao}.${chao2:-lohi}   ;; # 只输出chao
    3) mysql ${OPT:--t} kts <<< "${tempday}${tbl_super_dive}"
       CHAO=1 PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao ${chao}.${chao2:-lohi}   ;; # 既输出chao，又输出mysql
    *) mysql ${OPT:--t} kts <<< "${tempday}${tbl_super_dive}"
       PREFIX=${tempday} sqls=${tbl_super_dive} fn_chao ${chao}.${chao2:-lohi}          ;; # 响应CHAO
    esac

    fn_echo_warn "END=$END time=${HMS} index=${iF5} FIELD=${FIELD}"
}

function fn_ban()
{
    iDATE=`fn_get_prev`
    tempday="(SELECT * FROM day WHERE date='${iDATE}')"
    sql="SELECT round(d.close*shares/10000,1) as col FROM cap as c, ${tempday} as d WHERE c.code=d.code ORDER by col ASC LIMIT 770,1"
    smlYi=`mysql -N kts <<<"${sql}"`
    sql="SELECT round(d.close*shares/10000,1) as col FROM cap as c, ${tempday} as d WHERE c.code=d.code ORDER by col ASC LIMIT 1540,1"
    midYi=`mysql -N kts <<<"${sql}"`
    sql="SELECT round(d.volume/shares, 4)     as col FROM cap as c, ${tempday} as d WHERE c.code=d.code ORDER by col ASC LIMIT 1160,1"
    tov=`mysql -N kts <<<"${sql}"`

    fn_echo_succ ${tov} ${smlYi} ${midYi}

    factor=${ZIZE:-0.25}    # tov(30min) ~= 25%，3个10分钟分别是：<12:8:5> * 优秀因子1.5 0940 0945 0950=>  0.18 0.25 0.30

    fn_run()
    {
    # 有时小票连续3板也是好票 <300314	戴维医疗>，特别是10点前封板票
    incr="incr<${incr:-22}"
    COND="${incr}" LIMIT=1400 HAVING="avri>2&&rise>avri-.6 && tov>${factor}&&tov<.8 && ${xCOND}" SELECT lohi ${1:-1}
    }

    fn_echo_blue "small"
    incr=30 xCOND="eYi>nmcYi*${factor}*${tov} && nmcYi<=${smlYi}"
    fn_run $1
    xt_ret $? "" || return $?

    fn_echo_succ "middle"
    xCOND="eYi>nmcYi*${factor}*${tov} && nmcYi>${smlYi}&&nmcYi<${midYi}"
    fn_run $1 2>/dev/null
    xt_ret $? "" || return $?

    fn_echo_warn "large"
    xCOND="eYi>nmcYi*${factor}*${tov} && nmcYi>=${midYi}"
    fn_run $1 2>/dev/null
    xt_ret $? "" || return $?

    # 底部、中部，拒绝顶部
    fn_echo_warn "scale<1.2"
    xCOND="eYi>nmcYi*${factor}*${tov}"
    COND='incr>=22 && scale<1.2' LIMIT=1400 HAVING="avri>2&&rise>avri-.6 && tov>${factor} and ${xCOND}" SELECT lohi ${1:-1} 2>/dev/null
    xt_ret $? "" || return $?
}

function fn_sban()
{
    case $1 in
    a|avri)
        fn_get_ratio_close2open idxopen
        # echo ${idxopen} ${tov_pcnt}; exit
        for (( i=${START:=${idxopen}}; i>${STOP:-0}; i-=1 )); do
            [ "${i}" -ne "${START}" ] && YIST=${chao}.temp 
            iCOND="hiri>5 && rise>avri-.6 && avri>0 && avri<9.93 && tov<${tov_pcnt} && nmcYi<80"
            LIMIT=3000 YIST=${YIST} COND=${iCOND} CHAO=1 SELECT lohi ${i}
            cp ${chao}.lohi ${chao}.temp
        done
        ;;
    40)
        ZIZE=0.18 fn_ban; exit
        ;;
    47)
        ZIZE=0.25 fn_ban; exit
        ;;
    .99)
        COND='tov<=1 && rise>9.93' SELECT lohi ${2:-1} ${3}; exit
        ;;
    g1)
        COND='tov>1 && rise>9.93' SELECT lohi ${2:-1} ${3}; exit
        ;;
    c|code)
        COND="code=$2" SELECT lohi ${3:-1}; exit
        ;;
    u|*)
        echo "
        SELECT sban <param>
            a   : close>avri-1
            40  : 0940 tov .18
            47  : 0947 tov .25
            .99 : tov<=1 && rise>9.93
            g1  : tov>1 && rise>9.93
            c   : c code [i]
            *   : usage
        "
        ;;
    esac
}

function fn_xrd()
{
    mysql kts <<<"SELECT * from xRD WHERE date${OP:->}'${END}' order by ${1:-date} ASC"
    return $?
}

function fn_cap()
{
    if [ -n "${1}" ]; then
        COND="code=${1}"
    elif [ -f "${YIST}" ]; then
        fn_yist
    else
        fn_execute -l && exit
    fi

    mysql -t kts <<<"SELECT * FROM cap WHERE ${COND:-1} ${inLIST} ORDER by nmc DESC;"
    return $?
}

function fn_lhb()
{
    if [ -n "${CAUSE}" ]; then
        CAUSE=`
                sed -e "s/c3/cause='3up20'/"        \
                    -e "s/c7/cause='up7'/"          \
                    -e "s/c8/chng>=9.832/"          \
                    -e "s/cs/cause='s3up12'/"       \
                    -e "s/ct/cause='tov20'/"        \
                    -e "s/b>/bloo>/"                \
                    -e "s/p>/${LOGIC}bsp>/"         \
                    -e 's/A/\&\&/g'                 \
                    -e 's/O/||/g' <<< "${CAUSE}"`
        # echo ${CAUSE}; exit
        CAUSE="and (${CAUSE})"
    fi

    sql_maxdate="SELECT max(date) FROM lhb"
    max_dt=`mysql -N kts <<< "${sql_maxdate}"`
    case $1 in
    r|cause)
        mysql -t kts <<<"SELECT DISTINCT cause FROM lhb"
        ;;
    l|dates)
        fn_list_date $2
        ;;
    d|del)
        date=`fn_get_date ${2:-1}`
        mysql kts <<< "DELETE FROM lhb WHERE date='${date}'"
        xt_ret $? "del fail" || return $?
        fn_echo_succ "del from lhb@${date}"
        ;;
    +10)
        sta=`fn_get_date ${2:-1}`
        off=`mysql -N kts <<< "SELECT count(*) from day WHERE code=900001 and date>='${sta}' && date<='${END}'"`
        tbl="SELECT * FROM day WHERE date>='${sta}' && date<='${END}' and (close-yesc)/yesc>.0993"
        sql="SELECT code,count(code) as num FROM (${tbl}) as t GROUP by code ORDER by num DESC LIMIT ${LIMIT:-30}"
        sql="SELECT * FROM ($sql) as t HAVING 1 ${COND}"
        mysql -t kts <<<"${sql}"
        fn_echo_succ "${sta} wday:`date --date=${sta} +'%w'` off:${off}"
        sqls=${sql} fn_chao ${chao}
        ;;
    g)
        sta=`fn_get_date ${2:-1}`
        off=`mysql -N kts <<< "SELECT count(*) from day WHERE code=900001 and date>='${sta}' && date<='${END}'"`
        wsql="WHERE date>='${sta}' && date<='${END}' && (chng>=3.82)"
        sql="SELECT code,count(code) as num FROM lhb ${wsql} GROUP by code ORDER by num DESC LIMIT ${LIMIT:-30}"
        sql="SELECT * FROM ($sql) as t HAVING 1 ${COND}"
        mysql -t kts <<<"${sql}"
        fn_echo_succ "${sta} wday:`date --date=${sta} +'%w'` off:${off}"
        sqls=${sql} fn_chao ${chao}
        ;;
    c|n|s|S)
        if [ $1 = S ]; then
            col_date='date,'
        elif [ $1 = c ]; then
            fn_iscode $2
            xt_ret $? "code:${2}" || return $?
            fn_xtempday $2
            xt_ret $? "xtempday error" || return $?
            COND="${COND} and code=${2}"
            col_date='date,'
            FIELD=${FIELD:-date}
            sql_relate="&& l.date=d.date"
            sql_xtempday=", xtempday as d"
            LIMIT=${LIMIT:-8}
        else # s
            fn_isdigit ${2:-1}
            xt_ret $? "\$2[$2] must be digit" || return $?
            date=`fn_get_date ${2:-1}`
            fn_echo_warn "lhb of ${date} by ${FIELD}"

            fn_xtempday ${date}
            xt_ret $? "xtempday error" || return $?

            sql_relate="&& l.code=d.code && l.date='$date'"
            sql_xtempday=", xtempday as d"

            # 自动处理apple
            RET=`mysql -N kts <<< "SELECT IF('${date}'<'${CURR}', 1, 0)"`
            if [ "${RET}" -eq 1 ]; then
                xdate=`END=${date} fn_get_next`

                TBL=x fn_xtempday ${xdate}
                xt_ret $? "xtempday error" || return $?
                sql_relate="&& l.code=x.code ${sql_relate}"
                sql_xtempday="${sql_xtempday}, x"
                sql_next="
                ${APPLE} as apple,
                ROUND(100*(x.open-x.yesc)/x.yesc, 1) as Xopri,
                "
                FIELD=${FIELD:-apple}
            fi
        fi

        fn_echo_warn "CAUSE: ${CAUSE}"

        ABBR=l fn_yist
        xt_ret $? "" || return $?

        columns="${col_date}code,cause"
        columns=l.${columns//,/,l.}

        sqls="
            SELECT ${columns}, round(chng,1) as chng,
            ${sql_next}
            ${sql_tov}
            round((buy-sell)/10000, 2) as eLHB,
            round(l.buy/10000, 2) as buy,
            round(l.sell/10000, 2) as sell,
            bloo,sloo,
            round((l.buy-l.sell)/${nmcYi0%as*}/100,2) as net,
            round(bloo/sloo, 2) as bsp,
            ${sql_avrg}
            round(l.buy/bloo/100, 2) as eYi, ${nmcYi0},
            c.name FROM lhb as l,cap as c ${sql_xtempday}
            $WHERE l.code=c.code ${sql_relate} 
            HAVING 1 ${CAUSE} ${COND} ORDER by ${FIELD:-bsp} DESC LIMIT ${LIMIT:-36}
        "
        #echo "${sqls}"; exit
        mysql -t kts <<<"${sqls}"
        fn_chao
        ;;
    a|o)
        LOGIC=${1/o/'||'}
        LOGIC=${LOGIC/a/'\&\&'}
        CAUSE="(c8&&(b>${BLOO:-13.8}p>1.38))||(chng<-4.9&&bsp>2)"
        LOGIC=${LOGIC} CAUSE="${CAUSE}" COND="${COND#and}" SELECT lhb s ${2:-1} ${3:-avrg}
        #echo $CAUSE
        ;;
    x)
        BLOO=25;
        LOGIC=${1/x/'\&\&'}
        CAUSE="(c8&&(b>${BLOO}p>1.38))"
        LOGIC=${LOGIC} CAUSE="${CAUSE}" COND="${COND#and}" SELECT lhb s ${2:-1} ${3:-bloo}
        ;;
    *)
        fn_echo_succ "\tlhb max_date@${max_dt}"
        echo "
        SELECT lhb <param>
        +10 n   n日内涨停次数
        c code  指定代码
        r       上榜原因list
        l       日期list
        g n     n日内因+3.82%上榜次数统计
        s [i]   SELECT日期，i不指定时为1，代表今天
        d [i]   指定dele日期，i不指定时为1，代表今天
        a|AND   CAUSE='(8&&(b>15p>2))' COND=\$aCOND
        o|OR    CAUSE='(8||(b>15p>2))' COND=\$aCOND
        x|XOR   b>25

        CAUSE='3 7 8 s t'
        c3   3up20
        c7   up7
        c8   +5%         ----- 3+7=8
        cs   s3up12
        ct   tov20
        b>p> bloo.bsp    tov!>20 && avrg>7 && opri>3 (tov太大即3日内到头 && 和大猪在一起 && 起飞的欲望)
        "
        ;;
    esac

    return $?
}

function fn_BBD_wolf() 
{
    fn_usage() { echo "SELECT wolf real 0|3|6|03|a|y";exit; }
    case $i in
    0) YIST= fn_yist;iCOND='and d.code<100000' ;;
    3) YIST= fn_yist;iCOND='and d.code>=300000 and d.code<400000' ;;
    6) YIST= fn_yist;iCOND='and d.code>=600000 and d.code<700000' ;;
    03)YIST= fn_yist;iCOND='and d.code<400000' ;;
    a) YIST= fn_yist;iCOND='and d.code<700000' ;;
    y) [ -z "${YIST}" ] && fn_usage || iCOND= fn_yist ;;
    *) fn_usage ;;
    esac
    #fn_echo_warn "SELECT sum(nmc*net)/sum(nmc) FROM dde $WHERE date='${END}' ${iCOND}"

    if [ "${once}" = '' ]; then
        fn_echo_warn "code\tnet\ttov @${END}"; once=1
    fi
    echo "
    SELECT '$i', round(sum(nmc*net)/sum(nmc), 2), round(sum(amount)/100/sum(nmc), 2) 
    FROM dde as d $WHERE date='${END}' ${iCOND};
    " | mysql -N kts
}


function fn_scale()
{
    if [ -z "${1}" ]; then
        HMS=CURRENT_TIME
    else
        HMS="'${1}'"
    fi
    SEC_150000=54000
    SEC_113000=41400
    SEC_093000=34200
    SEC_110000=39600
    col_open="IF( TIME_TO_SEC($HMS) <= ${SEC_113000}, TIME_TO_SEC($HMS)-${SEC_093000}, TIME_TO_SEC($HMS)-${SEC_110000} )"
    col_scale="IF(TIME_TO_SEC($HMS) <= ${SEC_150000}, ${col_open}, 60*60*4)"


    index=`mysql -N kts <<<"SELECT FLOOR( (${col_scale} + 30)/(60*6))-1"`
      mod=`mysql -N kts <<<"SELECT FLOOR( (${col_scale} + 30)/(60*3))%2"`
    
    # 每6分钟一个校正
    # iEND=5 CHAO=1 LIMIT=2000 COND="tov>2.5 && tov<7.5" SELECT lsd
    # tov<7.5，11:18:00达到50%
    # tov>7.5，为<7.5更快到达，但总体误差是很小的

    iRATIO=(
        .051 .092 .130 .166 .198 .230 .258 .284 .308 .331 # 10  .331  -- 1.64 
        .353 .375 .395 .415 .433 .451 .474 .498 .517 .534 # 20  .203            -- 成交呈月牙状，中间两中时较稳定
        .553 .569 .590 .611 .629 .654 .673 .692 .709 .733 # 30  .201            -- 如果1st+，且调低预期，3rd+，则要调高最后预期
        .756 .775 .796 .816 .834 .856 .884 .913 .950 1.00 # 40  .267  -- 1.34
    )
    # echo ${index} ${mod} iRATIO+mod: `bc -l<<<"scale=3;${iRATIO[${index}]}*(1+${mod}/80)"`; exit

    # 成交量估算值 = tov * K = tov / 时间百分比 * 动态倍数 
    # K = 动态倍数/时间百分比

    if [ "${SCALE}" = A ]; then
        mysql -N kts <<<"SELECT ROUND( 1 / (${iRATIO[${index}]}*(1+${mod}/80) ), 3)"
    else
        echo "带权  不带权"
        mysql -N kts <<<"SELECT ROUND( 1 / (${iRATIO[${index}]}*(1+${mod}/80) ), 3), ROUND( (60*60*4)/${col_scale}, 3)"
    fi

    return $?
}

function fn_wolf_sqls()
{
    col_tet="ROUND(net/(1-top10_ajst_aR), 2) as Tet,"
    FIELD=${FIELD:-net}
    DOOR=${DOOR:--1}
    yesc='(trade/(1+rise/100))'
    sqls="
        SELECT ${col_date} w.code, w.rise,
        ROUND( (100*(w.amount/shou-$yesc)/$yesc), 1) as avrg, tov,
        ROUND(100*nmc*(pbuy+nbuy)/w.amount, 2) as eWolf,
        pbuy,nbuy, psell,nsell,
    --  (pbuy+nbuy) as buy,
    --  (psell+nsell) as sell,
    --  round(100*(pbuy+nbuy)/tov, 1) as bloo,
    --  round(100*(psell+nsell)/tov, 1) as sloo,
        net,
    --  ${col_tet}
        round((pbuy/nbuy), 2) as Go,
        round((nsell/psell), 2) as nGo,
        round((pbuy+nbuy)/(psell+nsell), 2) as bsp,
        round((w.shou/h.volume), 1) as prop, h.scale,
        round(w.amount/10000, 2) as eYi, 
        ROUND(nmc, 2) as nmcYi 
        ${col_name}
        FROM xdde as w , curr_lohi as h
        ${WHERE} 
        w.code=h.code && 
        w.date<='${END}' ${iCOND} && net>${DOOR}     -- WHERE(net>0)加速3倍
        HAVING 1 ${CAUSE} ${COND} && ${eCOND:-1}  ${ORDER:-ORDER by ${FIELD} ${ASC:-DESC}} LIMIT ${LIMIT:-36}
    "
    fn_echo_warn "wolf of ${date:-${END}}.${stime:-latest} [DOOR:${DOOR}] ${FIELD}"
    # echo "${sqls}"; exit
}

function fn_asm_nDDE()
{
    echo "
    DROP   TABLE IF EXISTS nDDE;
    CREATE TABLE nDDE LIKE mat_dde;
    INSERT INTO nDDE(date,time,code,net,pbuy,nbuy,psell,nsell,rise,trade,speed,shou,tov,amount,nmc,name) 
        SELECT date,time,code,net,pbuy,nbuy,psell,nsell,rise,trade,speed,shou,tov,amount,nmc,name FROM dde
        WHERE date>='${STA}' && date<'${END}';
    INSERT INTO nDDE(date,time,code,net,pbuy,nbuy,psell,nsell,rise,trade,speed,shou,tov,amount,nmc,name) 
        SELECT date,time,code,net,pbuy,nbuy,psell,nsell,rise,trade,speed,shou,tov,amount,nmc,name FROM mat_dde
        WHERE date='${END}' && time='${stime}';
    " | mysql kts
    xt_ret $? "" || return $?
}

function fn_nDDE_sqls()
{
    DOOR=${DOOR:--.6}
    yesc='(trade/(1+rise/100))'
    sqls="
    SELECT t.code,
        sum(net>=${DOOR}) as red,
        sum(rise) as wise, 
        sum(net) as wet,
        ROUND(sum(tov/(1-top10_ajst_aR)), 2) as vtov,
        rise,avrg,
        sum(eWolf) as eWolfs,
        buy,sell,net,Go,bsp,prop,scale,eYi,nmcYi, t.name
        FROM (
        SELECT w.date,w.code, w.rise,
        round( (100*(w.amount/shou-$yesc)/$yesc), 1) as avrg,
        tov,
        round(nmc*net/100, 2) as eWolf,
        (pbuy+nbuy) as buy,
        (psell+nsell) as sell,
        round(net, 2) as net,
        round((pbuy/nbuy), 1) as Go,
        round((pbuy+nbuy)/(psell+nsell), 2) as bsp,
        round((w.shou/h.volume), 1) as prop, h.scale,
        round(w.amount/10000, 2) as eYi, 
        nmc as nmcYi, w.name 
        FROM ${WOLf} as w, curr_lohi as h
        ${WHERE} 
        w.code=h.code && 
        w.date>='${STA}' && w.date<='${END}' 
        ORDER by code ASC, date DESC
    ) as t, top10 WHERE t.code=top10.code
    GROUP by code 
    HAVING 1 ${CAUSE} ${COND} ORDER by ${FIELD} ${ASC:-DESC} LIMIT ${LIMIT:-24}
    "
    #-- && net>${DOOR}     -- WHERE(net>0)加速3倍
    fn_echo_warn "wolf of ${END}.${stime:-latest} [NUM:${NUM}] [DOOR:${DOOR}] ${FIELD}"
    echo "${sqls}"; exit
}

function fn_wolf()
{
    function fn_list_times()
    {
        fn_echo_warn "time @${END}"
        mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC" | cat -n
        exit
    }

    if [ -n "${CAUSE}" ]; then
        case ${CAUSE} in
        ct) LIMIT=;;
        esac

        CAUSE=`
                sed -e "s/c9/rise>9.93/"        \
                    -e "s/c8/rise<9.93/"        \
                    -e "s/c5/avrg>5/"           \
                    -e "s/c1/Go>1 A bsp>=1.5/"  \
                    -e "s/ct/net>0 A rise>0/"   \
                    -e 's/A/\&\&/g'             \
                    -e 's/O/||/g' <<< "${CAUSE}"`
        # echo ${CAUSE}; exit
        CAUSE="and (${CAUSE})"
        fn_echo_warn "CAUSE: ${CAUSE}"
    fi

    sql_maxdate="SELECT max(date) FROM dde"
    max_dt=`mysql -N kts <<< "${sql_maxdate}"`
    sql_mindate="SELECT min(date) FROM dde"
    min_dt=`mysql -N kts <<< "${sql_mindate}"`
    [ "${max_dt}" != ${CURR} ] && { fn_echo_fail "${max_dt} != ${CURR}, dde is lagged"; return 1; }
    sql_maxend="SELECT max(end) FROM mat_lohi"
    max_end=`mysql -N kts <<< "${sql_maxend}"`
    fn_issqltrue "'${max_end}' >= '${PREV}'"
    [ "${?}" -ne 0 ] && { fn_echo_fail "lohi is lagged, updating..."; SCREENER lohi 1; return 1; }
   #hilo_curr="( SELECT * FROM mat_lohi WHERE end='${PREV}' and num=${iNUM:-8} )"

    case $1 in
    l|dates)
        fn_list_date $2
        ;;
    b|BBD)
        param=${@:2}
        for i in ${param:-NULL}; do
            fn_BBD_wolf $i
        done
        ;;
    c|cf|code)
        fn_iscode $2
        xt_ret $? "code:${2}" || return $?

        if [ "${1}" = c ]; then
            col_date="w.date,"
            ORDER="ORDER by ${FIELD:-date} DESC"
            iTBL=dde
        else
            #col_date="DATE_FORMAT(w.date,'%m-%d')as date,time,"
            col_date="w.date,time,"
            ORDER="ORDER by date DESC, time DESC"
        fi

        xCol=code fn_xCol ${iTBL:-mat_dde} xdde ${2}
        xt_ret $? "" || return $?

        iCOND="and w.code=${2}"
        LIMIT=${LIMIT:-20}
        col_name=
        fn_name ${2}
        DOOR=-50 fn_wolf_sqls
        mysql -t kts <<<"${sqls}"
        fn_chao
        ;;
    n|nDDE)
        fn_yist
        sta=${2:-1}
        fn_isdigit ${sta}
        if [ "${?}" -eq 0 ]; then
            FIELD=${3:-wet}
        else
            FIELD=$2; sta=1; 
        fi

        [ "${2}" = l ] && fn_list_times

        # 非实时统计，重新组装wOLF

        PREV=`END=${date:-${END}} fn_get_prev`
        xCOND="num=${NUM:-8}" xCol=end fn_xCol mat_lohi curr_lohi ${PREV}

        NUM=${NUM:-2}
        STA=`fn_get_date ${NUM}`

        if [ ${sta} -ne 1 ]; then
            let sta--
            stime=`mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC LIMIT ${sta},1"`
            WOLF=nDDE
            fn_asm_nDDE
            xt_ret $? "" || return $?
        fi
        WOLf=${WOLF:-dde} fn_nDDE_sqls
        mysql -t kts <<<"${sqls}"
        fn_chao
        ;;
    s|st|select)
        ABBR=w fn_yist
        if [ "$1" = st ]; then
            fn_isdigit ${sta:=$2} || fn_list_times
            let sta--
            stime=`mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC LIMIT ${sta},1"`
            xCOND="time='${stime}'" xCol=date fn_xCol mat_dde xdde ${END}
            xt_ret $? "" || return $?
        else
            stime=`mysql -N kts<<< "SELECT DISTINCT time FROM mat_dde WHERE date='${END}' ORDER by time DESC LIMIT 1"`
            xCol=date fn_xCol dde xdde ${END}
            xt_ret $? "" || return $?
        fi

        PREV=`END=${date:-${END}} fn_get_prev`
        xCOND="num=${NUM:-8}" xCol=end fn_xCol mat_lohi curr_lohi ${PREV}
        xt_ret $? "" || return $?

        col_name=',w.name'
        fn_wolf_sqls
        mysql -t kts <<<"${sqls}"
        fn_chao ${chao}.wolf
        ;;
    e|E)
        HMS=${HMS:-`fn_get_time 1`}
        iSCALE=`SCALE=A fn_scale ${HMS}`
        iNMC=100
        case $1 in
           e) eCOND="tov>${iSCALE} && nmcYi<=${iNMC}" ;;
           E) eCOND="tov>${iSCALE} && nmcYi >${iNMC}";;
        esac

        FIELD=eWolf fn_wolf st ${2:-1}
        ;;
    *)
        fn_echo_succ "\twolf date ${min_dt}~${max_dt}"
        echo "
        SELECT wolf <param>
        l               date-list
        n|nDDE  idx     {NUM:-2}日DDE统计，变量代表日倒数索引
        b|BBD           沪深BBD统计
        s|e             e mean FIELD=eWolf
        st      idx|l   SELECT time or list-times
        cf      code    按15分钟统计
        c       code    按日统计\
        "
        fn_echo_warn "\
        CAUSE:
        c1  攻击性  短期资金涌入，Go>1&&bsp>=1.5
        ct  高换手  短线活跃资金，net>0Arise>0      -- 前两档和>1亿，并BSP>2
        cT  博反弹  浙江永强
        c5  >7保底  avrg>5
        c8  非涨停  rise<9.93
        c9  涨停    rise>9.93"
        fn_echo_succ "
        熵减表征eWolf=buy/tov
        COND='eWolf>.5&&Go>1 && nmcYi<100' iEND=2 SELECT wolf s
        涨停潜力股
        DOOR=-.6 LIMIT=300 COND='rise>2&&rise<9.93' SELECT wolf s rise
        " 2>&1 | sed 's/^  *//g'
        ;;
    esac
    
    return $?
}

function fn_fmacd()
{
    mysql -t kts <<< "SELECT * FROM fmacd";
}

function fn_macd()
{
    fn_yist
    case $1 in
    c|clean)
        echo "DROP TABLE IF EXISTS mm55" | mysql kts; 
        fn_echo_succ "succ: clean macd!"; exit 0
        ;;
    [0-9]*)
        COND="and code=$1"
        FIELD=$2
        ;;
    u|h)
        echo "
        c           # clean mm55
        000002      # 只显示单个代码的macd
        "
        exit
        ;;
    *)
        FIELD=$1
        ;;
    esac

    fields='close,fa20,ma5,ma10,ma20,ma40,ma80'
    limo='(FM=15)*IF(close>=fa20, 1, -1)*((fa20>=ma5)+(fa20>=ma10)+(fa20>=ma20)+(fa20>=ma40)+(fa20>=ma80))'
    echo "
    SELECT code,FM,datetime%1000000 as time,
        ${fields},
        round(100*( abs(ma5-ma10)/ma10 + abs(ma20-ma10)/ma10 ), 2) as abs,
            cvgenc,
            ${limo} as limo, d1,m1,dif,macd FROM mm55
            HAVING 1 ${COND} ${inLIST}
            ORDER by ${FIELD:-code},FM ${ASC:-ASC};
	" | mysql -t kts
    
    return $?
}

function fn_update_stati_ban()
{
    nrLIST=${#LIST[@]}
    sql_earning="
    INSERT INTO stati_ban SELECT 
                 '${END}' as date,
              '${nrLIST}' as nrLIST,
              count(code) as num,
    sum(hiri)/count(code) as e_hiri,
    sum(opri)/count(code) as e_opri,
    sum(rise)/count(code) as e_clri,
    sum(avrg)/count(code) as e_avrg
    FROM (${sqls//;/}) as t
    "

    if [ "${UPDATE_STATI_CODES:-0}" = 1 ]; then
        echo "
        SELECT code FROM (${sqls//;/}) as t
        " | mysql -N kts >> ${chao}.stati_ban
    fi
    mysql -t kts <<<"${sql_earning}"
    xt_ret $? "" || return $?
}

function fn_create_stati_ban()
{
    echo "
    $DROP stati_ban;
    $CREATE stati_ban (
        date    date,
        nrLIST  INT,
        num     INT,
        e_hiri  DECIMAL(6,2) NOT NULL DEFAULT 0,
        e_opri  DECIMAL(6,2) NOT NULL DEFAULT 0,
        e_clri  DECIMAL(6,2) NOT NULL DEFAULT 0,
        e_avrg  DECIMAL(6,2) NOT NULL DEFAULT 0,
        INDEX(date)
    );
    " | mysql kts
    > ${chao}.stati_ban
}

function fn_stat()
{
    case $1 in
    m|mid)
        fn_echo_warn "1000,500换手率"
        LIMIT=1000,1 END=${END} FIELD=tov SELECT lsd
        ASC=DESC LIMIT=500,1 END=${END} FIELD=tov SELECT lsd
        fn_echo_blue "500th成交额"
        LIMIT=500,2 END=${END} SELECT lsd amount
        fn_echo_succ "897(2345*.382),1789(2345*.618*1.235)流通市值"
        ASC=asc LIMIT=897,1  END=${END} FIELD=nmc SELECT lsd
        ASC=asc LIMIT=1789,1 END=${END} FIELD=nmc SELECT lsd
        fn_echo_fail "涨停板amount中位数，top1/3，与amount500th相近"
        num=`OPT='-N' LIMIT=400 END=${END} FIELD=amount SELECT lsd top 2>/dev/null | wc -l`
        let LIMIT=num/2-3
        LIMIT="${LIMIT},2" END=${END} FIELD=amount SELECT lsd top
        let LIMIT=num/3-2
        LIMIT="${LIMIT},2" END=${END} FIELD=amount SELECT lsd top
        fn_echo_succ "***** Layout @${END} ******"
        ;;
    t|time)
        usage="
    Usage:
        u|h     This message
        iF5     iF5
    CONDs:
        code>=300000 and code<400000
        code>=600000 and code<700000
        code<400000
        code<700000
        "
        case ${2:-1} in
        u|h)
            echo "${usage}"; exit
            ;;
        *)
            fn_yist
            for (( iF5=1; iF5<=${NUM:-1}; iF5+=2 )); do
                HMS=`HMS= fn_get_time ${iF5}`
                TEMPDAY="(SELECT * FROM dorat WHERE date='${END}' && time='${HMS}')"
                echo "
                    SELECT sum(amount) FROM ${TEMPDAY} as d $WHERE date='${END}' INTO @curr;
                    SELECT '${END} ${HMS}' as DateTime, 
                        ROUND(@curr/sum(amount), 3) as ratio FROM day as d $WHERE date='${END}' HAVING ${COND:-1};
                " | mysql -N kts
                xt_ret $? "" || return $?
            done
            ;;
        esac
        ;;
    ban)
        fn_create_stati_ban
        dates=(`fn_get_date 1 ${NUM:-3}`)
        local i
        for (( i=0,j=1; i<${#dates[@]}-1; i++,j++ )); do
            export END=${dates[$i]}
            export PREV=${dates[$j]} #echo ${PREV} ${END}; continue
            # 全天
            YIST=  END=${PREV} PARTS=2 LIMIT=300 HAVING="rise>9.93&&avrg<9.93"  chao2=full fn_lsd
            YIST=${chao}.full PARTS=1 LIMIT=300 fn_lsd
            fn_update_stati_ban
            # 上午
            YIST=${chao}.full  END=${PREV} PARTS=2 LIMIT=300 HAVING="rise>9.93"  chao2=mid HMS=13:00:00 fn_lsd 1
            YIST=${chao}.mid PARTS=1 LIMIT=300 fn_lsd
            fn_update_stati_ban
        done

        mysql -t kts <<<"SELECT *,(e_clri-e_opri)as e_next FROM stati_ban"
        fn_echo_succ "
        奇数行，全天数据
        偶数行，上午封板数据
        "
        ;;
    yiz)
        fn_notin_blk FFA1
        fn_create_stati_ban
        dates=(`fn_get_date 1 ${NUM:-3}`)
        local i
        for (( i=0,j=1,k=2; i<${#dates[@]}-2; i++,j++,k++ )); do
            export PREV2=${dates[$k]} 
            export PREV=${dates[$j]}
            export END=${dates[$i]}
            # 一字 
            YIST=  END=${PREV2} PARTS=2 LIMIT=300 HAVING="rise>9.93&&avrg>9.93 ${notinBLK}" chao2=prev2 fn_lsd

            # 开板，PARTS=3时不
            YIST=${chao}.prev2 END=${PREV} PARTS=2 LIMIT=300 HAVING="avrg<9.93" chao2=prev  fn_lsd
            END=${PREV} fn_update_stati_ban

            # 再日
            YIST=${chao}.prev END=${END} PARTS=1 LIMIT=300 fn_lsd
            UPDATE_STATI_CODES=1 \
            END=${END}  fn_update_stati_ban
            xt_ret $? "" || return $?
        done

        mysql -t kts <<<"SELECT *,(e_clri-e_opri)as e_next FROM stati_ban"

        fn_echo_succ "`wc -l ${chao}.stati_ban`"
        ;;
    *)
        echo "
        SELECT stat <param>:
        m   middle of 1160
        t   realtimetov
        ban 涨停板收益统计
        yiz 一字板收益统计
        "
        exit
        ;;
    esac
    return $?
}

function fn_xtempfen()
{
    fen=`fn_get_time $1`
    fn_echo_succ "Peel off time@${fen}..."

    local table=${TBL:-xtempday}
    columns='code,date,yesc,open,high,low,close,volume,amount'

    echo "
    $DROP ${table}; CREATE TABLE ${table} LIKE day;
    INSERT INTO ${table} 
    SELECT ${columns} from dorat WHERE date='${END}' and time='${fen}';
    " | mysql kts
    return $?
}

function fn_topX()
{
    sqls="
    SELECT n.blk FROM blk_name as n, blk_memb as m
     WHERE n.blk=m.blk AND n.blk NOT in ${EXCLUDE_BLK//,0x40/} 
     GROUP by blk
    " 

    blks=`mysql -N kts<<<"${sqls}"`

    if [ -z "${STEP}" ]; then
        fn_xtempday
        xt_ret $? "xtempday error" || return $?
    else
        let NR=STEP++
        fn_xtempfen ${NR}
        xt_ret $? "xtempfen error" || return $?
    fi

    echo "
    $DROP topN;
    $CREATE topN (
        date    date,
        blk     INT,
        sym     CHAR(64),
        SAMPLES INT, 
        rise    DECIMAL(6,2) NOT NULL DEFAULT 0,
        INDEX(date,blk)
    );
    $DROP topX;
    $CREATE topX LIKE topN;
    " | mysql kts

    for i in ${blks}; do
        # mysql -t kts <<< "SELECT code FROM blk_memb WHERE blk=${i}"
        SAMPLES=`mysql -N kts <<< "SELECT IF(count(code)>10, 10, count(code)) FROM blk_memb WHERE blk=${i}"`
        # echo ${SAMPLES}; exit
        echo "
        INSERT INTO topX (date,blk,sym,SAMPLES,rise)
        SELECT '${END}', blk, sym, ${SAMPLES}, sum(rise)/${SAMPLES} FROM
        (
        SELECT d.code, round(100*(close-yesc)/yesc, 2) as rise 
        FROM
        xtempday as d,
        (SELECT code FROM blk_memb WHERE blk=${i}) as b
        WHERE d.code=b.code ORDER by rise DESC LIMIT ${SAMPLES}
        ) as top13, blk_name WHERE blk=${i}
        " | mysql -t kts
    done

    echo "
        DELETE FROM topN WHERE date='${END}';
        INSERT INTO topN SELECT * FROM topX ORDER by rise DESC;
    " | mysql -t kts

    return $?
}

function fn_top()
{
    case $1 in
    l)
        echo "
            SELECT DISTINCT date FROM topN ORDER by date DESC LIMIT ${LIMIT:-15};
        " | mysql -t kts
        ;;
    d)
        sta=$2
        seq=`seq ${sta:-1} ${3}`
        for i in ${seq}; do
            date=`fn_get_date ${i} 1`
            echo "
                DELETE FROM topN WHERE date='${date}'
            " | mysql -t kts
            fn_echo_succ "DELETE ${date} FROM topN done..."
        done
        ;;
    s)
        sta=$2
        for i in `seq ${sta:-1} ${3}`; do
            date=`fn_get_date ${i} 1`
            idate=`mysql -N kts<<<"SELECT DISTINCT date FROM topN WHERE date='${date}'"`
            echo ${date} + ${idate}
            if [ -z "${idate}" ]; then
                fn_echo_succ "CREATE ${date} INTO topN..."
                END=${date} fn_topX
            fi
            echo "
            SELECT date,hex(blk),sym,SAMPLES,rise FROM topN 
                WHERE date='${date}' ORDER by ${FIELD:-rise} DESC LIMIT ${LIMIT:-20};
            " | mysql -t kts
        done
        ;;
    i)
        fn_top d
        STEP=${2:-1} END=${date} fn_topX
        echo "
        SELECT date,hex(blk),sym,SAMPLES,rise FROM topN 
            WHERE date='${date}' ORDER by ${FIELD:-rise} DESC LIMIT ${LIMIT:-20};
        " | mysql -t kts
        ;;
    *)
        echo "
        SELECT blk top 
        l           # list DATE
        d sta end   # 删除 seq(sta,{step,}end)
        s sta end   # 生成&查询
        i [iF5]     # 查询iF5
        u           # USAGE
        "
        ;;
    esac
    
    return $?
}

function fn_blk_delta_codes()
{
    DOOR=${DOOR:-0.5}
    ABBR=d BLK_CAN_NOT_BE_NULL=1 fn_peeloff_blk ${1}
    sqls="
        SELECT d.code, 
            ROUND(100*(d.close-yesc)/yesc,2) as rise, 
            ROUND(100*high/yesc,2) as drise,
            name
        FROM delta as d, cap as c ${frBLK}
        WHERE d.code=c.code ${inBLK}
        HAVING drise>${DOOR} ORDER by ${filed:-drise} DESC
    "

    #echo "${sqls}"; exit
    mysql -t kts <<< "${sqls}"
    xt_ret $? "" || return $?

    CHAO=1 fn_chao ${chao}.opt.drise
    return $?
}

function fn_blk_delta_layout()
{
    sqls="
    SELECT hex(n.blk) as blk,count(m.code) as num, n.sym, 
        max(drise) as maxDri,
        ROUND( sum(drise)/count(m.code), 2 ) as avDri,
        ROUND( sum( rise)/count(m.code), 2 ) as avri
        FROM blk_name as n, blk_memb as m,
        (
        SELECT code, ROUND(100*(close-yesc)/yesc,2) as rise, 
            ROUND(100*high/yesc,2) as drise FROM delta 
            HAVING drise>${DOOR} ORDER by drise DESC
        ) as dlt
        $WHERE m.blk=n.blk && m.code=dlt.code AND m.blk not in ${EXCLUDE_BLK}
        GROUP by blk 
        HAVING 1 ${COND}
        ORDER by num ${ASC:-DESC}, ${1:-avDri} DESC LIMIT ${LIMIT:-20};
    "

    #echo "${sqls}"; exit
    mysql -t kts <<< "${sqls}"
    return $?

}

function fn_blk_delta()
{
    let NR=${1}+1
    HMS1=`fn_get_time`          # HMS不精确时亦可用
    HMS2=`fn_get_time ${NR}`

    echo "\
    end: ${HMS1}
    sta: ${HMS2}\
    " | tee ${info}.delta
    columns="code,date,yesc,open,high,low,close,volume,amount"

    echo "
    $DROP delta;
    $CREATE delta LIKE day;
    INSERT INTO delta 
    SELECT t1.code,t1.date,t1.yesc,t1.open, (t1.close-t2.close), t1.low,t1.close,t1.volume,t1.amount
    FROM 
    ( SELECT ${columns} FROM dorat WHERE date='${END}' and time='${HMS1}' ) as t1,
    ( SELECT ${columns} FROM dorat WHERE date='${END}' and time='${HMS2}' ) as t2
    WHERE t1.code=t2.code;
    " | mysql kts

    fn_echo_succ "    gen delta succ!"
    return $?
}

function fn_blk()
{
    EXCLUDE_BLK="(
    0xCE54,  -- 898 | 融资融券    
    0xDAE8,  -- 574 | 沪港通概念  
    0xDBD4,  -- 316 | 股东增持    
    0xDA4D,  -- 305 | 央企国资改革
    0xD953,  -- 243 | 参股金融    
    0xD886,  -- 100 | 证金持股
    0xDB9B   -- 81  | 转融券标的
-- ,0x40     -- 226 | 新股与次新股
    )"
#   EXCLUDE_BLK="(0x1234)"

    case $1 in
    top)
        fn_top ${@:2}
        ;;
    l|layout)
       #ABBR=m fn_notin_blk FFA1
        ABBR=m fn_yist
        FIELD=${2}
        echo "
        SELECT hex(n.blk) as blk,count(m.code) as num,n.sym FROM blk_name as n, blk_memb as m
         $WHERE n.blk=m.blk AND n.blk not in ${EXCLUDE_BLK} ${notinBLK}
         GROUP by blk ORDER by ${FIELD:-num} ${ASC:-DESC} LIMIT ${LIMIT:-20};
        " | mysql -t kts
        ;;
    10)
        fn_echo_succ "Classify @${END}"
        ABBR=m fn_yist
        CHAO=1 LIMIT=3000 COND="rise>${DOOR:-9.93}" SELECT lsd ${2}> /dev/null
        YIST='/tmp/kts/chao.lsd' fn_blk layout
        ;;
    ban)
        ABBR=m fn_notin_blk FFA1
        DZH=N CHAO=1 fn_blk u ${BLK} > /dev/null
        xt_ret $? "BLK:${BLK}" || return $?
        YIST='/tmp/kts/chao.opt.union' \
        COND="rise>${DOOR:-9.93}" SELECT lsd ${@:2}
        xt_ret $? "" || return $?
        ;;
    delta)
        case $2 in
        s|step)
            fn_blk_delta ${3:-1}
            ;;
        l|layout)
            # 从3个维度考量：数量、delta涨幅、最高涨幅
            fn_echo_warn "DOOR:${DOOR:=0.5}"
            cat ${info}.delta
            fn_blk_delta_layout ${@:3}
            ;;
        b|blk)
            fn_blk_delta_codes ${3}
            ;;
        *)
            echo "SELECT blk delta
            s       STEP    # \$HMS不指定时，默认15:05:00
            l       FIELD   # layout {DOOR:-0.5}
            b       BLK     # 单独展示一个BLK的细节
            "
            ;;
        esac
        ;;
    66)
        fn_peeloff_blk
        off=${2:-1}
        sta=`fn_get_date ${off}`
        fn_sqls() {
        sqls="
        SELECT d.code,sum(${RISE}) as rise, ${nmcYi}, c.name FROM day as d, cap as c ${frBLK}
            ${WHERE} d.code=c.code and d.date>='${sta}' && d.date<='${END}' ${inBLK}
            GROUP by code 
            HAVING ${HAVING:-1} ${COND} and rise>${DOOR:-'-100'}
            ORDER BY ${FIELD:-rise} ${ASC:-desc} LIMIT ${LIMIT:-36}
        " 
        }
        fn_sqls
        #echo "${sqls}" ; exit
        mysql -t kts <<< "${sqls}"
        LIMIT=3000 fn_sqls
        fn_chao ${chao}.opt.66
        ;;
    123)
        size=${2:-3}
        xCOND="TRUNCATE(100*(close-yesc)/yesc, 2)>${DOOR:-9.93}"
        dates=(`fn_get_date 1 ${size}`)

        for (( i=${size}-1; i>=0; i-- )); do
            date=${dates[$i]}
            fn_xtempday ${date}
            fn_echo_succ "DOOR date: ${date}"
            echo "
            SELECT hex(n.blk) as blk, count(m.code) as num, n.sym FROM blk_name as n, blk_memb as m, xtempday as d
            WHERE n.blk=m.blk and m.code=d.code && m.blk not in ${EXCLUDE_BLK}
             GROUP by blk 
             ORDER by num DESC LIMIT ${LIMIT:-16};
            " | mysql -t kts
        done
        ;;
    c|code)
        for code in ${@:2}; do
            fn_iscode ${code}
            xt_ret $? "" || return $?
            fn_name ${code}

            FIELD=${3:-blk}
            echo "
             SELECT m.code, hex(n.blk) as blk, n.sym FROM blk_name as n, blk_memb as m
             WHERE n.blk=m.blk and code=${code}
             ORDER by ${FIELD} DESC LIMIT ${LIMIT:-36};
            " | mysql -t kts
        done
        ;;
    f|find)
        fn_echo_blue "to find ${2}"
        LIMIT=300 fn_blk l | grep ${2}
        ;;
    d|dif)
        ABBR=T1 fn_yist
        sqls="
        SELECT T1.code, name FROM
        (SELECT code FROM blk_memb WHERE blk=0x${2}) as T1, cap
        $WHERE T1.code=cap.code AND T1.code NOT IN 
        (SELECT code FROM blk_memb WHERE blk=0x${3})
        "
        #echo "${sqls}"; exit
        mysql -t kts <<< "${sqls}"
        fn_chao ${chao}.opt.dif
        ;;
    !)  
        if [ -z "${YIST}" ]; then
            fn_echo_fail "Usage: YIST=xxx SELECT ! blk..."
            exit
        fi
        ABBR=c fn_yist
        ABBR=c fn_peeloff_blk
        sqls="
        SELECT c.code, name FROM cap as c ${frBLK}
        $WHERE c.code NOT IN (SELECT code FROM xblk)
        "
        mysql -t kts <<< "${sqls}"
        fn_chao ${chao}.opt.minus
        ;;
    A|intersection)
        ABBR=T1 fn_yist
        sqls="
        SELECT T1.code, name FROM
        (SELECT code FROM blk_memb WHERE blk=0x${2}) as T1,
        (SELECT code FROM blk_memb WHERE blk=0x${3}) as T2, cap
        $WHERE T1.code=T2.code && T1.code=cap.code
        "
        #echo "${sqls}"; exit
        mysql -t kts <<< "${sqls}"
        fn_chao ${chao}.opt.A
        ;;
    u|union)
        fn_echo_succ ${notinBLK}
        BLK=${@:2}
        ABBR=m fn_yist
        ABBR=m fn_peeloff_blk
       #sql_exclude="&& blk NOT IN ${EXCLUDE_BLK}"
        sqls="
        SELECT m.code,count(m.code) as num, ${nmcYi}, c.name 
               FROM blk_memb as m, cap as c ${frBLK}
        ${WHERE} m.code=c.code ${inBLK} ${sql_exclude}
        GROUP by code HAVING 1 ${COND} ${notinBLK}
        ORDER by num ASC LIMIT ${LIMIT:-500}
        " 
        #echo "${sqls}">/dev/stderr; exit
        mysql -t kts <<< "${sqls}"
        fn_chao ${chao}.opt.union
        ;;
    *)
        echo "
        SELECT blk <param>  # 注：使用HAVING向<SELECT lsd>传递条件
        l                   # layout
        10      iF5         # 涨停板概念分类 {DOOR:-10}，查讯iF5: SELECT lohi l
        ban     iF5         # 列出变量BLK关联的code涨幅，iF5为5分钟数据索引
        delta   {s|l|b}     # 做差、显示layout、显示layout中一个BLK的细节
        66      off         # off日内代码累计涨幅
        123     size        # for(i<size)循环_10_的内容，但这是平均值
        c       code        # 显示code关联的所有板块
        !       blk [...]   # FROM YIST not in (blk...)
        d       big small   # 求两个blk的差集 big-small 
        A       blk blk2    # 求两个blk的交集
        u       blk [...]   # 求几个blk的并集(.c时可作为输出)
                            # blk中code关联的blk数目排名，越小，概念越纯正。
        top     arg...      # [热点]分析
        "
        ;;
    esac

    return $?
}

function fn_yysj()
{

    case $1 in
    d|date)
        echo "
        SELECT DISTINCT date FROM yysj ORDER by date ASC;
        " | mysql -t kts
        fn_echo_warn "Usage: SELECT yysj d <date>"
        exit
        ;;
    s|select)
        sqls="
        SELECT * FROM yysj 
        HAVING ${HAVING:-1} ${COND} ${sql_date} ORDER BY ${FIELD:-date} ${ASC:-asc} LIMIT ${LIMIT:-36}
        "    
        mysql ${OPT:--t} kts <<<"${sqls}"
        fn_chao ${chao}.yysj
        ;;
    *|u|h)
        echo "Usage: SELECT yysj {date|select}"
        ;;
    esac
}

function fn_dde()
{
    NUM=${NUM:-4}
    dates=(`fn_get_date 1 ${NUM}`)
    let NUM=NUM-1

    local i
    for (( i=0; i<${NUM}; i+=1 )); do
        let j=i+1
        iCURR=${dates[$i]}
        iPREV=${dates[$j]}
        #echo ${iCURR} ${iPREV}
        sqls="
        SELECT C.code FROM 
        (SELECT code,net FROM dde WHERE date='${iCURR}') as C,
        (SELECT code,net FROM dde WHERE date='${iPREV}') as P
        ${WHERE} C.code=P.code and C.net>=P.net
        "
        mysql -N kts <<<"${sqls}" > ${chao}.dde

        fn_echo_warn "got `wc -l<${chao}.dde` @${iCURR} ${j}"

        if [ "${j}" -eq ${NUM} ]; then
            fn_echo_succ "gen zxg fro 10jqka"
            PLAIN=${chao}.dde fn_gen_10jqka_sel
        else
            ABBR=C YIST=${chao}.dde fn_yist
        fi
    done
    
    return $?
}


function fn_max()
{
    STA=`fn_get_date ${1:-5} 1` #echo ${STA}
    let half=${1}/2
    sqls="
    SELECT date,code,close,max(close),count(code) as num  FROM
    ( SELECT * FROM day $WHERE date>='${STA}' && date<='${END}' ORDER by date DESC ) as d
    GROUP by code HAVING max(date)='${END}' && close=max(close) && num>${half};
    "

    if [ "${1}" -gt 5 ]; then
        mysql -t kts <<<"${sqls}"
    fi

    fn_chao ${chao}.${chao2:-max20}
    chao2=

    return $?
}


function fn_g20()
{
    CHAO=1 chao2=max5 fn_max 5
    YIST=${chao}.max5 chao2=max${1} fn_max ${1:-20}
    return $?
}

function fn_dive()
{
    dates=`fn_get_date 1 ${1:-10}`

    local i=
    for i in ${dates}; do
        COND="dive>${DOOR:-10}" END=${i} FIELD=dive SELECT lsd
    done

    return $?
}

function fn_ATR()
{
    NUM=${NUM:-40}
    STA=`fn_get_date ${NUM} 1` #echo ${STA}
    let half=${NUM}/${PARTS:-4}

    if [ -n "${*}" ]; then
        echo ${*} | xargs -n1 > /tmp/kts/chao.ATR.in
        YIST='/tmp/kts/chao.ATR.in'
    else
        CONDbig="and max(date)='${END}'"    # 当天阳线
    fi

    fn_yist

    sqls="
    SELECT * FROM (
        SELECT date,code, 
            ROUND( sum( 100*GREATEST(high-low, high-yesc, yesc-low)/yesc )/count(code), 2 ) as ATR,
            count(code) as num FROM
        ( SELECT d.* FROM day as d $WHERE date>='${STA}' && date<='${END}' && high!=low && close>yesc
          ORDER by date DESC ) as d2
        GROUP by code HAVING num>${half} ${CONDbig}
    ) as t 
    ORDER by ATR DESC LIMIT ${LIMIT:-200}
    "

    #echo "${sqls}"; exit
    mysql -t kts <<<"${sqls}"

    fn_chao ${chao}.${chao2:-ATR}

    return $?
}

function fn_wee()
{
    NUM=${NUM:-3}
    end1=${END}
    sta1=`fn_get_date ${NUM} 1`
    end2=`END=${sta1} fn_get_date 2 1`
    sta2=`END=${end2} fn_get_date ${NUM} 1`
    end3=`END=${sta2} fn_get_date 2 1`
    sta3=`END=${end3} fn_get_date ${NUM} 1`

    #echo $end1 $sta1 $end2 $sta2 $end3 $sta3; exit

    fn_tbl() {
    echo "
    ( SELECT date,code, ROUND( sum(volume)/count(code), 2 ) as mavol 
        FROM
        ( SELECT d.* FROM day as d $WHERE date>='${1}' && date<='${2}'
          ORDER by date DESC 
        ) as d2 GROUP by code
    )"
    }

    fn_yist
    t1="`fn_tbl ${sta1} ${end1}`"
    t2="`fn_tbl ${sta2} ${end2}`"
    t3="`fn_tbl ${sta3} ${end3}`"

    sqls="
    SELECT t1.code,
        ROUND(t2.mavol/t3.mavol,2) as w1,
        ROUND(t1.mavol/t2.mavol,2) as w2,
        ROUND(100*t1.mavol*c.close/c.nmc,2) as tov FROM
        ${t1} as t1,
        ${t2} as t2,
        ${t3} as t3,
        cap   as c
        WHERE t1.code=c.code && t1.code=t2.code && t1.code=t3.code && t2.mavol>t3.mavol
        HAVING 1 ${COND}
        ORDER by ${FIELD:-tov} DESC
        LIMIT ${LIMIT:-200}
    "

    #echo "${sqls}"; exit
    mysql -t kts <<<"${sqls}"
    fn_chao ${chao}.${chao2:-eek}${NUM}
    return $?
}

function fn_notice()
{
  helpmsg="
  c     clean空文件
  消息  高开低走有惊喜: 2015-12-11.亿帆鑫富
  获+   是重要的关键字
  "
    cmdlist=(
    "非公开发行限售股           -----注意黑天鹅------"
    "增持                       看增持数量"
    "收购                       若关联定向增发，增发价可作为支撑"
    "签署战略                   VR"
    "重大合同"
    "[^重].合同"
    "利润分配                   高送转预案"
    "高送转"
    "股东权益变动               举牌"
    "回购.*股份                 国内回购只能注销，是真自救"
    "挂牌转让"
    )
    cd /opt/notice/
    case $1 in
    [036][0-9][0-9][0-9]*)
        grep --color "${1}" * ;;
    +([0-9]))
        [ $1 -ge ${#cmdlist[@]} ] && \
        fn_execute --list && fn_echo_fail "  -- fn_execute $1 too big --\n" && return
        cmd=${cmdlist[$1]/ */}
        grep --color "${cmd}" `ls -t | head -${NUM:-7}`
        ;;
    c|clean)
        wc -l * | grep -w 0 | awk '{print $2}' | xargs rm -f
        ;;
    *|l|--list)
        fn_execute
        ;;
    esac

    
    return $?
}

function fn_main()
{
    cmdlist=(
    "dugu9jian          [sortfield]           # chng只是(close-open)/open"
    "6maishenjian       [sortfield]           # chng只是(close-open)/open"
    "comma              [tbl_name:-day]       # 逗分列名"
    "list_date          num                   # num默认10"
    "wma                [sortfield:tov5]      # 均价+现成513.静态rat"
    "rat                [sortfield:-ratio]    # wma+day-->动态rat，实时速度快"
    "dorat                                    # 时间为表名list"
    "dirtio                                   # diff(dorat)"
    "ma240              [sortfield:-ratio]    # "
    "ma240_usage        {1~9}                 # 分析ma 5 13 34 55"
    "dif120             code...               # cost:(close-ma120) & sort by #{ASC:id}"
    "stat                                     # 大盘统计"
    # ----------------  ABOVE IS FIXED SEQUENCE --------------------
    "xrd                FIELD                 # #{OP:->}"
    "ace                sta num               # 10日内所有+10% amount nmc 统计"
    "cap                code                  # 查询nmc&cap"
    "name               code                  # 名"
    "pma                code                  # NUM=5日平均"
    "fbi                                      # tbl_fbi"
    #td_layout          code                  # 日内最高价时点分布.10:00am"
    #acc                                      # tbl_adiff"
    #acf                                      # tbl_acfdiff"
    #tao5                                     # "
    #rdiff                                    # tbl_rdiff"
    #tri                                      # 3连阳"
    #dive                                     # 跳水第2日买进"
    #ban                condi [time]          # 条件. 0945后使用"
    #sban               condi [time]          # super ban"
    "vol                {0|3|6|03}            # ^^3市成交^^"
    "ls                 {code|symbol}         # 日线数据 \$LIMIT"
    "lsd                [{top|floor}][FIELD]  # --- END YIST LIMIT 涨幅排名"
    "updown                                   # 近期{NUM=5}涨跌家数统计"
    "hilo               FIELD                 # 跌幅统计"
    "lohi               FIELD                 # 涨幅统计"
    "wee                                      # NUM日成交量放大倍数"
    "g20                                      # 创20日新高"
    "lhb                excption              # 龙虎榜"
    "wolf                                     # DDE"
    "dde                                      # DDE"
    "macd               [clean]               # macd-alarm-sys"
    "fmacd                                    # 单个代码的macd"
    "blk                                      # 板块信息"
    "yysj                                     # 预约时间"
    "scale                                    # 成交量放大倍数"
    "ATR                                      # AverageTrueRangeOf阳线非一字板"
    "notice                                   # 公告"
    )

    # `ASC=任意值`时使用'DESC'，弃用
    # ASC=${ASC:+'DESC'}  # ASC=${ASC:-'ASC'}
    # ASC=${ASC:-'ASC'}
    fn_set_END
    fn_execute "$@"
}

fn_main "$@"

# http://www.cnblogs.com/zhenjing/archive/2011/07/15/process_mutex_race.html
# 获取最大ID的记录

